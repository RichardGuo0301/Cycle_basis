Batch testing 100 random combinations of r, tau, and blocked edges
Map topology is identical across trials.


================================================================================
TRIAL 0
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 3, 3, 1, 2, 2] → J=243, T=200, cost=0 → queued

[Iter 1] cost=0, J=243, T=200, edges=35, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 3, 3, 1, 2, 2]
  [backtrack] Found solution with 512 backtracks in 0.00s
  [backtrack] Found solution with 194 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=199.6s
  DFS: latency violated (1 nodes, worst_gap=126.7s)
  Boundary nodes: [0, 2, 4, 6, 7, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 3, 3, 1, 2, 2] → J=230, T=198, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2] → J=241, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 3, 3, 1, 2, 2] → J=232, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 3, 1, 2, 2] → J=238, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 4, 3, 1, 2, 2] → J=240, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2] → J=241, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 3, 3, 1, 3, 2] → J=241, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 3, 3, 1, 2, 3] → J=239, T=199, cost=1 → queued

[Iter 2] cost=1, J=241, T=199, edges=35, frontier=7, MILP_calls=9
  V_MIN=[2, 2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2]
  [backtrack] Found solution with 8 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.2s
  *** SOLUTION FOUND! J=241, T_tour=199.2s ***

============================================================
Search done: 2 iters, 9 MILP calls, 9 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -3, -3, 4, 0, -2, -1, -2, 0, -1, -2, 2, 0, 2, 0, 3, -3, 0, 0, 2, -1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -3, -3, 4, 0, -2, -1, -2, 0, -1, -2, 2, 0, 2, 0, 3, -3, 0, 0, 2, -1]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-3)), ((1, 3), np.int64(-3)), ((1, 5), np.int64(4)), ((2, 8), np.int64(-2)), ((2, 11), np.int64(-1)), ((3, 4), np.int64(-2)), ((3, 8), np.int64(-1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(2)), ((6, 9), np.int64(2)), ((7, 8), np.int64(3)), ((7, 10), np.int64(-3)), ((9, 10), np.int64(2)), ((10, 11), np.int64(-1))]

Blocked edge 1: idx=2, edge=(1, 2), flow_B=-3  →  need Cm[2]=3
Blocked edge 2: idx=14, edge=(6, 9), flow_B=2  →  need Cm[14]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=31   ||Cm||_1=19

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [3, 1, -1, -1, -1, 0, 0, 0, 1, 1, -1]

Cm = C_oriented @ beta*:
  [0, 0, 3, -2, -1, 2, 0, 1, 1, -1, 0, 1, 0, 1, -2, 0, 1, 0, 1, 0, -1, -1]

Original flow_B:
  [-2, 2, -3, -3, 4, 0, -2, -1, -2, 0, -1, -2, 2, 0, 2, 0, 3, -3, 0, 0, 2, -1]

flow_B + Cm (corrected flow):
  [-2, 2, 0, -5, 3, 2, -2, 0, -1, -1, -1, -1, 2, 1, 0, 0, 4, -3, 1, 0, 1, -2]

Verification:
  flow_corrected[2] = 0  (should be 0, Cm=3, d=3)
  flow_corrected[14] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 31  (minimized by MIQP)
  ||Cm||_1  = 19
  ||flow_B||_2² = 87
  ||flow_corrected||_2² = 90

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    6.3          
    1     (0, 11)         2       0           2    7.7          
    2      (1, 2)        -3       3           0    4.3    -12.9s ← BLOCKED
    3      (1, 3)        -3      -2          -5    4.3     +8.6s
    4      (1, 5)         4      -1           3    4.1     -4.1s
    5      (2, 3)         0       2           2    7.3    +14.6s
    6      (2, 8)        -2       0          -2    7.1          
    7     (2, 11)        -1       1           0    7.5     -7.5s
    8      (3, 4)        -2       1          -1    7.9     -7.9s
    9      (3, 6)         0      -1          -1    7.2     +7.2s
   10      (3, 8)        -1       0          -1    5.8          
   11      (4, 5)        -2       1          -1    7.1     -7.1s
   12      (5, 6)         2       0           2    4.5          
   13      (6, 7)         0       1           1    6.6     +6.6s
   14      (6, 9)         2      -2           0    4.6     -9.2s ← BLOCKED
   15     (6, 10)         0       0           0    7.8          
   16      (7, 8)         3       1           4    6.1     +6.1s
   17     (7, 10)        -3       0          -3    5.7          
   18      (8, 9)         0       1           1    5.1     +5.1s
   19     (8, 11)         0       0           0    7.1          
   20     (9, 10)         2      -1           1    5.8     -5.8s
   21    (10, 11)        -1      -1          -2    6.3     +6.3s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=5, out=5  OK
  Node 2: in=2, out=2  OK
  Node 3: in=5, out=5  OK
  Node 4: in=1, out=1  OK
  Node 5: in=3, out=3  OK
  Node 6: in=2, out=2  OK
  Node 7: in=4, out=4  OK
  Node 8: in=4, out=4  OK
  Node 9: in=1, out=1  OK
  Node 10: in=3, out=3  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 20

  Summary:
    Original path length:  35 edges
    Spliced path length:   34 edges
    Splices performed:     20
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)          -5        -5  ✓
    4      (1, 5)           3         3  ✓
    5      (2, 3)           2         2  ✓
    6      (2, 8)          -2        -2  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -1        -1  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)          -1        -1  ✓
   12      (5, 6)           2         2  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           4         4  ✓
   17     (7, 10)          -3        -3  ✓
   18      (8, 9)           1         1  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)          -2        -2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 1
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3] → J=171, T=200, cost=0 → queued

[Iter 1] cost=0, J=171, T=200, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3]
  [backtrack] EXHAUSTED search space (618 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (399 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (487 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (274 backtracks in 0.00s)
  [backtrack] Found solution with 480 backtracks in 0.00s
  [backtrack] Found solution with 458 backtracks in 0.00s
  [backtrack] Found solution with 663 backtracks in 0.00s
  [backtrack] Found solution with 40 backtracks in 0.00s
  [backtrack] Found solution with 447 backtracks in 0.00s
  [backtrack] Found solution with 593 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (633 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (583 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=81.4s)
  Boundary nodes: [3, 4, 5, 7] → expanding 4 children
    V_MIN=[2, 3, 1, 3, 2, 2, 2, 2, 2, 2, 2, 3] → J=168, T=200, cost=1 → queued
    V_MIN=[2, 3, 1, 2, 3, 2, 2, 2, 2, 2, 2, 3] → J=158, T=200, cost=1 → queued
    V_MIN=[2, 3, 1, 2, 2, 3, 2, 2, 2, 2, 2, 3] → J=164, T=200, cost=1 → queued
    V_MIN=[2, 3, 1, 2, 2, 2, 2, 3, 2, 2, 2, 3] → J=167, T=200, cost=1 → queued

[Iter 2] cost=1, J=168, T=200, edges=36, frontier=3, MILP_calls=5
  V_MIN=[2, 3, 1, 3, 2, 2, 2, 2, 2, 2, 2, 3]
  [backtrack] Found solution with 214 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.5s
  *** SOLUTION FOUND! J=168, T_tour=199.5s ***

============================================================
Search done: 2 iters, 5 MILP calls, 5 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -1, -3, 2, 0, 0, -1, -2, 0, -1, -2, 0, 1, -4, 3, 2, -1, 4, -3, 0, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -1, -3, 2, 0, 0, -1, -2, 0, -1, -2, 0, 1, -4, 3, 2, -1, 4, -3, 0, 2]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-1)), ((1, 3), np.int64(-3)), ((1, 5), np.int64(2)), ((2, 11), np.int64(-1)), ((3, 4), np.int64(-2)), ((3, 8), np.int64(-1)), ((4, 5), np.int64(-2)), ((6, 7), np.int64(1)), ((6, 9), np.int64(-4)), ((6, 10), np.int64(3)), ((7, 8), np.int64(2)), ((7, 10), np.int64(-1)), ((8, 9), np.int64(4)), ((8, 11), np.int64(-3)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=1, edge=(0, 11), flow_B=2  →  need Cm[1]=-2
Blocked edge 2: idx=14, edge=(6, 9), flow_B=-4  →  need Cm[14]=4
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=45   ||Cm||_1=23

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-2, -2, 1, 3, 1, 1, 2, 1, -1, -1, 2]

Cm = C_oriented @ beta*:
  [2, -2, 0, 1, 1, -1, 0, 1, 0, 1, -1, 0, 1, -1, 4, -1, 0, -1, -1, 0, 3, 1]

Original flow_B:
  [-2, 2, -1, -3, 2, 0, 0, -1, -2, 0, -1, -2, 0, 1, -4, 3, 2, -1, 4, -3, 0, 2]

flow_B + Cm (corrected flow):
  [0, 0, -1, -2, 3, -1, 0, 0, -2, 1, -2, -2, 1, 0, 0, 2, 2, -2, 3, -3, 3, 3]

Verification:
  flow_corrected[1] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[14] = 0  (should be 0, Cm=4, d=4)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 45  (minimized by MIQP)
  ||Cm||_1  = 23
  ||flow_B||_2² = 92
  ||flow_corrected||_2² = 77

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       2           0    4.8     -9.6s
    1     (0, 11)         2      -2           0    7.5    -15.0s ← BLOCKED
    2      (1, 2)        -1       0          -1    4.1          
    3      (1, 3)        -3       1          -2    6.7     -6.7s
    4      (1, 5)         2       1           3    5.7     +5.7s
    5      (2, 3)         0      -1          -1    6.2     +6.2s
    6      (2, 8)         0       0           0    4.6          
    7     (2, 11)        -1       1           0    4.8     -4.8s
    8      (3, 4)        -2       0          -2    7.2          
    9      (3, 6)         0       1           1    7.9     +7.9s
   10      (3, 8)        -1      -1          -2    5.3     +5.3s
   11      (4, 5)        -2       0          -2    6.8          
   12      (5, 6)         0       1           1    7.5     +7.5s
   13      (6, 7)         1      -1           0    7.6     -7.6s
   14      (6, 9)        -4       4           0    4.3    -17.2s ← BLOCKED
   15     (6, 10)         3      -1           2    4.2     -4.2s
   16      (7, 8)         2       0           2    4.7          
   17     (7, 10)        -1      -1          -2    7.5     +7.5s
   18      (8, 9)         4      -1           3    4.4     -4.4s
   19     (8, 11)        -3       0          -3    5.7          
   20     (9, 10)         0       3           3    7.8    +23.4s
   21    (10, 11)         2       1           3    6.1     +6.1s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=3, out=3  OK
  Node 2: in=1, out=1  OK
  Node 3: in=4, out=4  OK
  Node 4: in=2, out=2  OK
  Node 5: in=3, out=3  OK
  Node 6: in=2, out=2  OK
  Node 7: in=2, out=2  OK
  Node 8: in=5, out=5  OK
  Node 9: in=3, out=3  OK
  Node 10: in=5, out=5  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 33 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 17

  Summary:
    Original path length:  36 edges
    Spliced path length:   33 edges
    Splices performed:     17
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)          -1        -1  ✓
    3      (1, 3)          -2        -2  ✓
    4      (1, 5)           3         3  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)          -2        -2  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           2         2  ✓
   16      (7, 8)           2         2  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           3         3  ✓
   19     (8, 11)          -3        -3  ✓
   20     (9, 10)           3         3  ✓
   21    (10, 11)           3         3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 2
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3, 3] → J=192, T=199, cost=0 → queued

[Iter 1] cost=0, J=192, T=199, edges=39, frontier=0, MILP_calls=1
  V_MIN=[2, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3, 3]
  [backtrack] Found solution with 29 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.1s
  *** SOLUTION FOUND! J=192, T_tour=199.1s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 2, 0, 0, -3, 0, 5, -2, -1, 0, -2, -2, 0, 0, -3, -4, 4, -2, -2, -2, -1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 2, 0, 0, -3, 0, 5, -2, -1, 0, -2, -2, 0, 0, -3, -4, 4, -2, -2, -2, -1]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(2)), ((2, 3), np.int64(-3)), ((2, 11), np.int64(5)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(-1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-2)), ((6, 10), np.int64(-3)), ((7, 8), np.int64(-4)), ((7, 10), np.int64(4)), ((8, 9), np.int64(-2)), ((8, 11), np.int64(-2)), ((9, 10), np.int64(-2)), ((10, 11), np.int64(-1))]

Blocked edge 1: idx=16, edge=(7, 8), flow_B=-4  →  need Cm[16]=4
Blocked edge 2: idx=11, edge=(4, 5), flow_B=-2  →  need Cm[11]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=48   ||Cm||_1=24

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, 0, -1, 1, 0, 1, 0, 3, 1, 1, 2]

Cm = C_oriented @ beta*:
  [0, 0, 0, 1, -1, 0, -1, 1, 2, 1, -2, 2, 1, 3, 0, -1, 4, -1, 1, 0, 1, -1]

Original flow_B:
  [2, -2, 2, 0, 0, -3, 0, 5, -2, -1, 0, -2, -2, 0, 0, -3, -4, 4, -2, -2, -2, -1]

flow_B + Cm (corrected flow):
  [2, -2, 2, 1, -1, -3, -1, 6, 0, 0, -2, 0, -1, 3, 0, -4, 0, 3, -1, -2, -1, -2]

Verification:
  flow_corrected[16] = 0  (should be 0, Cm=4, d=4)
  flow_corrected[11] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 48  (minimized by MIQP)
  ||Cm||_1  = 24
  ||flow_B||_2² = 113
  ||flow_corrected||_2² = 109

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    4.5          
    1     (0, 11)        -2       0          -2    6.1          
    2      (1, 2)         2       0           2    4.7          
    3      (1, 3)         0       1           1    7.1     +7.1s
    4      (1, 5)         0      -1          -1    7.4     +7.4s
    5      (2, 3)        -3       0          -3    6.0          
    6      (2, 8)         0      -1          -1    7.4     +7.4s
    7     (2, 11)         5       1           6    4.3     +4.3s
    8      (3, 4)        -2       2           0    6.0    -12.0s
    9      (3, 6)        -1       1           0    4.3     -4.3s
   10      (3, 8)         0      -2          -2    5.7    +11.4s
   11      (4, 5)        -2       2           0    4.4     -8.8s ← BLOCKED
   12      (5, 6)        -2       1          -1    4.5     -4.5s
   13      (6, 7)         0       3           3    6.4    +19.2s
   14      (6, 9)         0       0           0    4.9          
   15     (6, 10)        -3      -1          -4    4.4     +4.4s
   16      (7, 8)        -4       4           0    4.9    -19.6s ← BLOCKED
   17     (7, 10)         4      -1           3    5.4     -5.4s
   18      (8, 9)        -2       1          -1    5.9     -5.9s
   19     (8, 11)        -2       0          -2    4.8          
   20     (9, 10)        -2       1          -1    6.6     -6.6s
   21    (10, 11)        -1      -1          -2    5.9     +5.9s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=3, out=3  OK
  Node 2: in=6, out=6  OK
  Node 3: in=3, out=3  OK
  Node 5: in=1, out=1  OK
  Node 6: in=4, out=4  OK
  Node 7: in=3, out=3  OK
  Node 8: in=3, out=3  OK
  Node 9: in=1, out=1  OK
  Node 10: in=5, out=5  OK
  Node 11: in=6, out=6  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 37 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 19

  Summary:
    Original path length:  39 edges
    Spliced path length:   37 edges
    Splices performed:     19
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           2         2  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)          -3        -3  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           6         6  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)          -2        -2  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)           3         3  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)          -4        -4  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)           3         3  ✓
   18      (8, 9)          -1        -1  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)          -1        -1  ✓
   21    (10, 11)          -2        -2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 3
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 1, 2] → J=217, T=199, cost=0 → queued

[Iter 1] cost=0, J=217, T=199, edges=36, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 1, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 6, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 2, 2, 3, 3, 2, 2, 2, 2, 1, 2] → J=206, T=197, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 3, 3, 2, 2, 2, 2, 1, 2] → J=213, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 3, 3, 2, 2, 2, 1, 2] → J=211, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 3, 2, 3, 2, 2, 1, 2] → J=200, T=197, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 3, 2, 2, 3, 2, 1, 2] → J=211, T=198, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 3, 2, 2, 2, 3, 1, 2] → J=202, T=198, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2] → J=212, T=198, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 1, 3] → J=206, T=199, cost=1 → queued

[Iter 2] cost=1, J=213, T=200, edges=36, frontier=7, MILP_calls=9
  V_MIN=[2, 2, 3, 2, 3, 3, 2, 2, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (1003 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (776 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1023 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1634 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1633 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1986 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (627 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (318 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (467 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (583 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (342 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1172 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 6, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 3, 2, 3, 3, 2, 2, 2, 2, 1, 2] → J=200, T=197, cost=2 → queued
    V_MIN=[2, 2, 4, 2, 3, 3, 2, 2, 2, 2, 1, 2] → J=204, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 3, 3, 2, 2, 2, 1, 2] → J=208, T=198, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 3, 2, 3, 2, 2, 1, 2] → J=192, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 3, 2, 2, 3, 2, 1, 2] → J=204, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 3, 2, 2, 2, 3, 1, 2] → J=194, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 2] → J=202, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 3, 2, 2, 2, 2, 1, 3] → J=202, T=200, cost=2 → queued

[Iter 3] cost=1, J=212, T=198, edges=36, frontier=14, MILP_calls=17
  V_MIN=[2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 9 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.4s
  *** SOLUTION FOUND! J=212, T_tour=198.4s ***

============================================================
Search done: 3 iters, 17 MILP calls, 17 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 0, -4, 6, 0, -2, 2, -4, 0, 0, -4, 2, 0, 2, 0, 2, -2, 0, 0, 2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 0, -4, 6, 0, -2, 2, -4, 0, 0, -4, 2, 0, 2, 0, 2, -2, 0, 0, 2, 0]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 3), np.int64(-4)), ((1, 5), np.int64(6)), ((2, 8), np.int64(-2)), ((2, 11), np.int64(2)), ((3, 4), np.int64(-4)), ((4, 5), np.int64(-4)), ((5, 6), np.int64(2)), ((6, 9), np.int64(2)), ((7, 8), np.int64(2)), ((7, 10), np.int64(-2)), ((9, 10), np.int64(2))]

Blocked edge 1: idx=14, edge=(6, 9), flow_B=2  →  need Cm[14]=-2
Blocked edge 2: idx=3, edge=(1, 3), flow_B=-4  →  need Cm[3]=4
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=42   ||Cm||_1=20

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-2, 0, 0, 0, 0, -1, 0, 1, 0, 2, -1]

Cm = C_oriented @ beta*:
  [0, 0, -2, 4, -2, -2, 0, 0, 1, 0, 1, 1, -1, 1, -2, 0, 1, 0, 2, 0, 0, 0]

Original flow_B:
  [2, -2, 0, -4, 6, 0, -2, 2, -4, 0, 0, -4, 2, 0, 2, 0, 2, -2, 0, 0, 2, 0]

flow_B + Cm (corrected flow):
  [2, -2, -2, 0, 4, -2, -2, 2, -3, 0, 1, -3, 1, 1, 0, 0, 3, -2, 2, 0, 2, 0]

Verification:
  flow_corrected[14] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[3] = 0  (should be 0, Cm=4, d=4)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 42  (minimized by MIQP)
  ||Cm||_1  = 20
  ||flow_B||_2² = 120
  ||flow_corrected||_2² = 82

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    6.6          
    1     (0, 11)        -2       0          -2    5.1          
    2      (1, 2)         0      -2          -2    6.7    +13.4s
    3      (1, 3)        -4       4           0    6.4    -25.6s ← BLOCKED
    4      (1, 5)         6      -2           4    4.1     -8.2s
    5      (2, 3)         0      -2          -2    6.2    +12.4s
    6      (2, 8)        -2       0          -2    5.0          
    7     (2, 11)         2       0           2    5.7          
    8      (3, 4)        -4       1          -3    5.1     -5.1s
    9      (3, 6)         0       0           0    6.8          
   10      (3, 8)         0       1           1    5.8     +5.8s
   11      (4, 5)        -4       1          -3    4.6     -4.6s
   12      (5, 6)         2      -1           1    6.2     -6.2s
   13      (6, 7)         0       1           1    7.1     +7.1s
   14      (6, 9)         2      -2           0    5.2    -10.4s ← BLOCKED
   15     (6, 10)         0       0           0    4.9          
   16      (7, 8)         2       1           3    5.6     +5.6s
   17     (7, 10)        -2       0          -2    7.7          
   18      (8, 9)         0       2           2    7.9    +15.8s
   19     (8, 11)         0       0           0    6.7          
   20     (9, 10)         2       0           2    7.6          
   21    (10, 11)         0       0           0    7.4          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=4, out=4  OK
  Node 2: in=4, out=4  OK
  Node 3: in=3, out=3  OK
  Node 4: in=3, out=3  OK
  Node 5: in=4, out=4  OK
  Node 6: in=1, out=1  OK
  Node 7: in=3, out=3  OK
  Node 8: in=4, out=4  OK
  Node 9: in=2, out=2  OK
  Node 10: in=2, out=2  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 18

  Summary:
    Original path length:  36 edges
    Spliced path length:   34 edges
    Splices performed:     18
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)          -2        -2  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           4         4  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)          -2        -2  ✓
    7     (2, 11)           2         2  ✓
    8      (3, 4)          -3        -3  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           1         1  ✓
   11      (4, 5)          -3        -3  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           3         3  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           2         2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 4
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 3, 2, 2, 2, 3, 1, 2, 2, 2, 2] → J=239, T=199, cost=0 → queued

[Iter 1] cost=0, J=239, T=199, edges=35, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 3, 2, 2, 2, 3, 1, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (311 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (268 backtracks in 0.00s)
  [backtrack] Found solution with 12 backtracks in 0.00s
  [backtrack] Found solution with 169 backtracks in 0.00s
  [backtrack] Found solution with 161 backtracks in 0.00s
  [backtrack] Found solution with 149 backtracks in 0.00s
  [backtrack] Found solution with 193 backtracks in 0.00s
  [backtrack] Found solution with 65 backtracks in 0.00s
  [backtrack] Found solution with 57 backtracks in 0.00s
  [backtrack] Found solution with 210 backtracks in 0.00s
  [backtrack] Found solution with 119 backtracks in 0.00s
  [backtrack] Found solution with 23 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=100.8s)
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9] → expanding 7 children
    V_MIN=[4, 2, 3, 2, 2, 2, 3, 1, 2, 2, 2, 2] → J=227, T=197, cost=1 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 3, 1, 2, 2, 2, 2] → J=238, T=198, cost=1 → queued
    V_MIN=[3, 2, 3, 2, 3, 2, 3, 1, 2, 2, 2, 2] → J=226, T=200, cost=1 → queued
    V_MIN=[3, 2, 3, 2, 2, 3, 3, 1, 2, 2, 2, 2] → J=232, T=198, cost=1 → queued
    V_MIN=[3, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 2] → J=237, T=199, cost=1 → queued
    V_MIN=[3, 2, 3, 2, 2, 2, 3, 1, 3, 2, 2, 2] → J=233, T=199, cost=1 → queued
    V_MIN=[3, 2, 3, 2, 2, 2, 3, 1, 2, 3, 2, 2] → J=237, T=200, cost=1 → queued

[Iter 2] cost=1, J=238, T=198, edges=35, frontier=6, MILP_calls=8
  V_MIN=[3, 2, 3, 3, 2, 2, 3, 1, 2, 2, 2, 2]
  [backtrack] Found solution with 205 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.0s
  *** SOLUTION FOUND! J=238, T_tour=198.0s ***

============================================================
Search done: 2 iters, 8 MILP calls, 8 states visited

Original flow_B is latency-feasible ✓
  flow_B = [3, -3, 5, -1, -1, 3, 2, 0, 2, 0, 0, 2, 1, -1, -1, 3, 0, -1, 2, 0, 1, 3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [3, -3, 5, -1, -1, 3, 2, 0, 2, 0, 0, 2, 1, -1, -1, 3, 0, -1, 2, 0, 1, 3]
  Non-zero edges: [((0, 1), np.int64(3)), ((0, 11), np.int64(-3)), ((1, 2), np.int64(5)), ((1, 3), np.int64(-1)), ((1, 5), np.int64(-1)), ((2, 3), np.int64(3)), ((2, 8), np.int64(2)), ((3, 4), np.int64(2)), ((4, 5), np.int64(2)), ((5, 6), np.int64(1)), ((6, 7), np.int64(-1)), ((6, 9), np.int64(-1)), ((6, 10), np.int64(3)), ((7, 10), np.int64(-1)), ((8, 9), np.int64(2)), ((9, 10), np.int64(1)), ((10, 11), np.int64(3))]

Blocked edge 1: idx=11, edge=(4, 5), flow_B=2  →  need Cm[11]=-2
Blocked edge 2: idx=0, edge=(0, 1), flow_B=3  →  need Cm[0]=-3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=47   ||Cm||_1=25

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [2, -1, -1, 1, -2, -2, -3, 0, 0, 0, -1]

Cm = C_oriented @ beta*:
  [-3, 3, -1, -2, 0, 0, 1, -2, -2, 1, -1, -2, -2, -1, 0, 0, 0, -1, 1, -1, 1, 0]

Original flow_B:
  [3, -3, 5, -1, -1, 3, 2, 0, 2, 0, 0, 2, 1, -1, -1, 3, 0, -1, 2, 0, 1, 3]

flow_B + Cm (corrected flow):
  [0, 0, 4, -3, -1, 3, 3, -2, 0, 1, -1, 0, -1, -2, -1, 3, 0, -2, 3, -1, 2, 3]

Verification:
  flow_corrected[11] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[0] = 0  (should be 0, Cm=-3, d=-3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 47  (minimized by MIQP)
  ||Cm||_1  = 25
  ||flow_B||_2² = 93
  ||flow_corrected||_2² = 92

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         3      -3           0    7.5    -22.5s ← BLOCKED
    1     (0, 11)        -3       3           0    7.9    -23.7s
    2      (1, 2)         5      -1           4    4.7     -4.7s
    3      (1, 3)        -1      -2          -3    6.4    +12.8s
    4      (1, 5)        -1       0          -1    4.0          
    5      (2, 3)         3       0           3    5.5          
    6      (2, 8)         2       1           3    4.2     +4.2s
    7     (2, 11)         0      -2          -2    7.8    +15.6s
    8      (3, 4)         2      -2           0    5.7    -11.4s
    9      (3, 6)         0       1           1    7.8     +7.8s
   10      (3, 8)         0      -1          -1    7.1     +7.1s
   11      (4, 5)         2      -2           0    7.5    -15.0s ← BLOCKED
   12      (5, 6)         1      -2          -1    4.7          
   13      (6, 7)        -1      -1          -2    4.3     +4.3s
   14      (6, 9)        -1       0          -1    6.4          
   15     (6, 10)         3       0           3    4.7          
   16      (7, 8)         0       0           0    6.9          
   17     (7, 10)        -1      -1          -2    5.6     +5.6s
   18      (8, 9)         2       1           3    6.1     +6.1s
   19     (8, 11)         0      -1          -1    7.8     +7.8s
   20     (9, 10)         1       1           2    6.1     +6.1s
   21    (10, 11)         3       0           3    4.4          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=4, out=4  OK
  Node 2: in=6, out=6  OK
  Node 3: in=4, out=4  OK
  Node 5: in=1, out=1  OK
  Node 6: in=4, out=4  OK
  Node 7: in=2, out=2  OK
  Node 8: in=4, out=4  OK
  Node 9: in=3, out=3  OK
  Node 10: in=5, out=5  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 23

  Summary:
    Original path length:  35 edges
    Spliced path length:   36 edges
    Splices performed:     23
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           4         4  ✓
    3      (1, 3)          -3        -3  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)           3         3  ✓
    6      (2, 8)           3         3  ✓
    7     (2, 11)          -2        -2  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)          -2        -2  ✓
   14      (6, 9)          -1        -1  ✓
   15     (6, 10)           3         3  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           3         3  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           3         3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 5
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 2] → J=248, T=199, cost=0 → queued

[Iter 1] cost=0, J=248, T=199, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 2]
  [backtrack] Found solution with 328 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.1s
  *** SOLUTION FOUND! J=248, T_tour=199.1s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 1, -7, 4, 2, 0, -1, -2, -2, -1, -2, 2, 2, -2, 0, 1, 1, 1, -1, -1, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 1, -7, 4, 2, 0, -1, -2, -2, -1, -2, 2, 2, -2, 0, 1, 1, 1, -1, -1, 0]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(1)), ((1, 3), np.int64(-7)), ((1, 5), np.int64(4)), ((2, 3), np.int64(2)), ((2, 11), np.int64(-1)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(-2)), ((3, 8), np.int64(-1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(2)), ((6, 7), np.int64(2)), ((6, 9), np.int64(-2)), ((7, 8), np.int64(1)), ((7, 10), np.int64(1)), ((8, 9), np.int64(1)), ((8, 11), np.int64(-1)), ((9, 10), np.int64(-1))]

Blocked edge 1: idx=10, edge=(3, 8), flow_B=-1  →  need Cm[10]=1
Blocked edge 2: idx=1, edge=(0, 11), flow_B=2  →  need Cm[1]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=19   ||Cm||_1=15

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, 0, 2, 1, 1, 0, 2, 1, -1, 0, 0]

Cm = C_oriented @ beta*:
  [2, -2, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, -1, 0, 1, 1, 1, 1, 1]

Original flow_B:
  [-2, 2, 1, -7, 4, 2, 0, -1, -2, -2, -1, -2, 2, 2, -2, 0, 1, 1, 1, -1, -1, 0]

flow_B + Cm (corrected flow):
  [0, 0, 2, -6, 4, 2, 1, -1, -2, -2, 0, -2, 2, 3, -2, -1, 1, 2, 2, 0, 0, 1]

Verification:
  flow_corrected[10] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[1] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 19  (minimized by MIQP)
  ||Cm||_1  = 15
  ||flow_B||_2² = 109
  ||flow_corrected||_2² = 102

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       2           0    5.8    -11.6s
    1     (0, 11)         2      -2           0    4.6     -9.2s ← BLOCKED
    2      (1, 2)         1       1           2    7.5     +7.5s
    3      (1, 3)        -7       1          -6    5.1     -5.1s
    4      (1, 5)         4       0           4    5.7          
    5      (2, 3)         2       0           2    5.2          
    6      (2, 8)         0       1           1    6.5     +6.5s
    7     (2, 11)        -1       0          -1    6.3          
    8      (3, 4)        -2       0          -2    6.4          
    9      (3, 6)        -2       0          -2    5.1          
   10      (3, 8)        -1       1           0    5.1     -5.1s ← BLOCKED
   11      (4, 5)        -2       0          -2    5.0          
   12      (5, 6)         2       0           2    5.3          
   13      (6, 7)         2       1           3    4.6     +4.6s
   14      (6, 9)        -2       0          -2    4.7          
   15     (6, 10)         0      -1          -1    7.9     +7.9s
   16      (7, 8)         1       0           1    7.8          
   17     (7, 10)         1       1           2    4.8     +4.8s
   18      (8, 9)         1       1           2    4.1     +4.1s
   19     (8, 11)        -1       1           0    4.8     -4.8s
   20     (9, 10)        -1       1           0    6.8     -6.8s
   21    (10, 11)         0       1           1    7.1     +7.1s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=6, out=6  OK
  Node 2: in=3, out=3  OK
  Node 3: in=6, out=6  OK
  Node 4: in=2, out=2  OK
  Node 5: in=4, out=4  OK
  Node 6: in=5, out=5  OK
  Node 7: in=3, out=3  OK
  Node 8: in=2, out=2  OK
  Node 9: in=2, out=2  OK
  Node 10: in=2, out=2  OK
  Node 11: in=1, out=1  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 15

  Summary:
    Original path length:  37 edges
    Spliced path length:   36 edges
    Splices performed:     15
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           2         2  ✓
    3      (1, 3)          -6        -6  ✓
    4      (1, 5)           4         4  ✓
    5      (2, 3)           2         2  ✓
    6      (2, 8)           1         1  ✓
    7     (2, 11)          -1        -1  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)           2         2  ✓
   13      (6, 7)           3         3  ✓
   14      (6, 9)          -2        -2  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)           2         2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 6
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2] → J=195, T=199, cost=0 → queued

[Iter 1] cost=0, J=195, T=199, edges=33, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (147 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (145 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (136 backtracks in 0.00s)
  [backtrack] Found solution with 101 backtracks in 0.00s
  [backtrack] Found solution with 105 backtracks in 0.00s
  [backtrack] Found solution with 109 backtracks in 0.00s
  [backtrack] Found solution with 113 backtracks in 0.00s
  [backtrack] Found solution with 77 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (115 backtracks in 0.00s)
  [backtrack] Found solution with 10 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (123 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (232 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=95.8s)
  Boundary nodes: [0, 4, 5, 6, 7, 8] → expanding 6 children
    V_MIN=[4, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2] → J=193, T=200, cost=1 → queued
    V_MIN=[3, 2, 3, 1, 3, 2, 2, 2, 2, 2, 2, 2] → J=186, T=200, cost=1 → queued
    V_MIN=[3, 2, 3, 1, 2, 3, 2, 2, 2, 2, 2, 2] → J=191, T=198, cost=1 → queued
    V_MIN=[3, 2, 3, 1, 2, 2, 3, 2, 2, 2, 2, 2] → J=193, T=198, cost=1 → queued
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 3, 2, 2, 2, 2] → J=192, T=200, cost=1 → queued
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 2, 3, 2, 2, 2] → J=189, T=198, cost=1 → queued

[Iter 2] cost=1, J=193, T=198, edges=33, frontier=5, MILP_calls=7
  V_MIN=[3, 2, 3, 1, 2, 2, 3, 2, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (117 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (103 backtracks in 0.00s)
  [backtrack] Found solution with 61 backtracks in 0.00s
  [backtrack] Found solution with 65 backtracks in 0.00s
  [backtrack] Found solution with 69 backtracks in 0.00s
  [backtrack] Found solution with 5 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (123 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (142 backtracks in 0.00s)
  [backtrack] Found solution with 6 backtracks in 0.00s
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (123 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=94.7s)
  Boundary nodes: [0, 4, 5, 6, 7, 8] → expanding 6 children
    V_MIN=[4, 2, 3, 1, 2, 2, 3, 2, 2, 2, 2, 2] → J=185, T=198, cost=2 → queued
    V_MIN=[3, 2, 3, 1, 3, 2, 3, 2, 2, 2, 2, 2] → J=186, T=200, cost=2 → queued
    V_MIN=[3, 2, 3, 1, 2, 3, 3, 2, 2, 2, 2, 2] → J=191, T=198, cost=2 → queued
    V_MIN=[3, 2, 3, 1, 2, 2, 4, 2, 2, 2, 2, 2] → J=192, T=199, cost=2 → queued
    V_MIN=[3, 2, 3, 1, 2, 2, 3, 3, 2, 2, 2, 2] → J=192, T=200, cost=2 → queued
    V_MIN=[3, 2, 3, 1, 2, 2, 3, 2, 3, 2, 2, 2] → J=188, T=198, cost=2 → queued

[Iter 3] cost=1, J=193, T=200, edges=33, frontier=10, MILP_calls=13
  V_MIN=[4, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
    ✓ Latency-feasible! source=3, T_tour=200.0s
  DFS: latency violated (2 nodes, worst_gap=128.8s)
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9] → expanding 7 children
    V_MIN=[5, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[4, 2, 3, 1, 3, 2, 2, 2, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[4, 2, 3, 1, 2, 3, 2, 2, 2, 2, 2, 2] → J=186, T=200, cost=2 → queued
    V_MIN=[4, 2, 3, 1, 2, 2, 2, 3, 2, 2, 2, 2] → J=189, T=200, cost=2 → queued
    V_MIN=[4, 2, 3, 1, 2, 2, 2, 2, 3, 2, 2, 2] → J=183, T=199, cost=2 → queued
    V_MIN=[4, 2, 3, 1, 2, 2, 2, 2, 2, 3, 2, 2] → MILP infeasible, pruned

[Iter 4] cost=1, J=192, T=200, edges=34, frontier=12, MILP_calls=19
  V_MIN=[3, 2, 3, 1, 2, 2, 2, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (102 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (52 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (135 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (203 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (216 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (114 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (258 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (54 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (81 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 7, 8] → expanding 6 children
    V_MIN=[3, 2, 4, 1, 2, 2, 2, 3, 2, 2, 2, 2] → J=191, T=198, cost=2 → queued
    V_MIN=[3, 2, 3, 1, 3, 2, 2, 3, 2, 2, 2, 2] → J=179, T=200, cost=2 → queued
    V_MIN=[3, 2, 3, 1, 2, 3, 2, 3, 2, 2, 2, 2] → J=187, T=198, cost=2 → queued
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 4, 2, 2, 2, 2] → J=191, T=200, cost=2 → queued
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 3, 3, 2, 2, 2] → J=189, T=198, cost=2 → queued

[Iter 5] cost=1, J=191, T=198, edges=33, frontier=16, MILP_calls=24
  V_MIN=[3, 2, 3, 1, 2, 3, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=197.5s
  *** SOLUTION FOUND! J=191, T_tour=197.5s ***

============================================================
Search done: 5 iters, 24 MILP calls, 24 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, -2, 0, -1, -2, 2, -2, -2, 0, 0, -2, -3, 0, -3, 0, -2, 2, 0, 0, -3, -1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, -2, 0, -1, -2, 2, -2, -2, 0, 0, -2, -3, 0, -3, 0, -2, 2, 0, 0, -3, -1]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 2), np.int64(-2)), ((1, 5), np.int64(-1)), ((2, 3), np.int64(-2)), ((2, 8), np.int64(2)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(-2)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-3)), ((6, 9), np.int64(-3)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(2)), ((9, 10), np.int64(-3)), ((10, 11), np.int64(-1))]

Blocked edge 1: idx=7, edge=(2, 11), flow_B=-2  →  need Cm[7]=2
Blocked edge 2: idx=14, edge=(6, 9), flow_B=-3  →  need Cm[14]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=31   ||Cm||_1=21

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, 0, -1, 1, 0, 0, 1, -1, 1, -1, 1]

Cm = C_oriented @ beta*:
  [1, -1, 0, 0, 1, -1, -1, 2, -1, 1, -1, -1, 0, -1, 3, -1, 0, -1, -2, 0, 1, -1]

Original flow_B:
  [-3, 3, -2, 0, -1, -2, 2, -2, -2, 0, 0, -2, -3, 0, -3, 0, -2, 2, 0, 0, -3, -1]

flow_B + Cm (corrected flow):
  [-2, 2, -2, 0, 0, -3, 1, 0, -3, 1, -1, -3, -3, -1, 0, -1, -2, 1, -2, 0, -2, -2]

Verification:
  flow_corrected[7] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[14] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 31  (minimized by MIQP)
  ||Cm||_1  = 21
  ||flow_B||_2² = 79
  ||flow_corrected||_2² = 70

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       1          -2    6.1     -6.1s
    1     (0, 11)         3      -1           2    6.3     -6.3s
    2      (1, 2)        -2       0          -2    6.6          
    3      (1, 3)         0       0           0    8.0          
    4      (1, 5)        -1       1           0    7.3     -7.3s
    5      (2, 3)        -2      -1          -3    5.7     +5.7s
    6      (2, 8)         2      -1           1    7.5     -7.5s
    7     (2, 11)        -2       2           0    7.3    -14.6s ← BLOCKED
    8      (3, 4)        -2      -1          -3    4.2     +4.2s
    9      (3, 6)         0       1           1    6.9     +6.9s
   10      (3, 8)         0      -1          -1    7.2     +7.2s
   11      (4, 5)        -2      -1          -3    6.9     +6.9s
   12      (5, 6)        -3       0          -3    6.8          
   13      (6, 7)         0      -1          -1    6.2     +6.2s
   14      (6, 9)        -3       3           0    4.5    -13.5s ← BLOCKED
   15     (6, 10)         0      -1          -1    7.8     +7.8s
   16      (7, 8)        -2       0          -2    5.6          
   17     (7, 10)         2      -1           1    4.9     -4.9s
   18      (8, 9)         0      -2          -2    6.9    +13.8s
   19     (8, 11)         0       0           0    8.0          
   20     (9, 10)        -3       1          -2    5.0     -5.0s
   21    (10, 11)        -1      -1          -2    6.7     +6.7s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=2, out=2  OK
  Node 2: in=3, out=3  OK
  Node 3: in=4, out=4  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=3, out=3  OK
  Node 7: in=2, out=2  OK
  Node 8: in=3, out=3  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 32 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 26

  Summary:
    Original path length:  33 edges
    Spliced path length:   32 edges
    Splices performed:     26
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)          -2        -2  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)          -3        -3  ✓
    6      (2, 8)           1         1  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -3        -3  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)          -3        -3  ✓
   12      (5, 6)          -3        -3  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)          -2        -2  ✓
   17     (7, 10)           1         1  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)          -2        -2  ✓
   21    (10, 11)          -2        -2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 7
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 1, 2, 2, 2, 2] → J=237, T=199, cost=0 → queued

[Iter 1] cost=0, J=237, T=199, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 3, 2, 2, 1, 2, 2, 2, 2]
  [backtrack] Found solution with 12 backtracks in 0.00s
  [backtrack] Found solution with 84 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=198.9s
  *** SOLUTION FOUND! J=237, T_tour=198.9s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 5, 0, -3, 0, 0, 5, 3, -1, -2, 3, 0, 1, 0, -2, 0, 1, -2, 0, -2, -3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 5, 0, -3, 0, 0, 5, 3, -1, -2, 3, 0, 1, 0, -2, 0, 1, -2, 0, -2, -3]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(5)), ((1, 5), np.int64(-3)), ((2, 11), np.int64(5)), ((3, 4), np.int64(3)), ((3, 6), np.int64(-1)), ((3, 8), np.int64(-2)), ((4, 5), np.int64(3)), ((6, 7), np.int64(1)), ((6, 10), np.int64(-2)), ((7, 10), np.int64(1)), ((8, 9), np.int64(-2)), ((9, 10), np.int64(-2)), ((10, 11), np.int64(-3))]

Blocked edge 1: idx=4, edge=(1, 5), flow_B=-3  →  need Cm[4]=3
Blocked edge 2: idx=15, edge=(6, 10), flow_B=-2  →  need Cm[15]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=31   ||Cm||_1=19

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-2, -1, 0, -1, 1, 2, 0, 1, -1, -3, 2]

Cm = C_oriented @ beta*:
  [0, 0, -2, -1, 3, -1, -1, 0, -1, 0, -1, -1, 2, 0, 0, 2, 0, 0, -1, -1, -1, 1]

Original flow_B:
  [2, -2, 5, 0, -3, 0, 0, 5, 3, -1, -2, 3, 0, 1, 0, -2, 0, 1, -2, 0, -2, -3]

flow_B + Cm (corrected flow):
  [2, -2, 3, -1, 0, -1, -1, 5, 2, -1, -3, 2, 2, 1, 0, 0, 0, 1, -3, -1, -3, -2]

Verification:
  flow_corrected[4] = 0  (should be 0, Cm=3, d=3)
  flow_corrected[15] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 31  (minimized by MIQP)
  ||Cm||_1  = 19
  ||flow_B||_2² = 113
  ||flow_corrected||_2² = 92

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    5.5          
    1     (0, 11)        -2       0          -2    4.3          
    2      (1, 2)         5      -2           3    5.2    -10.4s
    3      (1, 3)         0      -1          -1    7.6     +7.6s
    4      (1, 5)        -3       3           0    4.9    -14.7s ← BLOCKED
    5      (2, 3)         0      -1          -1    5.8     +5.8s
    6      (2, 8)         0      -1          -1    7.7     +7.7s
    7     (2, 11)         5       0           5    4.1          
    8      (3, 4)         3      -1           2    6.4     -6.4s
    9      (3, 6)        -1       0          -1    7.8          
   10      (3, 8)        -2      -1          -3    4.9     +4.9s
   11      (4, 5)         3      -1           2    6.2     -6.2s
   12      (5, 6)         0       2           2    7.6    +15.2s
   13      (6, 7)         1       0           1    4.5          
   14      (6, 9)         0       0           0    6.1          
   15     (6, 10)        -2       2           0    7.0    -14.0s ← BLOCKED
   16      (7, 8)         0       0           0    6.7          
   17     (7, 10)         1       0           1    5.9          
   18      (8, 9)        -2      -1          -3    4.8     +4.8s
   19     (8, 11)         0      -1          -1    6.0     +6.0s
   20     (9, 10)        -2      -1          -3    5.5     +5.5s
   21    (10, 11)        -3       1          -2    5.9     -5.9s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=3, out=3  OK
  Node 2: in=5, out=5  OK
  Node 3: in=4, out=4  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=2, out=2  OK
  Node 7: in=1, out=1  OK
  Node 8: in=4, out=4  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=5, out=5  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 17

  Summary:
    Original path length:  37 edges
    Spliced path length:   36 edges
    Splices performed:     17
    Path is continuous:    True
    Returns to source 1: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           3         3  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           5         5  ✓
    8      (3, 4)           2         2  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)          -3        -3  ✓
   11      (4, 5)           2         2  ✓
   12      (5, 6)           2         2  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)           1         1  ✓
   18      (8, 9)          -3        -3  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)          -3        -3  ✓
   21    (10, 11)          -2        -2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 8
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 3, 3, 2, 2, 1, 2, 2, 2, 2, 2, 2] → J=230, T=200, cost=0 → queued

[Iter 1] cost=0, J=230, T=200, edges=36, frontier=0, MILP_calls=1
  V_MIN=[3, 3, 3, 2, 2, 1, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 677 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=200.0s
  *** SOLUTION FOUND! J=230, T_tour=200.0s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, -2, -3, 2, 0, 2, -4, -2, 0, -1, -2, 0, 2, -1, -1, 2, 0, 3, 0, 2, 1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, -2, -3, 2, 0, 2, -4, -2, 0, -1, -2, 0, 2, -1, -1, 2, 0, 3, 0, 2, 1]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 2), np.int64(-2)), ((1, 3), np.int64(-3)), ((1, 5), np.int64(2)), ((2, 8), np.int64(2)), ((2, 11), np.int64(-4)), ((3, 4), np.int64(-2)), ((3, 8), np.int64(-1)), ((4, 5), np.int64(-2)), ((6, 7), np.int64(2)), ((6, 9), np.int64(-1)), ((6, 10), np.int64(-1)), ((7, 8), np.int64(2)), ((8, 9), np.int64(3)), ((9, 10), np.int64(2)), ((10, 11), np.int64(1))]

Blocked edge 1: idx=8, edge=(3, 4), flow_B=-2  →  need Cm[8]=2
Blocked edge 2: idx=16, edge=(7, 8), flow_B=2  →  need Cm[16]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=26   ||Cm||_1=16

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, 0, 0, 0, 0, 2, 0, -1, -1, 0, 0]

Cm = C_oriented @ beta*:
  [0, 0, 0, 0, 0, 0, 0, 0, 2, -2, 0, 2, 2, -1, 1, 0, -2, 1, -1, -1, 0, 1]

Original flow_B:
  [-3, 3, -2, -3, 2, 0, 2, -4, -2, 0, -1, -2, 0, 2, -1, -1, 2, 0, 3, 0, 2, 1]

flow_B + Cm (corrected flow):
  [-3, 3, -2, -3, 2, 0, 2, -4, 0, -2, -1, 0, 2, 1, 0, -1, 0, 1, 2, -1, 2, 2]

Verification:
  flow_corrected[8] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[16] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 26  (minimized by MIQP)
  ||Cm||_1  = 16
  ||flow_B||_2² = 88
  ||flow_corrected||_2² = 80

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       0          -3    7.0          
    1     (0, 11)         3       0           3    6.8          
    2      (1, 2)        -2       0          -2    6.5          
    3      (1, 3)        -3       0          -3    5.7          
    4      (1, 5)         2       0           2    5.2          
    5      (2, 3)         0       0           0    7.9          
    6      (2, 8)         2       0           2    5.3          
    7     (2, 11)        -4       0          -4    4.9          
    8      (3, 4)        -2       2           0    4.3     -8.6s ← BLOCKED
    9      (3, 6)         0      -2          -2    7.9    +15.8s
   10      (3, 8)        -1       0          -1    4.5          
   11      (4, 5)        -2       2           0    5.3    -10.6s
   12      (5, 6)         0       2           2    4.3     +8.6s
   13      (6, 7)         2      -1           1    4.9     -4.9s
   14      (6, 9)        -1       1           0    5.6     -5.6s
   15     (6, 10)        -1       0          -1    7.6          
   16      (7, 8)         2      -2           0    5.4    -10.8s ← BLOCKED
   17     (7, 10)         0       1           1    7.9     +7.9s
   18      (8, 9)         3      -1           2    4.1     -4.1s
   19     (8, 11)         0      -1          -1    5.4     +5.4s
   20     (9, 10)         2       0           2    5.5          
   21    (10, 11)         1       1           2    7.1     +7.1s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=5, out=5  OK
  Node 2: in=4, out=4  OK
  Node 3: in=3, out=3  OK
  Node 5: in=2, out=2  OK
  Node 6: in=3, out=3  OK
  Node 7: in=1, out=1  OK
  Node 8: in=3, out=3  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=5, out=5  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 25

  Summary:
    Original path length:  36 edges
    Spliced path length:   34 edges
    Splices performed:     25
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -3        -3  ✓
    1     (0, 11)           3         3  ✓
    2      (1, 2)          -2        -2  ✓
    3      (1, 3)          -3        -3  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           2         2  ✓
    7     (2, 11)          -4        -4  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)           2         2  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)           1         1  ✓
   18      (8, 9)           2         2  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           2         2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 9
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3] → J=136, T=199, cost=0 → queued

[Iter 1] cost=0, J=136, T=199, edges=31, frontier=0, MILP_calls=1
  V_MIN=[1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3]
  [backtrack] Found solution with 6 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=198.6s
  DFS: latency violated (1 nodes, worst_gap=157.4s)
  Boundary nodes: [0, 1, 3, 4, 5, 7, 8, 9] → expanding 8 children
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3] → J=134, T=199, cost=1 → queued
    V_MIN=[1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3] → J=135, T=197, cost=1 → queued
    V_MIN=[1, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3] → J=134, T=200, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3] → J=128, T=200, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3] → J=133, T=199, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3] → J=130, T=199, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 3] → J=135, T=200, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3] → J=131, T=199, cost=1 → queued

[Iter 2] cost=1, J=135, T=197, edges=31, frontier=7, MILP_calls=9
  V_MIN=[1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3]
  [backtrack] Found solution with 4 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=197.2s
  *** SOLUTION FOUND! J=135, T_tour=197.2s ***

============================================================
Search done: 2 iters, 9 MILP calls, 9 states visited

Original flow_B is latency-feasible ✓
  flow_B = [1, -1, 3, -2, 0, 0, -1, 4, -2, 0, 0, -2, -2, 2, -2, -2, 2, 0, 1, 0, -1, -3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [1, -1, 3, -2, 0, 0, -1, 4, -2, 0, 0, -2, -2, 2, -2, -2, 2, 0, 1, 0, -1, -3]
  Non-zero edges: [((0, 1), np.int64(1)), ((0, 11), np.int64(-1)), ((1, 2), np.int64(3)), ((1, 3), np.int64(-2)), ((2, 8), np.int64(-1)), ((2, 11), np.int64(4)), ((3, 4), np.int64(-2)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(2)), ((6, 9), np.int64(-2)), ((6, 10), np.int64(-2)), ((7, 8), np.int64(2)), ((8, 9), np.int64(1)), ((9, 10), np.int64(-1)), ((10, 11), np.int64(-3))]

Blocked edge 1: idx=13, edge=(6, 7), flow_B=2  →  need Cm[13]=-2
Blocked edge 2: idx=11, edge=(4, 5), flow_B=-2  →  need Cm[11]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=27   ||Cm||_1=19

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -1, 0, 0, 0, 1, 1, -1, 0, 1, -1]

Cm = C_oriented @ beta*:
  [1, -1, 1, 1, -1, 0, 0, 1, 2, -2, 1, 2, 1, -2, 0, 1, -1, -1, 0, 0, 0, 0]

Original flow_B:
  [1, -1, 3, -2, 0, 0, -1, 4, -2, 0, 0, -2, -2, 2, -2, -2, 2, 0, 1, 0, -1, -3]

flow_B + Cm (corrected flow):
  [2, -2, 4, -1, -1, 0, -1, 5, 0, -2, 1, 0, -1, 0, -2, -1, 1, -1, 1, 0, -1, -3]

Verification:
  flow_corrected[13] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[11] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 27  (minimized by MIQP)
  ||Cm||_1  = 19
  ||flow_B||_2² = 71
  ||flow_corrected||_2² = 76

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         1       1           2    7.8     +7.8s
    1     (0, 11)        -1      -1          -2    4.2     +4.2s
    2      (1, 2)         3       1           4    6.8     +6.8s
    3      (1, 3)        -2       1          -1    6.3     -6.3s
    4      (1, 5)         0      -1          -1    7.6     +7.6s
    5      (2, 3)         0       0           0    6.7          
    6      (2, 8)        -1       0          -1    6.2          
    7     (2, 11)         4       1           5    6.8     +6.8s
    8      (3, 4)        -2       2           0    5.5    -11.0s
    9      (3, 6)         0      -2          -2    6.8    +13.6s
   10      (3, 8)         0       1           1    7.3     +7.3s
   11      (4, 5)        -2       2           0    5.9    -11.8s ← BLOCKED
   12      (5, 6)        -2       1          -1    7.8     -7.8s
   13      (6, 7)         2      -2           0    7.2    -14.4s ← BLOCKED
   14      (6, 9)        -2       0          -2    7.9          
   15     (6, 10)        -2       1          -1    4.7     -4.7s
   16      (7, 8)         2      -1           1    6.1     -6.1s
   17     (7, 10)         0      -1          -1    7.8     +7.8s
   18      (8, 9)         1       0           1    6.6          
   19     (8, 11)         0       0           0    7.4          
   20     (9, 10)        -1       0          -1    7.9          
   21    (10, 11)        -3       0          -3    4.7          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=4, out=4  OK
  Node 2: in=5, out=5  OK
  Node 3: in=2, out=2  OK
  Node 5: in=1, out=1  OK
  Node 6: in=3, out=3  OK
  Node 7: in=1, out=1  OK
  Node 8: in=2, out=2  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=5, out=5  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 30 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 15

  Summary:
    Original path length:  31 edges
    Spliced path length:   30 edges
    Splices performed:     15
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           4         4  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           5         5  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)           1         1  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)          -2        -2  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)           1         1  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)          -1        -1  ✓
   21    (10, 11)          -3        -3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 10
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3] → J=199, T=200, cost=0 → queued

[Iter 1] cost=0, J=199, T=200, edges=33, frontier=0, MILP_calls=1
  V_MIN=[2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3]
  [backtrack] Found solution with 121 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=200.0s
  *** SOLUTION FOUND! J=199, T_tour=200.0s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 0, 0, -2, 4, 0, -4, 2, 1, 1, 2, 0, 2, 0, -1, 0, 2, 2, -1, 2, 3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 0, 0, -2, 4, 0, -4, 2, 1, 1, 2, 0, 2, 0, -1, 0, 2, 2, -1, 2, 3]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 5), np.int64(-2)), ((2, 3), np.int64(4)), ((2, 11), np.int64(-4)), ((3, 4), np.int64(2)), ((3, 6), np.int64(1)), ((3, 8), np.int64(1)), ((4, 5), np.int64(2)), ((6, 7), np.int64(2)), ((6, 10), np.int64(-1)), ((7, 10), np.int64(2)), ((8, 9), np.int64(2)), ((8, 11), np.int64(-1)), ((9, 10), np.int64(2)), ((10, 11), np.int64(3))]

Blocked edge 1: idx=1, edge=(0, 11), flow_B=2  →  need Cm[1]=-2
Blocked edge 2: idx=18, edge=(8, 9), flow_B=2  →  need Cm[18]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=27   ||Cm||_1=19

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, 1, 1, 0, 0, 0, 2, -1, 0, 0, 1]

Cm = C_oriented @ beta*:
  [2, -2, 1, 1, 0, -1, 1, 1, 0, 1, -1, 0, 0, 0, 2, -1, -1, 1, -2, 1, 0, 0]

Original flow_B:
  [-2, 2, 0, 0, -2, 4, 0, -4, 2, 1, 1, 2, 0, 2, 0, -1, 0, 2, 2, -1, 2, 3]

flow_B + Cm (corrected flow):
  [0, 0, 1, 1, -2, 3, 1, -3, 2, 2, 0, 2, 0, 2, 2, -2, -1, 3, 0, 0, 2, 3]

Verification:
  flow_corrected[1] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[18] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 27  (minimized by MIQP)
  ||Cm||_1  = 19
  ||flow_B||_2² = 81
  ||flow_corrected||_2² = 72

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       2           0    4.0     -8.0s
    1     (0, 11)         2      -2           0    6.0    -12.0s ← BLOCKED
    2      (1, 2)         0       1           1    7.3     +7.3s
    3      (1, 3)         0       1           1    6.5     +6.5s
    4      (1, 5)        -2       0          -2    6.9          
    5      (2, 3)         4      -1           3    5.2     -5.2s
    6      (2, 8)         0       1           1    7.7     +7.7s
    7     (2, 11)        -4       1          -3    6.9     -6.9s
    8      (3, 4)         2       0           2    6.2          
    9      (3, 6)         1       1           2    4.6     +4.6s
   10      (3, 8)         1      -1           0    5.5     -5.5s
   11      (4, 5)         2       0           2    6.7          
   12      (5, 6)         0       0           0    5.8          
   13      (6, 7)         2       0           2    5.7          
   14      (6, 9)         0       2           2    6.5    +13.0s
   15     (6, 10)        -1      -1          -2    6.1     +6.1s
   16      (7, 8)         0      -1          -1    6.6     +6.6s
   17     (7, 10)         2       1           3    6.4     +6.4s
   18      (8, 9)         2      -2           0    7.2    -14.4s ← BLOCKED
   19     (8, 11)        -1       1           0    6.1     -6.1s
   20     (9, 10)         2       0           2    7.6          
   21    (10, 11)         3       0           3    5.3          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=2, out=2  OK
  Node 2: in=4, out=4  OK
  Node 3: in=4, out=4  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=4, out=4  OK
  Node 7: in=3, out=3  OK
  Node 8: in=1, out=1  OK
  Node 9: in=2, out=2  OK
  Node 10: in=5, out=5  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 32 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 17

  Summary:
    Original path length:  33 edges
    Spliced path length:   32 edges
    Splices performed:     17
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           1         1  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)          -2        -2  ✓
    5      (2, 3)           3         3  ✓
    6      (2, 8)           1         1  ✓
    7     (2, 11)          -3        -3  ✓
    8      (3, 4)           2         2  ✓
    9      (3, 6)           2         2  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           2         2  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)           2         2  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)          -2        -2  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)           3         3  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           3         3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 11
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 2, 2] → J=221, T=200, cost=0 → queued

[Iter 1] cost=0, J=221, T=200, edges=36, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 2, 2]
  [backtrack] Found solution with 86 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.8s
  *** SOLUTION FOUND! J=221, T_tour=199.8s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 1, 0, 1, 2, -3, 2, -2, 0, 4, -2, -1, -1, 0, 0, -4, 3, -3, 0, -3, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 1, 0, 1, 2, -3, 2, -2, 0, 4, -2, -1, -1, 0, 0, -4, 3, -3, 0, -3, 0]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(1)), ((1, 5), np.int64(1)), ((2, 3), np.int64(2)), ((2, 8), np.int64(-3)), ((2, 11), np.int64(2)), ((3, 4), np.int64(-2)), ((3, 8), np.int64(4)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-1)), ((6, 7), np.int64(-1)), ((7, 8), np.int64(-4)), ((7, 10), np.int64(3)), ((8, 9), np.int64(-3)), ((9, 10), np.int64(-3))]

Blocked edge 1: idx=2, edge=(1, 2), flow_B=1  →  need Cm[2]=-1
Blocked edge 2: idx=10, edge=(3, 8), flow_B=4  →  need Cm[10]=-4
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=40   ||Cm||_1=20

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, 0, 0, -1, -2, 1, 0, 1, -1, -1, 2]

Cm = C_oriented @ beta*:
  [0, 0, -1, 0, 1, -3, 2, 0, 0, 1, -4, 0, 1, 1, 0, 1, 0, 1, -1, -1, -1, 1]

Original flow_B:
  [2, -2, 1, 0, 1, 2, -3, 2, -2, 0, 4, -2, -1, -1, 0, 0, -4, 3, -3, 0, -3, 0]

flow_B + Cm (corrected flow):
  [2, -2, 0, 0, 2, -1, -1, 2, -2, 1, 0, -2, 0, 0, 0, 1, -4, 4, -4, -1, -4, 1]

Verification:
  flow_corrected[2] = 0  (should be 0, Cm=-1, d=-1)
  flow_corrected[10] = 0  (should be 0, Cm=-4, d=-4)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 40  (minimized by MIQP)
  ||Cm||_1  = 20
  ||flow_B||_2² = 96
  ||flow_corrected||_2² = 94

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    7.6          
    1     (0, 11)        -2       0          -2    7.4          
    2      (1, 2)         1      -1           0    4.7     -4.7s ← BLOCKED
    3      (1, 3)         0       0           0    6.5          
    4      (1, 5)         1       1           2    4.1     +4.1s
    5      (2, 3)         2      -3          -1    4.5     -4.5s
    6      (2, 8)        -3       2          -1    5.3    -10.6s
    7     (2, 11)         2       0           2    4.6          
    8      (3, 4)        -2       0          -2    7.0          
    9      (3, 6)         0       1           1    7.3     +7.3s
   10      (3, 8)         4      -4           0    5.4    -21.6s ← BLOCKED
   11      (4, 5)        -2       0          -2    5.3          
   12      (5, 6)        -1       1           0    4.4     -4.4s
   13      (6, 7)        -1       1           0    4.3     -4.3s
   14      (6, 9)         0       0           0    6.9          
   15     (6, 10)         0       1           1    6.4     +6.4s
   16      (7, 8)        -4       0          -4    4.2          
   17     (7, 10)         3       1           4    5.9     +5.9s
   18      (8, 9)        -3      -1          -4    5.6     +5.6s
   19     (8, 11)         0      -1          -1    7.4     +7.4s
   20     (9, 10)        -3      -1          -4    6.9     +6.9s
   21    (10, 11)         0       1           1    6.4     +6.4s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=2, out=2  OK
  Node 2: in=2, out=2  OK
  Node 3: in=2, out=2  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=1, out=1  OK
  Node 7: in=4, out=4  OK
  Node 8: in=5, out=5  OK
  Node 9: in=4, out=4  OK
  Node 10: in=5, out=5  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 28

  Summary:
    Original path length:  36 edges
    Spliced path length:   34 edges
    Splices performed:     28
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           2         2  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)          -4        -4  ✓
   17     (7, 10)           4         4  ✓
   18      (8, 9)          -4        -4  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)          -4        -4  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 12
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 1, 3, 3, 2, 3, 2, 2, 2] → J=232, T=199, cost=0 → queued

[Iter 1] cost=0, J=232, T=199, edges=36, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 1, 3, 3, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 2 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.1s
  *** SOLUTION FOUND! J=232, T_tour=199.1s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 2, 0, -4, 0, 0, 2, -1, 3, -2, -1, -5, 0, -2, 0, -2, 2, 0, -4, -2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 2, 0, -4, 0, 0, 2, -1, 3, -2, -1, -5, 0, -2, 0, -2, 2, 0, -4, -2, 0]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(2)), ((1, 5), np.int64(-4)), ((2, 11), np.int64(2)), ((3, 4), np.int64(-1)), ((3, 6), np.int64(3)), ((3, 8), np.int64(-2)), ((4, 5), np.int64(-1)), ((5, 6), np.int64(-5)), ((6, 9), np.int64(-2)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(2)), ((8, 11), np.int64(-4)), ((9, 10), np.int64(-2))]

Blocked edge 1: idx=7, edge=(2, 11), flow_B=2  →  need Cm[7]=-2
Blocked edge 2: idx=9, edge=(3, 6), flow_B=3  →  need Cm[9]=-3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=32   ||Cm||_1=20

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, 1, 1, 0, 0, 1, -1, -1, 1, -1, -2]

Cm = C_oriented @ beta*:
  [-1, 1, -1, -1, 1, 0, 1, -2, 0, -3, 2, 0, 1, 0, -1, -1, 0, 0, 1, 2, 0, -1]

Original flow_B:
  [-2, 2, 2, 0, -4, 0, 0, 2, -1, 3, -2, -1, -5, 0, -2, 0, -2, 2, 0, -4, -2, 0]

flow_B + Cm (corrected flow):
  [-3, 3, 1, -1, -3, 0, 1, 0, -1, 0, 0, -1, -4, 0, -3, -1, -2, 2, 1, -2, -2, -1]

Verification:
  flow_corrected[7] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[9] = 0  (should be 0, Cm=-3, d=-3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 32  (minimized by MIQP)
  ||Cm||_1  = 20
  ||flow_B||_2² = 104
  ||flow_corrected||_2² = 76

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2      -1          -3    7.8     +7.8s
    1     (0, 11)         2       1           3    7.4     +7.4s
    2      (1, 2)         2      -1           1    4.0     -4.0s
    3      (1, 3)         0      -1          -1    6.1     +6.1s
    4      (1, 5)        -4       1          -3    6.2     -6.2s
    5      (2, 3)         0       0           0    5.9          
    6      (2, 8)         0       1           1    7.1     +7.1s
    7     (2, 11)         2      -2           0    4.6     -9.2s ← BLOCKED
    8      (3, 4)        -1       0          -1    7.1          
    9      (3, 6)         3      -3           0    4.1    -12.3s ← BLOCKED
   10      (3, 8)        -2       2           0    4.5     -9.0s
   11      (4, 5)        -1       0          -1    4.5          
   12      (5, 6)        -5       1          -4    5.2     -5.2s
   13      (6, 7)         0       0           0    6.7          
   14      (6, 9)        -2      -1          -3    5.9     +5.9s
   15     (6, 10)         0      -1          -1    7.3     +7.3s
   16      (7, 8)        -2       0          -2    5.2          
   17     (7, 10)         2       0           2    6.9          
   18      (8, 9)         0       1           1    6.8     +6.8s
   19     (8, 11)        -4       2          -2    5.3    -10.6s
   20     (9, 10)        -2       0          -2    5.3          
   21    (10, 11)         0      -1          -1    7.9     +7.9s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=4, out=4  OK
  Node 2: in=1, out=1  OK
  Node 3: in=1, out=1  OK
  Node 4: in=1, out=1  OK
  Node 5: in=4, out=4  OK
  Node 6: in=4, out=4  OK
  Node 7: in=2, out=2  OK
  Node 8: in=3, out=3  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 32 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 15

  Summary:
    Original path length:  36 edges
    Spliced path length:   32 edges
    Splices performed:     15
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -3        -3  ✓
    1     (0, 11)           3         3  ✓
    2      (1, 2)           1         1  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)          -3        -3  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           1         1  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -1        -1  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -1        -1  ✓
   12      (5, 6)          -4        -4  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)          -3        -3  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)          -2        -2  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)           1         1  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)          -2        -2  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 13
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2] → J=258, T=200, cost=0 → queued

[Iter 1] cost=0, J=258, T=200, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (164 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (172 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (316 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (99 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (242 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (243 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (155 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (363 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (364 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (95 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (165 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 3, 4, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2] → J=246, T=200, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2] → J=251, T=200, cost=1 → queued
    V_MIN=[2, 2, 4, 3, 3, 2, 2, 2, 2, 2, 1, 2] → J=257, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 4, 3, 2, 2, 2, 2, 2, 1, 2] → J=257, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 4, 2, 2, 2, 2, 2, 1, 2] → J=247, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 3, 1, 2] → J=248, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2] → J=250, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 3] → J=253, T=199, cost=1 → queued

[Iter 2] cost=1, J=257, T=200, edges=36, frontier=7, MILP_calls=9
  V_MIN=[2, 2, 4, 3, 3, 2, 2, 2, 2, 2, 1, 2]
  [backtrack] Found solution with 784 backtracks in 0.00s
  [backtrack] Found solution with 890 backtracks in 0.00s
  [backtrack] Found solution with 4 backtracks in 0.00s
  [backtrack] Found solution with 154 backtracks in 0.00s
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] Found solution with 6 backtracks in 0.00s
  [backtrack] Found solution with 157 backtracks in 0.00s
  [backtrack] Found solution with 135 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 237 backtracks in 0.00s
  [backtrack] Found solution with 359 backtracks in 0.00s
  [backtrack] Found solution with 762 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=120.9s)
  Boundary nodes: [0, 1, 2, 4, 9, 10, 11] → expanding 7 children
    V_MIN=[3, 2, 4, 3, 3, 2, 2, 2, 2, 2, 1, 2] → J=246, T=200, cost=2 → queued
    V_MIN=[2, 3, 4, 3, 3, 2, 2, 2, 2, 2, 1, 2] → J=250, T=200, cost=2 → queued
    V_MIN=[2, 2, 5, 3, 3, 2, 2, 2, 2, 2, 1, 2] → J=256, T=199, cost=2 → queued
    V_MIN=[2, 2, 4, 3, 4, 2, 2, 2, 2, 2, 1, 2] → J=242, T=200, cost=2 → queued
    V_MIN=[2, 2, 4, 3, 3, 2, 2, 2, 2, 3, 1, 2] → J=246, T=200, cost=2 → queued
    V_MIN=[2, 2, 4, 3, 3, 2, 2, 2, 2, 2, 2, 2] → J=250, T=200, cost=2 → queued
    V_MIN=[2, 2, 4, 3, 3, 2, 2, 2, 2, 2, 1, 3] → J=253, T=199, cost=2 → queued

[Iter 3] cost=1, J=257, T=200, edges=36, frontier=13, MILP_calls=16
  V_MIN=[2, 2, 3, 4, 3, 2, 2, 2, 2, 2, 1, 2]
  [backtrack] Found solution with 784 backtracks in 0.00s
  [backtrack] Found solution with 890 backtracks in 0.00s
  [backtrack] Found solution with 4 backtracks in 0.00s
  [backtrack] Found solution with 154 backtracks in 0.00s
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] Found solution with 6 backtracks in 0.00s
  [backtrack] Found solution with 157 backtracks in 0.00s
  [backtrack] Found solution with 135 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 237 backtracks in 0.00s
  [backtrack] Found solution with 359 backtracks in 0.00s
  [backtrack] Found solution with 762 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=120.9s)
  Boundary nodes: [0, 1, 4, 9, 10, 11] → expanding 6 children
    V_MIN=[3, 2, 3, 4, 3, 2, 2, 2, 2, 2, 1, 2] → J=242, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 4, 3, 2, 2, 2, 2, 2, 1, 2] → J=251, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 4, 4, 2, 2, 2, 2, 2, 1, 2] → J=247, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 4, 3, 2, 2, 2, 2, 3, 1, 2] → J=248, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 4, 3, 2, 2, 2, 2, 2, 2, 2] → J=250, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 4, 3, 2, 2, 2, 2, 2, 1, 3] → J=253, T=199, cost=2 → queued

[Iter 4] cost=1, J=253, T=199, edges=36, frontier=18, MILP_calls=22
  V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (1095 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1457 backtracks in 0.00s)
  [backtrack] Found solution with 31 backtracks in 0.00s
  [backtrack] Found solution with 76 backtracks in 0.00s
  [backtrack] Found solution with 607 backtracks in 0.00s
  [backtrack] Found solution with 51 backtracks in 0.00s
  [backtrack] Found solution with 304 backtracks in 0.00s
  [backtrack] Found solution with 429 backtracks in 0.00s
  [backtrack] Found solution with 33 backtracks in 0.00s
  [backtrack] Found solution with 226 backtracks in 0.00s
  [backtrack] Found solution with 265 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (873 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=131.4s)
  Boundary nodes: [0, 1, 4, 7, 9, 10, 11] → expanding 7 children
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 3] → J=246, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 3] → J=246, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 4, 2, 2, 2, 2, 2, 1, 3] → J=243, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 3, 2, 2, 1, 3] → J=252, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 3, 1, 3] → J=244, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3] → J=246, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 4] → J=247, T=200, cost=2 → queued

[Iter 5] cost=1, J=251, T=200, edges=36, frontier=24, MILP_calls=29
  V_MIN=[2, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (438 backtracks in 0.00s)
  [backtrack] Found solution with 101 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 25 backtracks in 0.00s
  [backtrack] Found solution with 25 backtracks in 0.00s
  [backtrack] Found solution with 101 backtracks in 0.00s
  [backtrack] Found solution with 25 backtracks in 0.00s
  [backtrack] Found solution with 25 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 32 backtracks in 0.00s
  [backtrack] Found solution with 219 backtracks in 0.00s
  [backtrack] Found solution with 102 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=121.9s)
  Boundary nodes: [0, 1, 2, 4, 9, 10, 11] → expanding 7 children
    V_MIN=[3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2] → J=246, T=200, cost=2 → queued
    V_MIN=[2, 4, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2] → J=244, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 4, 2, 2, 2, 2, 2, 1, 2] → J=237, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 3, 2, 2, 2, 2, 3, 1, 2] → J=240, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2] → J=243, T=199, cost=2 → queued

[Iter 6] cost=1, J=250, T=200, edges=36, frontier=28, MILP_calls=34
  V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 24 backtracks in 0.00s
  [backtrack] Found solution with 25 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 11 backtracks in 0.00s
  [backtrack] Found solution with 38 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 5 backtracks in 0.00s
  [backtrack] Found solution with 43 backtracks in 0.00s
  [backtrack] Found solution with 23 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=101.1s)
  Boundary nodes: [0, 1, 4, 9, 10, 11] → expanding 6 children
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2] → J=235, T=198, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 4, 2, 2, 2, 2, 2, 2, 2] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 3, 2, 2] → J=241, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 3, 2] → J=236, T=200, cost=2 → queued

[Iter 7] cost=1, J=248, T=200, edges=35, frontier=31, MILP_calls=38
  V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (1769 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1493 backtracks in 0.00s)
  [backtrack] Found solution with 234 backtracks in 0.00s
  [backtrack] Found solution with 237 backtracks in 0.00s
  [backtrack] Found solution with 289 backtracks in 0.00s
  [backtrack] Found solution with 298 backtracks in 0.00s
  [backtrack] Found solution with 176 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (2195 backtracks in 0.00s)
  [backtrack] Found solution with 362 backtracks in 0.00s
  [backtrack] Found solution with 111 backtracks in 0.00s
  [backtrack] Found solution with 632 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1514 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=131.1s)
  Boundary nodes: [0, 1, 2, 4, 7, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 2, 2, 3, 1, 2] → J=231, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 4, 2, 2, 2, 2, 3, 1, 2] → J=233, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 3, 2, 3, 1, 2] → J=246, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 4, 1, 2] → J=236, T=200, cost=2 → queued

[Iter 8] cost=1, J=247, T=199, edges=35, frontier=34, MILP_calls=42
  V_MIN=[2, 2, 3, 3, 4, 2, 2, 2, 2, 2, 1, 2]
  [backtrack] Found solution with 176 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.6s
  *** SOLUTION FOUND! J=247, T_tour=198.6s ***

============================================================
Search done: 8 iters, 42 MILP calls, 42 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 0, 0, 2, -3, 3, 0, -4, 1, 0, -4, -2, -3, 2, 0, -3, 0, -1, 1, 1, 1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 0, 0, 2, -3, 3, 0, -4, 1, 0, -4, -2, -3, 2, 0, -3, 0, -1, 1, 1, 1]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 5), np.int64(2)), ((2, 3), np.int64(-3)), ((2, 8), np.int64(3)), ((3, 4), np.int64(-4)), ((3, 6), np.int64(1)), ((4, 5), np.int64(-4)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(-3)), ((6, 9), np.int64(2)), ((7, 8), np.int64(-3)), ((8, 9), np.int64(-1)), ((8, 11), np.int64(1)), ((9, 10), np.int64(1)), ((10, 11), np.int64(1))]

Blocked edge 1: idx=11, edge=(4, 5), flow_B=-4  →  need Cm[11]=4
Blocked edge 2: idx=1, edge=(0, 11), flow_B=-2  →  need Cm[1]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=78   ||Cm||_1=32

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -1, 0, 0, -1, 1, -2, 0, 0, 3, 1]

Cm = C_oriented @ beta*:
  [-2, 2, -2, 3, -3, -1, 1, -2, 4, 0, -2, 4, 1, -1, 1, 1, 0, -1, -1, 0, 0, 0]

Original flow_B:
  [2, -2, 0, 0, 2, -3, 3, 0, -4, 1, 0, -4, -2, -3, 2, 0, -3, 0, -1, 1, 1, 1]

flow_B + Cm (corrected flow):
  [0, 0, -2, 3, -1, -4, 4, -2, 0, 1, -2, 0, -1, -4, 3, 1, -3, -1, -2, 1, 1, 1]

Verification:
  flow_corrected[11] = 0  (should be 0, Cm=4, d=4)
  flow_corrected[1] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 78  (minimized by MIQP)
  ||Cm||_1  = 32
  ||flow_B||_2² = 93
  ||flow_corrected||_2² = 99

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2      -2           0    4.2     -8.4s
    1     (0, 11)        -2       2           0    7.4    -14.8s ← BLOCKED
    2      (1, 2)         0      -2          -2    5.5    +11.0s
    3      (1, 3)         0       3           3    6.7    +20.1s
    4      (1, 5)         2      -3          -1    5.0     -5.0s
    5      (2, 3)        -3      -1          -4    5.4     +5.4s
    6      (2, 8)         3       1           4    4.0     +4.0s
    7     (2, 11)         0      -2          -2    5.4    +10.8s
    8      (3, 4)        -4       4           0    7.8    -31.2s
    9      (3, 6)         1       0           1    4.9          
   10      (3, 8)         0      -2          -2    5.3    +10.6s
   11      (4, 5)        -4       4           0    7.7    -30.8s ← BLOCKED
   12      (5, 6)        -2       1          -1    4.1     -4.1s
   13      (6, 7)        -3      -1          -4    4.3     +4.3s
   14      (6, 9)         2       1           3    6.5     +6.5s
   15     (6, 10)         0       1           1    7.5     +7.5s
   16      (7, 8)        -3       0          -3    4.0          
   17     (7, 10)         0      -1          -1    7.0     +7.0s
   18      (8, 9)        -1      -1          -2    7.3     +7.3s
   19     (8, 11)         1       0           1    4.3          
   20     (9, 10)         1       0           1    6.6          
   21    (10, 11)         1       0           1    6.0          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=3, out=3  OK
  Node 2: in=6, out=6  OK
  Node 3: in=5, out=5  OK
  Node 5: in=1, out=1  OK
  Node 6: in=5, out=5  OK
  Node 7: in=4, out=4  OK
  Node 8: in=6, out=6  OK
  Node 9: in=3, out=3  OK
  Node 10: in=2, out=2  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 37 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 19

  Summary:
    Original path length:  35 edges
    Spliced path length:   37 edges
    Splices performed:     19
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)          -2        -2  ✓
    3      (1, 3)           3         3  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)          -4        -4  ✓
    6      (2, 8)           4         4  ✓
    7     (2, 11)          -2        -2  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)          -2        -2  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)          -4        -4  ✓
   14      (6, 9)           3         3  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)          -3        -3  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)           1         1  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 14
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 3, 1, 2, 3, 2, 2, 2, 2, 3, 2] → J=204, T=199, cost=0 → queued

[Iter 1] cost=0, J=204, T=199, edges=33, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 3, 1, 2, 3, 2, 2, 2, 2, 3, 2]
  [backtrack] Found solution with 27 backtracks in 0.00s
  [backtrack] Found solution with 35 backtracks in 0.00s
  [backtrack] Found solution with 160 backtracks in 0.00s
  [backtrack] Found solution with 41 backtracks in 0.00s
  [backtrack] Found solution with 427 backtracks in 0.00s
  [backtrack] Found solution with 35 backtracks in 0.00s
  [backtrack] Found solution with 26 backtracks in 0.00s
  [backtrack] Found solution with 215 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (198 backtracks in 0.00s)
  [backtrack] Found solution with 26 backtracks in 0.00s
  [backtrack] Found solution with 30 backtracks in 0.00s
  [backtrack] Found solution with 29 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=94.4s)
  Boundary nodes: [0, 2, 4, 6, 7, 8, 9] → expanding 7 children
    V_MIN=[3, 2, 3, 1, 2, 3, 2, 2, 2, 2, 3, 2] → J=203, T=199, cost=1 → queued
    V_MIN=[2, 2, 4, 1, 2, 3, 2, 2, 2, 2, 3, 2] → J=201, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 1, 3, 3, 2, 2, 2, 2, 3, 2] → J=198, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 1, 2, 3, 3, 2, 2, 2, 3, 2] → J=203, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 1, 2, 3, 2, 3, 2, 2, 3, 2] → J=202, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 1, 2, 3, 2, 2, 3, 2, 3, 2] → J=203, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 1, 2, 3, 2, 2, 2, 3, 3, 2] → J=196, T=200, cost=1 → queued

[Iter 2] cost=1, J=203, T=200, edges=35, frontier=6, MILP_calls=8
  V_MIN=[2, 2, 3, 1, 2, 3, 3, 2, 2, 2, 3, 2]
  [backtrack] Found solution with 442 backtracks in 0.00s
  [backtrack] Found solution with 593 backtracks in 0.00s
  [backtrack] Found solution with 438 backtracks in 0.00s
    ✓ Latency-feasible! source=2, T_tour=200.0s
  *** SOLUTION FOUND! J=203, T_tour=200.0s ***

============================================================
Search done: 2 iters, 8 MILP calls, 8 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 2, -1, 1, 2, -1, 1, 2, -1, 0, 2, 3, 0, 2, 0, -2, 2, 0, -3, 2, 4]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 2, -1, 1, 2, -1, 1, 2, -1, 0, 2, 3, 0, 2, 0, -2, 2, 0, -3, 2, 4]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(2)), ((1, 3), np.int64(-1)), ((1, 5), np.int64(1)), ((2, 3), np.int64(2)), ((2, 8), np.int64(-1)), ((2, 11), np.int64(1)), ((3, 4), np.int64(2)), ((3, 6), np.int64(-1)), ((4, 5), np.int64(2)), ((5, 6), np.int64(3)), ((6, 9), np.int64(2)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(2)), ((8, 11), np.int64(-3)), ((9, 10), np.int64(2)), ((10, 11), np.int64(4))]

Blocked edge 1: idx=11, edge=(4, 5), flow_B=2  →  need Cm[11]=-2
Blocked edge 2: idx=7, edge=(2, 11), flow_B=1  →  need Cm[7]=-1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=21   ||Cm||_1=15

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, 1, 1, 0, 1, -1, 0, -1, 0, -1, -1]

Cm = C_oriented @ beta*:
  [0, 0, 0, -1, 1, 1, 0, -1, -2, 0, 2, -2, -1, 0, 0, -1, -1, 1, 0, 1, 0, 0]

Original flow_B:
  [2, -2, 2, -1, 1, 2, -1, 1, 2, -1, 0, 2, 3, 0, 2, 0, -2, 2, 0, -3, 2, 4]

flow_B + Cm (corrected flow):
  [2, -2, 2, -2, 2, 3, -1, 0, 0, -1, 2, 0, 2, 0, 2, -1, -3, 3, 0, -2, 2, 4]

Verification:
  flow_corrected[11] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[7] = 0  (should be 0, Cm=-1, d=-1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 21  (minimized by MIQP)
  ||Cm||_1  = 15
  ||flow_B||_2² = 79
  ||flow_corrected||_2² = 86

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    6.2          
    1     (0, 11)        -2       0          -2    4.0          
    2      (1, 2)         2       0           2    6.7          
    3      (1, 3)        -1      -1          -2    4.8     +4.8s
    4      (1, 5)         1       1           2    7.7     +7.7s
    5      (2, 3)         2       1           3    5.5     +5.5s
    6      (2, 8)        -1       0          -1    7.0          
    7     (2, 11)         1      -1           0    7.1     -7.1s ← BLOCKED
    8      (3, 4)         2      -2           0    7.5    -15.0s
    9      (3, 6)        -1       0          -1    4.4          
   10      (3, 8)         0       2           2    5.2    +10.4s
   11      (4, 5)         2      -2           0    5.9    -11.8s ← BLOCKED
   12      (5, 6)         3      -1           2    6.7     -6.7s
   13      (6, 7)         0       0           0    5.0          
   14      (6, 9)         2       0           2    6.8          
   15     (6, 10)         0      -1          -1    6.6     +6.6s
   16      (7, 8)        -2      -1          -3    4.7     +4.7s
   17     (7, 10)         2       1           3    5.3     +5.3s
   18      (8, 9)         0       0           0    7.6          
   19     (8, 11)        -3       1          -2    4.3     -4.3s
   20     (9, 10)         2       0           2    7.0          
   21    (10, 11)         4       0           4    4.2          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=4, out=4  OK
  Node 2: in=3, out=3  OK
  Node 3: in=4, out=4  OK
  Node 5: in=2, out=2  OK
  Node 6: in=3, out=3  OK
  Node 7: in=3, out=3  OK
  Node 8: in=4, out=4  OK
  Node 9: in=2, out=2  OK
  Node 10: in=5, out=5  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 30

  Summary:
    Original path length:  35 edges
    Spliced path length:   36 edges
    Splices performed:     30
    Path is continuous:    True
    Returns to source 2: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           2         2  ✓
    3      (1, 3)          -2        -2  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           3         3  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)           2         2  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)           2         2  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)          -3        -3  ✓
   17     (7, 10)           3         3  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           4         4  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 15
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 2] → J=166, T=199, cost=0 → queued

[Iter 1] cost=0, J=166, T=199, edges=34, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 2]
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.4s
  *** SOLUTION FOUND! J=166, T_tour=199.4s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, 0, 0, -3, -1, 0, 1, 2, -3, 0, 2, -1, 0, -1, -3, 2, -2, 2, 0, 1, -4]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, 0, 0, -3, -1, 0, 1, 2, -3, 0, 2, -1, 0, -1, -3, 2, -2, 2, 0, 1, -4]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 5), np.int64(-3)), ((2, 3), np.int64(-1)), ((2, 11), np.int64(1)), ((3, 4), np.int64(2)), ((3, 6), np.int64(-3)), ((4, 5), np.int64(2)), ((5, 6), np.int64(-1)), ((6, 9), np.int64(-1)), ((6, 10), np.int64(-3)), ((7, 8), np.int64(2)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(2)), ((9, 10), np.int64(1)), ((10, 11), np.int64(-4))]

Blocked edge 1: idx=0, edge=(0, 1), flow_B=-3  →  need Cm[0]=3
Blocked edge 2: idx=15, edge=(6, 10), flow_B=-3  →  need Cm[15]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=48   ||Cm||_1=24

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-2, -3, 1, 0, 2, 0, 3, 2, -1, 0, 1]

Cm = C_oriented @ beta*:
  [3, -3, 1, 2, 0, 0, -1, 2, 0, 1, 1, 0, 0, -1, -1, 3, 1, -2, 1, 0, 0, 1]

Original flow_B:
  [-3, 3, 0, 0, -3, -1, 0, 1, 2, -3, 0, 2, -1, 0, -1, -3, 2, -2, 2, 0, 1, -4]

flow_B + Cm (corrected flow):
  [0, 0, 1, 2, -3, -1, -1, 3, 2, -2, 1, 2, -1, -1, -2, 0, 3, -4, 3, 0, 1, -3]

Verification:
  flow_corrected[0] = 0  (should be 0, Cm=3, d=3)
  flow_corrected[15] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 48  (minimized by MIQP)
  ||Cm||_1  = 24
  ||flow_B||_2² = 86
  ||flow_corrected||_2² = 88

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       3           0    6.9    -20.7s ← BLOCKED
    1     (0, 11)         3      -3           0    7.5    -22.5s
    2      (1, 2)         0       1           1    7.2     +7.2s
    3      (1, 3)         0       2           2    4.8     +9.6s
    4      (1, 5)        -3       0          -3    4.7          
    5      (2, 3)        -1       0          -1    4.2          
    6      (2, 8)         0      -1          -1    4.2     +4.2s
    7     (2, 11)         1       2           3    4.8     +9.6s
    8      (3, 4)         2       0           2    8.0          
    9      (3, 6)        -3       1          -2    5.5     -5.5s
   10      (3, 8)         0       1           1    7.0     +7.0s
   11      (4, 5)         2       0           2    5.9          
   12      (5, 6)        -1       0          -1    6.0          
   13      (6, 7)         0      -1          -1    7.8     +7.8s
   14      (6, 9)        -1      -1          -2    4.4     +4.4s
   15     (6, 10)        -3       3           0    5.9    -17.7s ← BLOCKED
   16      (7, 8)         2       1           3    4.6     +4.6s
   17     (7, 10)        -2      -2          -4    6.2    +12.4s
   18      (8, 9)         2       1           3    5.2     +5.2s
   19     (8, 11)         0       0           0    6.2          
   20     (9, 10)         1       0           1    6.7          
   21    (10, 11)        -4       1          -3    5.5     -5.5s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=3, out=3  OK
  Node 2: in=3, out=3  OK
  Node 3: in=4, out=4  OK
  Node 4: in=2, out=2  OK
  Node 5: in=3, out=3  OK
  Node 6: in=3, out=3  OK
  Node 7: in=4, out=4  OK
  Node 8: in=4, out=4  OK
  Node 9: in=3, out=3  OK
  Node 10: in=4, out=4  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 17

  Summary:
    Original path length:  34 edges
    Spliced path length:   36 edges
    Splices performed:     17
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           1         1  ✓
    3      (1, 3)           2         2  ✓
    4      (1, 5)          -3        -3  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           3         3  ✓
    8      (3, 4)           2         2  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)           1         1  ✓
   11      (4, 5)           2         2  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)          -2        -2  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           3         3  ✓
   17     (7, 10)          -4        -4  ✓
   18      (8, 9)           3         3  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)          -3        -3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 16
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 1, 2, 2, 2, 2, 2, 3, 2, 2] → J=196, T=198, cost=0 → queued

[Iter 1] cost=0, J=196, T=198, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 1, 2, 2, 2, 2, 2, 3, 2, 2]
  [backtrack] Found solution with 17 backtracks in 0.00s
  [backtrack] Found solution with 12 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=198.2s
  *** SOLUTION FOUND! J=196, T_tour=198.2s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -4, 2, 0, 0, -2, -2, 2, 0, 0, 2, 2, 2, -3, 3, 0, 2, -2, 0, -5, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -4, 2, 0, 0, -2, -2, 2, 0, 0, 2, 2, 2, -3, 3, 0, 2, -2, 0, -5, 0]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-4)), ((1, 3), np.int64(2)), ((2, 8), np.int64(-2)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(2)), ((4, 5), np.int64(2)), ((5, 6), np.int64(2)), ((6, 7), np.int64(2)), ((6, 9), np.int64(-3)), ((6, 10), np.int64(3)), ((7, 10), np.int64(2)), ((8, 9), np.int64(-2)), ((9, 10), np.int64(-5))]

Blocked edge 1: idx=8, edge=(3, 4), flow_B=2  →  need Cm[8]=-2
Blocked edge 2: idx=17, edge=(7, 10), flow_B=2  →  need Cm[17]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=23   ||Cm||_1=17

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, -1, -1, 0, 0, -1, 0, 0, 1, -1, 0]

Cm = C_oriented @ beta*:
  [0, 0, -1, 0, 1, -1, -1, 1, -2, 1, 0, -2, -1, -1, 0, 1, 1, -2, 0, 0, 0, -1]

Original flow_B:
  [-2, 2, -4, 2, 0, 0, -2, -2, 2, 0, 0, 2, 2, 2, -3, 3, 0, 2, -2, 0, -5, 0]

flow_B + Cm (corrected flow):
  [-2, 2, -5, 2, 1, -1, -3, -1, 0, 1, 0, 0, 1, 1, -3, 4, 1, 0, -2, 0, -5, -1]

Verification:
  flow_corrected[8] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[17] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 23  (minimized by MIQP)
  ||Cm||_1  = 17
  ||flow_B||_2² = 103
  ||flow_corrected||_2² = 108

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    6.9          
    1     (0, 11)         2       0           2    4.6          
    2      (1, 2)        -4      -1          -5    5.0     +5.0s
    3      (1, 3)         2       0           2    5.2          
    4      (1, 5)         0       1           1    6.8     +6.8s
    5      (2, 3)         0      -1          -1    5.9     +5.9s
    6      (2, 8)        -2      -1          -3    4.9     +4.9s
    7     (2, 11)        -2       1          -1    5.8     -5.8s
    8      (3, 4)         2      -2           0    4.5     -9.0s ← BLOCKED
    9      (3, 6)         0       1           1    7.7     +7.7s
   10      (3, 8)         0       0           0    6.3          
   11      (4, 5)         2      -2           0    5.9    -11.8s
   12      (5, 6)         2      -1           1    5.3     -5.3s
   13      (6, 7)         2      -1           1    4.2     -4.2s
   14      (6, 9)        -3       0          -3    7.0          
   15     (6, 10)         3       1           4    6.2     +6.2s
   16      (7, 8)         0       1           1    7.1     +7.1s
   17     (7, 10)         2      -2           0    7.2    -14.4s ← BLOCKED
   18      (8, 9)        -2       0          -2    4.3          
   19     (8, 11)         0       0           0    6.6          
   20     (9, 10)        -5       0          -5    4.2          
   21    (10, 11)         0      -1          -1    6.7     +6.7s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=5, out=5  OK
  Node 2: in=5, out=5  OK
  Node 3: in=2, out=2  OK
  Node 5: in=1, out=1  OK
  Node 6: in=5, out=5  OK
  Node 7: in=1, out=1  OK
  Node 8: in=3, out=3  OK
  Node 9: in=5, out=5  OK
  Node 10: in=5, out=5  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 20

  Summary:
    Original path length:  37 edges
    Spliced path length:   36 edges
    Splices performed:     20
    Path is continuous:    True
    Returns to source 1: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)          -5        -5  ✓
    3      (1, 3)           2         2  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)          -3        -3  ✓
    7     (2, 11)          -1        -1  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)          -3        -3  ✓
   15     (6, 10)           4         4  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)          -5        -5  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 17
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 3, 2] → J=225, T=196, cost=0 → queued

[Iter 1] cost=0, J=225, T=196, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 3, 2]
  [backtrack] Found solution with 75 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=195.7s
  *** SOLUTION FOUND! J=225, T_tour=195.7s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 2, 0, 0, 1, 1, 0, 2, 0, -1, 2, 2, -4, -2, 8, 0, -4, 0, 0, -2, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 2, 0, 0, 1, 1, 0, 2, 0, -1, 2, 2, -4, -2, 8, 0, -4, 0, 0, -2, 2]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(2)), ((2, 3), np.int64(1)), ((2, 8), np.int64(1)), ((3, 4), np.int64(2)), ((3, 8), np.int64(-1)), ((4, 5), np.int64(2)), ((5, 6), np.int64(2)), ((6, 7), np.int64(-4)), ((6, 9), np.int64(-2)), ((6, 10), np.int64(8)), ((7, 10), np.int64(-4)), ((9, 10), np.int64(-2)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=21, edge=(10, 11), flow_B=2  →  need Cm[21]=-2
Blocked edge 2: idx=10, edge=(3, 8), flow_B=-1  →  need Cm[10]=1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=16   ||Cm||_1=14

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 1, -1, -1, 0, -1, -1, -2, 2, 1, -1]

Cm = C_oriented @ beta*:
  [-1, 1, 0, 0, -1, 1, -1, 0, 0, 0, 1, 0, -1, -1, 0, 0, 0, -1, -1, 1, -1, -2]

Original flow_B:
  [2, -2, 2, 0, 0, 1, 1, 0, 2, 0, -1, 2, 2, -4, -2, 8, 0, -4, 0, 0, -2, 2]

flow_B + Cm (corrected flow):
  [1, -1, 2, 0, -1, 2, 0, 0, 2, 0, 0, 2, 1, -5, -2, 8, 0, -5, -1, 1, -3, 0]

Verification:
  flow_corrected[21] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[10] = 0  (should be 0, Cm=1, d=1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 16  (minimized by MIQP)
  ||Cm||_1  = 14
  ||flow_B||_2² = 135
  ||flow_corrected||_2² = 149

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2      -1           1    7.5     -7.5s
    1     (0, 11)        -2       1          -1    7.5     -7.5s
    2      (1, 2)         2       0           2    4.2          
    3      (1, 3)         0       0           0    6.6          
    4      (1, 5)         0      -1          -1    6.2     +6.2s
    5      (2, 3)         1       1           2    6.4     +6.4s
    6      (2, 8)         1      -1           0    5.9     -5.9s
    7     (2, 11)         0       0           0    5.1          
    8      (3, 4)         2       0           2    5.2          
    9      (3, 6)         0       0           0    6.2          
   10      (3, 8)        -1       1           0    5.6     -5.6s ← BLOCKED
   11      (4, 5)         2       0           2    7.2          
   12      (5, 6)         2      -1           1    5.7     -5.7s
   13      (6, 7)        -4      -1          -5    4.6     +4.6s
   14      (6, 9)        -2       0          -2    4.6          
   15     (6, 10)         8       0           8    4.2          
   16      (7, 8)         0       0           0    6.9          
   17     (7, 10)        -4      -1          -5    5.2     +5.2s
   18      (8, 9)         0      -1          -1    4.8     +4.8s
   19     (8, 11)         0       1           1    7.3     +7.3s
   20     (9, 10)        -2      -1          -3    6.3     +6.3s
   21    (10, 11)         2      -2           0    4.3     -8.6s ← BLOCKED

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=1, out=1  OK
  Node 1: in=2, out=2  OK
  Node 2: in=2, out=2  OK
  Node 3: in=2, out=2  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=8, out=8  OK
  Node 7: in=5, out=5  OK
  Node 8: in=1, out=1  OK
  Node 9: in=3, out=3  OK
  Node 10: in=8, out=8  OK
  Node 11: in=1, out=1  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 37 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 17

  Summary:
    Original path length:  37 edges
    Spliced path length:   37 edges
    Splices performed:     17
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           1         1  ✓
    1     (0, 11)          -1        -1  ✓
    2      (1, 2)           2         2  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)           2         2  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           2         2  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           2         2  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)          -5        -5  ✓
   14      (6, 9)          -2        -2  ✓
   15     (6, 10)           8         8  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)          -5        -5  ✓
   18      (8, 9)          -1        -1  ✓
   19     (8, 11)           1         1  ✓
   20     (9, 10)          -3        -3  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 18
================================================================================
✗ STATUS: FAILED EXCEPTION
Traceback (most recent call last):
  File "/Users/richardguo/Desktop/IROS_main/edge_block_batch_full.py", line 447, in <module>
    raise RuntimeError("Could not obtain a latency-feasible flow_B.")
RuntimeError: Could not obtain a latency-feasible flow_B.

================================================================================
TRIAL 19
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 1, 2, 2, 3, 2, 2, 2] → J=223, T=198, cost=0 → queued

[Iter 1] cost=0, J=223, T=198, edges=36, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 1, 2, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 20 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=197.8s
  *** SOLUTION FOUND! J=223, T_tour=197.8s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -2, 2, -2, 0, -2, 0, 2, 0, 0, 2, 0, 3, -3, 0, 5, -2, 4, -1, 1, -1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -2, 2, -2, 0, -2, 0, 2, 0, 0, 2, 0, 3, -3, 0, 5, -2, 4, -1, 1, -1]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-2)), ((1, 3), np.int64(2)), ((1, 5), np.int64(-2)), ((2, 8), np.int64(-2)), ((3, 4), np.int64(2)), ((4, 5), np.int64(2)), ((6, 7), np.int64(3)), ((6, 9), np.int64(-3)), ((7, 8), np.int64(5)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(4)), ((8, 11), np.int64(-1)), ((9, 10), np.int64(1)), ((10, 11), np.int64(-1))]

Blocked edge 1: idx=13, edge=(6, 7), flow_B=3  →  need Cm[13]=-3
Blocked edge 2: idx=4, edge=(1, 5), flow_B=-2  →  need Cm[4]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=36   ||Cm||_1=24

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, -3, 0, 1, 1, 1, 1, 0, -1, -2, 0]

Cm = C_oriented @ beta*:
  [1, -1, 0, -1, 2, 0, -1, 1, -1, -1, 1, -1, 1, -3, 1, 2, -1, -2, 0, -1, 1, 1]

Original flow_B:
  [-2, 2, -2, 2, -2, 0, -2, 0, 2, 0, 0, 2, 0, 3, -3, 0, 5, -2, 4, -1, 1, -1]

flow_B + Cm (corrected flow):
  [-1, 1, -2, 1, 0, 0, -3, 1, 1, -1, 1, 1, 1, 0, -2, 2, 4, -4, 4, -2, 2, 0]

Verification:
  flow_corrected[13] = 0  (should be 0, Cm=-3, d=-3)
  flow_corrected[4] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 36  (minimized by MIQP)
  ||Cm||_1  = 24
  ||flow_B||_2² = 98
  ||flow_corrected||_2² = 86

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       1          -1    6.2     -6.2s
    1     (0, 11)         2      -1           1    4.9     -4.9s
    2      (1, 2)        -2       0          -2    4.5          
    3      (1, 3)         2      -1           1    6.0     -6.0s
    4      (1, 5)        -2       2           0    4.6     -9.2s ← BLOCKED
    5      (2, 3)         0       0           0    6.1          
    6      (2, 8)        -2      -1          -3    5.5     +5.5s
    7     (2, 11)         0       1           1    6.8     +6.8s
    8      (3, 4)         2      -1           1    5.5     -5.5s
    9      (3, 6)         0      -1          -1    7.8     +7.8s
   10      (3, 8)         0       1           1    7.1     +7.1s
   11      (4, 5)         2      -1           1    6.4     -6.4s
   12      (5, 6)         0       1           1    6.5     +6.5s
   13      (6, 7)         3      -3           0    6.6    -19.8s ← BLOCKED
   14      (6, 9)        -3       1          -2    5.1     -5.1s
   15     (6, 10)         0       2           2    7.0    +14.0s
   16      (7, 8)         5      -1           4    5.1     -5.1s
   17     (7, 10)        -2      -2          -4    6.8    +13.6s
   18      (8, 9)         4       0           4    4.3          
   19     (8, 11)        -1      -1          -2    6.8     +6.8s
   20     (9, 10)         1       1           2    6.2     +6.2s
   21    (10, 11)        -1       1           0    6.2     -6.2s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=1, out=1  OK
  Node 1: in=2, out=2  OK
  Node 2: in=3, out=3  OK
  Node 3: in=2, out=2  OK
  Node 4: in=1, out=1  OK
  Node 5: in=1, out=1  OK
  Node 6: in=3, out=3  OK
  Node 7: in=4, out=4  OK
  Node 8: in=7, out=7  OK
  Node 9: in=4, out=4  OK
  Node 10: in=4, out=4  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 16

  Summary:
    Original path length:  36 edges
    Spliced path length:   34 edges
    Splices performed:     16
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -1        -1  ✓
    1     (0, 11)           1         1  ✓
    2      (1, 2)          -2        -2  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)          -3        -3  ✓
    7     (2, 11)           1         1  ✓
    8      (3, 4)           1         1  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)           1         1  ✓
   11      (4, 5)           1         1  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)          -2        -2  ✓
   15     (6, 10)           2         2  ✓
   16      (7, 8)           4         4  ✓
   17     (7, 10)          -4        -4  ✓
   18      (8, 9)           4         4  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 20
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 3, 3, 1, 2, 2, 2, 2, 2, 2, 2] → J=244, T=198, cost=0 → queued

[Iter 1] cost=0, J=244, T=198, edges=36, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 3, 3, 1, 2, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 927 backtracks in 0.00s
  [backtrack] Found solution with 726 backtracks in 0.00s
  [backtrack] Found solution with 139 backtracks in 0.00s
  [backtrack] Found solution with 512 backtracks in 0.00s
  [backtrack] Found solution with 298 backtracks in 0.00s
  [backtrack] Found solution with 51 backtracks in 0.00s
    ✓ Latency-feasible! source=5, T_tour=197.7s
  DFS: latency violated (1 nodes, worst_gap=116.1s)
  Boundary nodes: [0, 4, 5, 6, 7, 9] → expanding 6 children
    V_MIN=[3, 3, 3, 3, 1, 2, 2, 2, 2, 2, 2, 2] → J=235, T=199, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2] → J=242, T=199, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 1, 3, 2, 2, 2, 2, 2, 2] → J=242, T=199, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 1, 2, 3, 2, 2, 2, 2, 2] → J=241, T=199, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 1, 2, 2, 3, 2, 2, 2, 2] → J=238, T=200, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 1, 2, 2, 2, 2, 3, 2, 2] → J=235, T=199, cost=1 → queued

[Iter 2] cost=1, J=242, T=199, edges=35, frontier=5, MILP_calls=7
  V_MIN=[2, 3, 3, 3, 1, 3, 2, 2, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (1145 backtracks in 0.00s)
  [backtrack] Found solution with 89 backtracks in 0.00s
  [backtrack] Found solution with 248 backtracks in 0.00s
  [backtrack] Found solution with 89 backtracks in 0.00s
  [backtrack] Found solution with 22 backtracks in 0.00s
  [backtrack] Found solution with 12 backtracks in 0.00s
  [backtrack] Found solution with 283 backtracks in 0.00s
  [backtrack] Found solution with 4 backtracks in 0.00s
  [backtrack] Found solution with 160 backtracks in 0.00s
  [backtrack] Found solution with 283 backtracks in 0.00s
  [backtrack] Found solution with 249 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1039 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=119.0s)
  Boundary nodes: [0, 2, 4, 5, 6, 7, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 3, 3, 3, 1, 3, 2, 2, 2, 2, 2, 2] → J=234, T=199, cost=2 → queued
    V_MIN=[2, 3, 4, 3, 1, 3, 2, 2, 2, 2, 2, 2] → J=242, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2] → J=239, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 1, 4, 2, 2, 2, 2, 2, 2] → J=237, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 1, 3, 3, 2, 2, 2, 2, 2] → J=237, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 1, 3, 2, 3, 2, 2, 2, 2] → J=238, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 1, 3, 2, 2, 2, 3, 2, 2] → J=232, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 1, 3, 2, 2, 2, 2, 3, 2] → J=238, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 1, 3, 2, 2, 2, 2, 2, 3] → J=242, T=197, cost=2 → queued

[Iter 3] cost=1, J=242, T=199, edges=36, frontier=13, MILP_calls=16
  V_MIN=[2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 486 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (524 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (289 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (794 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (415 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (383 backtracks in 0.00s)
  [backtrack] Found solution with 533 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (334 backtracks in 0.00s)
  [backtrack] Found solution with 725 backtracks in 0.00s
  [backtrack] Found solution with 550 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=84.9s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2] → J=235, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2] → J=238, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 3, 2, 2, 2, 2, 2] → J=236, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 3, 2, 2, 2, 2] → J=238, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 2, 2, 3, 2, 2] → J=232, T=198, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2] → J=239, T=200, cost=2 → queued

[Iter 4] cost=1, J=241, T=199, edges=35, frontier=18, MILP_calls=22
  V_MIN=[2, 3, 3, 3, 1, 2, 3, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 197 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.0s
  *** SOLUTION FOUND! J=241, T_tour=199.0s ***

============================================================
Search done: 4 iters, 22 MILP calls, 22 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 1, -5, 2, 3, 2, -4, -1, -1, 0, -1, 1, -2, 2, 0, -2, 0, 0, 0, 2, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 1, -5, 2, 3, 2, -4, -1, -1, 0, -1, 1, -2, 2, 0, -2, 0, 0, 0, 2, 2]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(1)), ((1, 3), np.int64(-5)), ((1, 5), np.int64(2)), ((2, 3), np.int64(3)), ((2, 8), np.int64(2)), ((2, 11), np.int64(-4)), ((3, 4), np.int64(-1)), ((3, 6), np.int64(-1)), ((4, 5), np.int64(-1)), ((5, 6), np.int64(1)), ((6, 7), np.int64(-2)), ((6, 9), np.int64(2)), ((7, 8), np.int64(-2)), ((9, 10), np.int64(2)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=14, edge=(6, 9), flow_B=2  →  need Cm[14]=-2
Blocked edge 2: idx=7, edge=(2, 11), flow_B=-4  →  need Cm[7]=4
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=44   ||Cm||_1=22

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 0, -4, -1, -2, 0, 0, 0, 1, 0, -1]

Cm = C_oriented @ beta*:
  [0, 0, 1, -1, 0, -1, -2, 4, 0, -1, -1, 0, 0, 0, -2, 1, 1, -1, 1, -3, -1, -1]

Original flow_B:
  [-2, 2, 1, -5, 2, 3, 2, -4, -1, -1, 0, -1, 1, -2, 2, 0, -2, 0, 0, 0, 2, 2]

flow_B + Cm (corrected flow):
  [-2, 2, 2, -6, 2, 2, 0, 0, -1, -2, -1, -1, 1, -2, 0, 1, -1, -1, 1, -3, 1, 1]

Verification:
  flow_corrected[14] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[7] = 0  (should be 0, Cm=4, d=4)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 44  (minimized by MIQP)
  ||Cm||_1  = 22
  ||flow_B||_2² = 91
  ||flow_corrected||_2² = 83

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    7.1          
    1     (0, 11)         2       0           2    7.4          
    2      (1, 2)         1       1           2    7.1     +7.1s
    3      (1, 3)        -5      -1          -6    4.1     +4.1s
    4      (1, 5)         2       0           2    4.5          
    5      (2, 3)         3      -1           2    7.0     -7.0s
    6      (2, 8)         2      -2           0    5.0    -10.0s
    7     (2, 11)        -4       4           0    5.0    -20.0s ← BLOCKED
    8      (3, 4)        -1       0          -1    7.4          
    9      (3, 6)        -1      -1          -2    7.8     +7.8s
   10      (3, 8)         0      -1          -1    6.2     +6.2s
   11      (4, 5)        -1       0          -1    4.7          
   12      (5, 6)         1       0           1    7.1          
   13      (6, 7)        -2       0          -2    6.0          
   14      (6, 9)         2      -2           0    6.5    -13.0s ← BLOCKED
   15     (6, 10)         0       1           1    7.4     +7.4s
   16      (7, 8)        -2       1          -1    5.8     -5.8s
   17     (7, 10)         0      -1          -1    6.0     +6.0s
   18      (8, 9)         0       1           1    6.7     +6.7s
   19     (8, 11)         0      -3          -3    6.6    +19.8s
   20     (9, 10)         2      -1           1    5.1     -5.1s
   21    (10, 11)         2      -1           1    4.3     -4.3s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=6, out=6  OK
  Node 2: in=2, out=2  OK
  Node 3: in=6, out=6  OK
  Node 4: in=1, out=1  OK
  Node 5: in=2, out=2  OK
  Node 6: in=3, out=3  OK
  Node 7: in=2, out=2  OK
  Node 8: in=3, out=3  OK
  Node 9: in=1, out=1  OK
  Node 10: in=2, out=2  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 33 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 17

  Summary:
    Original path length:  35 edges
    Spliced path length:   33 edges
    Splices performed:     17
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)           2         2  ✓
    3      (1, 3)          -6        -6  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           2         2  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -1        -1  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)          -1        -1  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)          -2        -2  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)           1         1  ✓
   19     (8, 11)          -3        -3  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 21
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3] → J=171, T=199, cost=0 → queued

[Iter 1] cost=0, J=171, T=199, edges=34, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3]
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 77 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
    ✓ Latency-feasible! source=2, T_tour=199.4s
  *** SOLUTION FOUND! J=171, T_tour=199.4s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 2, 0, 0, -2, -2, 6, -2, 0, 0, -2, -2, 0, -2, 0, 2, -2, 2, -2, 0, -2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 2, 0, 0, -2, -2, 6, -2, 0, 0, -2, -2, 0, -2, 0, 2, -2, 2, -2, 0, -2]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(2)), ((2, 3), np.int64(-2)), ((2, 8), np.int64(-2)), ((2, 11), np.int64(6)), ((3, 4), np.int64(-2)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-2)), ((6, 9), np.int64(-2)), ((7, 8), np.int64(2)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(2)), ((8, 11), np.int64(-2)), ((10, 11), np.int64(-2))]

Blocked edge 1: idx=6, edge=(2, 8), flow_B=-2  →  need Cm[6]=2
Blocked edge 2: idx=8, edge=(3, 4), flow_B=-2  →  need Cm[8]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=24   ||Cm||_1=14

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [2, 0, 0, 0, -2, 0, 0, -1, 0, 2, -1]

Cm = C_oriented @ beta*:
  [0, 0, 2, 0, -2, 0, 2, 0, 2, -1, -1, 2, 0, -1, 0, 0, -1, 0, 0, 0, 0, 0]

Original flow_B:
  [2, -2, 2, 0, 0, -2, -2, 6, -2, 0, 0, -2, -2, 0, -2, 0, 2, -2, 2, -2, 0, -2]

flow_B + Cm (corrected flow):
  [2, -2, 4, 0, -2, -2, 0, 6, 0, -1, -1, 0, -2, -1, -2, 0, 1, -2, 2, -2, 0, -2]

Verification:
  flow_corrected[6] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[8] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 24  (minimized by MIQP)
  ||Cm||_1  = 14
  ||flow_B||_2² = 92
  ||flow_corrected||_2² = 96

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    4.5          
    1     (0, 11)        -2       0          -2    4.7          
    2      (1, 2)         2       2           4    6.0    +12.0s
    3      (1, 3)         0       0           0    7.5          
    4      (1, 5)         0      -2          -2    7.0    +14.0s
    5      (2, 3)        -2       0          -2    7.9          
    6      (2, 8)        -2       2           0    7.0    -14.0s ← BLOCKED
    7     (2, 11)         6       0           6    5.5          
    8      (3, 4)        -2       2           0    5.6    -11.2s ← BLOCKED
    9      (3, 6)         0      -1          -1    6.9     +6.9s
   10      (3, 8)         0      -1          -1    5.1     +5.1s
   11      (4, 5)        -2       2           0    7.4    -14.8s
   12      (5, 6)        -2       0          -2    7.7          
   13      (6, 7)         0      -1          -1    7.0     +7.0s
   14      (6, 9)        -2       0          -2    6.1          
   15     (6, 10)         0       0           0    4.7          
   16      (7, 8)         2      -1           1    5.2     -5.2s
   17     (7, 10)        -2       0          -2    5.1          
   18      (8, 9)         2       0           2    5.3          
   19     (8, 11)        -2       0          -2    5.8          
   20     (9, 10)         0       0           0    6.2          
   21    (10, 11)        -2       0          -2    4.9          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=4, out=4  OK
  Node 2: in=6, out=6  OK
  Node 3: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=3, out=3  OK
  Node 7: in=2, out=2  OK
  Node 8: in=3, out=3  OK
  Node 9: in=2, out=2  OK
  Node 10: in=2, out=2  OK
  Node 11: in=6, out=6  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 22

  Summary:
    Original path length:  34 edges
    Spliced path length:   34 edges
    Splices performed:     22
    Path is continuous:    True
    Returns to source 2: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           4         4  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)          -2        -2  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           6         6  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)          -2        -2  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)          -2        -2  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           2         2  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)          -2        -2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 22
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1, 2] → J=176, T=199, cost=0 → queued

[Iter 1] cost=0, J=176, T=199, edges=34, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1, 2]
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 422 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 3 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 76 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1334 backtracks in 0.00s)
  [backtrack] Found solution with 58 backtracks in 0.00s
  [backtrack] Found solution with 84 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=95.9s)
  Boundary nodes: [0, 2, 4, 5, 7, 8, 9] → expanding 7 children
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1, 2] → J=167, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 2, 2, 3, 1, 2] → J=174, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 2, 2, 3, 1, 2] → J=168, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 2, 2, 2, 3, 1, 2] → J=168, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 3, 2, 3, 1, 2] → J=169, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 3, 3, 1, 2] → J=175, T=198, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 4, 1, 2] → J=173, T=200, cost=1 → queued

[Iter 2] cost=1, J=175, T=198, edges=34, frontier=6, MILP_calls=8
  V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 3, 3, 1, 2]
  [backtrack] Found solution with 80 backtracks in 0.00s
  [backtrack] Found solution with 35 backtracks in 0.00s
  [backtrack] Found solution with 64 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 398 backtracks in 0.00s
  [backtrack] Found solution with 261 backtracks in 0.00s
  [backtrack] Found solution with 48 backtracks in 0.00s
  [backtrack] Found solution with 40 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (836 backtracks in 0.00s)
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 83 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=95.9s)
  Boundary nodes: [0, 2, 4, 5, 6, 7, 8, 9] → expanding 8 children
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 2, 3, 3, 1, 2] → J=167, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 2, 3, 3, 1, 2] → J=172, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 2, 3, 3, 1, 2] → J=163, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 2, 2, 3, 3, 1, 2] → J=167, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 3, 2, 3, 3, 1, 2] → J=172, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 3, 3, 3, 1, 2] → J=168, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 4, 3, 1, 2] → J=173, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 3, 4, 1, 2] → J=170, T=198, cost=2 → queued

[Iter 3] cost=1, J=174, T=199, edges=34, frontier=13, MILP_calls=16
  V_MIN=[2, 2, 3, 3, 2, 2, 2, 2, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (207 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (163 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (184 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (232 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (216 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (162 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (142 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (235 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (188 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (135 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (302 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (268 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 2, 2, 3, 1, 2] → J=164, T=200, cost=2 → queued
    V_MIN=[2, 2, 4, 3, 2, 2, 2, 2, 2, 3, 1, 2] → J=173, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 3, 1, 2] → J=161, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 3, 2, 2, 2, 3, 1, 2] → J=165, T=198, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 3, 2, 3, 1, 2] → J=169, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 2, 2, 4, 1, 2] → J=169, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 2, 2, 3, 1, 3] → J=173, T=199, cost=2 → queued

[Iter 4] cost=1, J=173, T=200, edges=34, frontier=19, MILP_calls=23
  V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 4, 1, 2]
  [backtrack] Found solution with 2 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.6s
  *** SOLUTION FOUND! J=173, T_tour=199.6s ***

============================================================
Search done: 4 iters, 23 MILP calls, 23 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, -2, 4, 0, -1, 0, -1, 2, 0, 1, 2, 2, -2, 4, 0, -2, 0, -1, 0, 3, 3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, -2, 4, 0, -1, 0, -1, 2, 0, 1, 2, 2, -2, 4, 0, -2, 0, -1, 0, 3, 3]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(-2)), ((1, 3), np.int64(4)), ((2, 3), np.int64(-1)), ((2, 11), np.int64(-1)), ((3, 4), np.int64(2)), ((3, 8), np.int64(1)), ((4, 5), np.int64(2)), ((5, 6), np.int64(2)), ((6, 7), np.int64(-2)), ((6, 9), np.int64(4)), ((7, 8), np.int64(-2)), ((8, 9), np.int64(-1)), ((9, 10), np.int64(3)), ((10, 11), np.int64(3))]

Blocked edge 1: idx=16, edge=(7, 8), flow_B=-2  →  need Cm[16]=2
Blocked edge 2: idx=3, edge=(1, 3), flow_B=4  →  need Cm[3]=-4
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=46   ||Cm||_1=24

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [2, 0, -1, 1, 0, 2, 0, 1, 1, -2, 1]

Cm = C_oriented @ beta*:
  [0, 0, 2, -4, 2, 2, -1, 1, 0, -1, -1, 0, 2, 1, 1, -1, 2, -1, 0, 0, 1, -1]

Original flow_B:
  [2, -2, -2, 4, 0, -1, 0, -1, 2, 0, 1, 2, 2, -2, 4, 0, -2, 0, -1, 0, 3, 3]

flow_B + Cm (corrected flow):
  [2, -2, 0, 0, 2, 1, -1, 0, 2, -1, 0, 2, 4, -1, 5, -1, 0, -1, -1, 0, 4, 2]

Verification:
  flow_corrected[16] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[3] = 0  (should be 0, Cm=-4, d=-4)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 46  (minimized by MIQP)
  ||Cm||_1  = 24
  ||flow_B||_2² = 86
  ||flow_corrected||_2² = 88

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    7.3          
    1     (0, 11)        -2       0          -2    7.0          
    2      (1, 2)        -2       2           0    4.8     -9.6s
    3      (1, 3)         4      -4           0    4.0    -16.0s ← BLOCKED
    4      (1, 5)         0       2           2    7.1    +14.2s
    5      (2, 3)        -1       2           1    7.8          
    6      (2, 8)         0      -1          -1    6.8     +6.8s
    7     (2, 11)        -1       1           0    5.2     -5.2s
    8      (3, 4)         2       0           2    7.1          
    9      (3, 6)         0      -1          -1    6.8     +6.8s
   10      (3, 8)         1      -1           0    5.5     -5.5s
   11      (4, 5)         2       0           2    6.5          
   12      (5, 6)         2       2           4    5.7    +11.4s
   13      (6, 7)        -2       1          -1    6.3     -6.3s
   14      (6, 9)         4       1           5    6.8     +6.8s
   15     (6, 10)         0      -1          -1    4.4     +4.4s
   16      (7, 8)        -2       2           0    7.7    -15.4s ← BLOCKED
   17     (7, 10)         0      -1          -1    8.0     +8.0s
   18      (8, 9)        -1       0          -1    6.7          
   19     (8, 11)         0       0           0    7.2          
   20     (9, 10)         3       1           4    4.1     +4.1s
   21    (10, 11)         3      -1           2    4.7     -4.7s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=2, out=2  OK
  Node 2: in=1, out=1  OK
  Node 3: in=2, out=2  OK
  Node 4: in=2, out=2  OK
  Node 5: in=4, out=4  OK
  Node 6: in=6, out=6  OK
  Node 7: in=1, out=1  OK
  Node 8: in=1, out=1  OK
  Node 9: in=5, out=5  OK
  Node 10: in=4, out=4  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 32 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 16

  Summary:
    Original path length:  34 edges
    Spliced path length:   32 edges
    Splices performed:     16
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           1         1  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           2         2  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           2         2  ✓
   12      (5, 6)           4         4  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)           5         5  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)          -1        -1  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           4         4  ✓
   21    (10, 11)           2         2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 23
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3] → J=220, T=200, cost=0 → queued

[Iter 1] cost=0, J=220, T=200, edges=34, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (1365 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2274 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2914 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1204 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1425 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1541 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1643 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1533 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1767 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (989 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (864 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2143 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3] → J=220, T=199, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 3] → J=217, T=199, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 1, 3] → J=212, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 1, 3] → J=212, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=211, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 1, 3] → J=209, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 1, 3] → J=209, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3] → J=220, T=199, cost=1 → queued

[Iter 2] cost=1, J=220, T=199, edges=35, frontier=7, MILP_calls=9
  V_MIN=[3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 3, 4, 5, 6, 7, 9] → expanding 8 children
    V_MIN=[4, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3] → J=218, T=199, cost=2 → queued
    V_MIN=[3, 4, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3] → J=218, T=199, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 3] → J=217, T=199, cost=2 → queued
    V_MIN=[3, 3, 2, 2, 3, 2, 2, 2, 2, 2, 1, 3] → J=210, T=198, cost=2 → queued
    V_MIN=[3, 3, 2, 2, 2, 3, 2, 2, 2, 2, 1, 3] → J=210, T=200, cost=2 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=209, T=200, cost=2 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 2, 3, 2, 2, 1, 3] → J=209, T=200, cost=2 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 2, 2, 2, 3, 1, 3] → J=209, T=200, cost=2 → queued

[Iter 3] cost=1, J=220, T=199, edges=35, frontier=14, MILP_calls=17
  V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [1, 3, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3] → J=218, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3] → J=217, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3] → J=210, T=198, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3] → J=210, T=198, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3] → J=211, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3] → J=208, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3] → J=209, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3] → J=212, T=200, cost=2 → queued

[Iter 4] cost=1, J=217, T=199, edges=36, frontier=21, MILP_calls=25
  V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [4, 5, 6, 7, 8, 9] → expanding 6 children
    V_MIN=[2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 1, 3] → J=212, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 2, 2, 2, 2, 1, 3] → J=212, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 2, 2, 2, 1, 3] → J=211, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 1, 3] → J=207, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 3, 2, 1, 3] → J=217, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 3, 1, 3] → J=209, T=200, cost=2 → queued

[Iter 5] cost=1, J=212, T=200, edges=34, frontier=26, MILP_calls=31
  V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (456 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (644 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (445 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (385 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (486 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (601 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (274 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (262 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (163 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (136 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (200 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 6, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[2, 3, 2, 2, 4, 2, 2, 2, 2, 2, 1, 3] → J=198, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 2, 2, 2, 1, 3] → J=201, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 1, 3] → J=201, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 3, 2, 1, 3] → J=211, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 2, 3, 1, 3] → J=201, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 1, 4] → J=210, T=200, cost=2 → queued

[Iter 6] cost=1, J=212, T=200, edges=34, frontier=31, MILP_calls=37
  V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (456 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (644 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (445 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (385 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (486 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (601 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (274 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (262 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (163 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (136 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (200 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 5, 6, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[2, 3, 2, 2, 2, 4, 2, 2, 2, 2, 1, 3] → J=203, T=198, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 2, 2, 2, 1, 3] → J=208, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 3, 2, 2, 1, 3] → J=206, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 3, 2, 1, 3] → J=211, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 2, 3, 1, 3] → J=205, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 1, 4] → J=210, T=197, cost=2 → queued

[Iter 7] cost=1, J=211, T=200, edges=36, frontier=36, MILP_calls=43
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (2299 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (639 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1880 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (4326 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3160 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2553 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1679 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2916 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1211 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2876 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1460 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3209 backtracks in 0.01s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 4, 5, 6, 7, 9, 11] → expanding 8 children
    V_MIN=[2, 4, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=209, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 2, 2, 2, 1, 3] → J=201, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 1, 3] → J=209, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3] → J=209, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 1, 4] → J=210, T=200, cost=2 → queued

[Iter 8] cost=1, J=209, T=200, edges=36, frontier=40, MILP_calls=48
  V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 1, 3]
  [backtrack] EXHAUSTED search space (392 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (243 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (613 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (582 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (270 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (256 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (266 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (267 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (415 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (186 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (442 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (132 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [1, 4, 5, 6, 7, 8, 9] → expanding 7 children
    V_MIN=[2, 4, 2, 2, 2, 2, 2, 2, 2, 3, 1, 3] → J=208, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 3, 1, 3] → J=204, T=198, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 3, 3, 1, 3] → J=209, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 4, 1, 3] → J=197, T=200, cost=2 → queued

[Iter 9] cost=1, J=209, T=200, edges=34, frontier=43, MILP_calls=52
  V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (393 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (644 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (583 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (462 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (389 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (227 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (606 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (178 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (296 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (430 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (434 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [1, 3, 4, 5, 7, 9, 10] → expanding 7 children
    V_MIN=[2, 4, 2, 2, 2, 2, 2, 3, 2, 2, 1, 3] → J=208, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 4, 2, 2, 1, 3] → J=198, T=200, cost=2 → queued

[Iter 10] cost=2, J=218, T=199, edges=35, frontier=44, MILP_calls=54
  V_MIN=[4, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7, 9] → expanding 7 children
    V_MIN=[5, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3] → J=211, T=199, cost=3 → queued
    V_MIN=[4, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 3] → J=217, T=199, cost=3 → queued
    V_MIN=[4, 3, 2, 2, 3, 2, 2, 2, 2, 2, 1, 3] → J=208, T=199, cost=3 → queued
    V_MIN=[4, 3, 2, 2, 2, 3, 2, 2, 2, 2, 1, 3] → J=208, T=198, cost=3 → queued
    V_MIN=[4, 3, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=208, T=200, cost=3 → queued
    V_MIN=[4, 3, 2, 2, 2, 2, 2, 3, 2, 2, 1, 3] → J=205, T=200, cost=3 → queued
    V_MIN=[4, 3, 2, 2, 2, 2, 2, 2, 2, 3, 1, 3] → J=205, T=199, cost=3 → queued

[Iter 11] cost=2, J=218, T=199, edges=35, frontier=50, MILP_calls=61
  V_MIN=[3, 4, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [1, 3, 4, 5, 6, 7, 9] → expanding 7 children
    V_MIN=[3, 5, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3] → J=215, T=200, cost=3 → queued
    V_MIN=[3, 4, 2, 3, 2, 2, 2, 2, 2, 2, 1, 3] → J=217, T=199, cost=3 → queued
    V_MIN=[3, 4, 2, 2, 3, 2, 2, 2, 2, 2, 1, 3] → J=208, T=199, cost=3 → queued
    V_MIN=[3, 4, 2, 2, 2, 3, 2, 2, 2, 2, 1, 3] → J=208, T=198, cost=3 → queued
    V_MIN=[3, 4, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=209, T=200, cost=3 → queued
    V_MIN=[3, 4, 2, 2, 2, 2, 2, 3, 2, 2, 1, 3] → J=206, T=198, cost=3 → queued
    V_MIN=[3, 4, 2, 2, 2, 2, 2, 2, 2, 3, 1, 3] → J=206, T=199, cost=3 → queued

[Iter 12] cost=2, J=218, T=199, edges=35, frontier=56, MILP_calls=68
  V_MIN=[2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [1, 3, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3] → J=215, T=200, cost=3 → queued
    V_MIN=[2, 4, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3] → J=217, T=199, cost=3 → queued
    V_MIN=[2, 4, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3] → J=208, T=199, cost=3 → queued
    V_MIN=[2, 4, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3] → J=210, T=198, cost=3 → queued
    V_MIN=[2, 4, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3] → J=209, T=199, cost=3 → queued
    V_MIN=[2, 4, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3] → J=207, T=200, cost=3 → queued
    V_MIN=[2, 4, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3] → J=207, T=200, cost=3 → queued
    V_MIN=[2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3] → J=212, T=200, cost=3 → queued

[Iter 13] cost=2, J=217, T=199, edges=36, frontier=63, MILP_calls=76
  V_MIN=[3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 1, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [4, 5, 6, 7, 8, 9] → expanding 6 children
    V_MIN=[3, 3, 2, 3, 3, 2, 2, 2, 2, 2, 1, 3] → J=210, T=198, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 3, 2, 2, 2, 2, 1, 3] → J=210, T=198, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 2, 3, 2, 2, 2, 1, 3] → J=209, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 2, 2, 3, 2, 2, 1, 3] → J=207, T=199, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 2, 2, 2, 3, 2, 1, 3] → J=216, T=199, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 2, 2, 2, 2, 3, 1, 3] → J=209, T=200, cost=3 → queued

[Iter 14] cost=2, J=217, T=199, edges=36, frontier=68, MILP_calls=82
  V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [4, 5, 6, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3] → J=210, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 2, 2, 2, 2, 2, 3] → J=210, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 3] → J=211, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3] → J=207, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 3, 2, 2, 3] → J=217, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 3, 2, 3] → J=209, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 3, 3] → J=212, T=200, cost=3 → queued

[Iter 15] cost=2, J=217, T=199, edges=35, frontier=74, MILP_calls=89
  V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 3, 2, 1, 3]
  [backtrack] Found solution with 610 backtracks in 0.00s
  [backtrack] Found solution with 1347 backtracks in 0.00s
  [backtrack] Found solution with 929 backtracks in 0.00s
  [backtrack] Found solution with 365 backtracks in 0.00s
  [backtrack] Found solution with 558 backtracks in 0.00s
  [backtrack] Found solution with 1099 backtracks in 0.00s
  [backtrack] Found solution with 530 backtracks in 0.00s
  [backtrack] Found solution with 616 backtracks in 0.00s
  [backtrack] Found solution with 730 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (934 backtracks in 0.00s)
  [backtrack] Found solution with 555 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=130.9s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10, 11] → expanding 8 children
    V_MIN=[2, 3, 2, 3, 3, 2, 2, 2, 3, 2, 1, 3] → J=211, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 1, 3] → J=211, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 2, 3, 2, 1, 3] → J=211, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 3, 3, 2, 1, 3] → J=207, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 3, 3, 1, 3] → J=207, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 3, 2, 1, 4] → J=217, T=197, cost=3 → queued

[Iter 16] cost=2, J=212, T=200, edges=36, frontier=79, MILP_calls=95
  V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3]
  [backtrack] EXHAUSTED search space (2618 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1507 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2719 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (4892 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2649 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2369 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1528 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2617 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1585 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2894 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1254 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3991 backtracks in 0.01s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3] → J=210, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 3, 3] → J=203, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 3, 3] → J=204, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 3, 3] → J=207, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 3, 3] → J=208, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3] → J=209, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 4, 3] → J=205, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4] → J=210, T=199, cost=3 → queued

[Iter 17] cost=2, J=212, T=200, edges=34, frontier=86, MILP_calls=103
  V_MIN=[2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (465 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (406 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (700 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (754 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (527 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (519 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (263 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (240 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (138 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (625 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 6, 7, 8, 9, 10, 11] → expanding 9 children
    V_MIN=[2, 3, 2, 4, 3, 2, 2, 2, 2, 2, 1, 3] → J=209, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 4, 2, 2, 2, 2, 2, 1, 3] → J=198, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 3, 2, 3, 2, 2, 2, 1, 3] → J=201, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 3, 2, 2, 3, 2, 2, 1, 3] → J=201, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 3, 2, 2, 2, 2, 3, 1, 3] → J=201, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 1, 4] → J=210, T=198, cost=3 → queued

[Iter 18] cost=2, J=212, T=200, edges=34, frontier=91, MILP_calls=109
  V_MIN=[2, 3, 2, 3, 2, 3, 2, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (456 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (644 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (445 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (385 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (486 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (601 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (274 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (262 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (163 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (136 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (200 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 5, 6, 7, 8, 9, 10, 11] → expanding 9 children
    V_MIN=[2, 3, 2, 4, 2, 3, 2, 2, 2, 2, 1, 3] → J=209, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 4, 2, 2, 2, 2, 1, 3] → J=203, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 2, 2, 2, 1, 3] → J=207, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 2, 3, 2, 2, 1, 3] → J=206, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 1, 3] → J=203, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 2, 2, 2, 2, 1, 4] → J=210, T=198, cost=3 → queued

[Iter 19] cost=2, J=211, T=200, edges=36, frontier=96, MILP_calls=115
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3]
  [backtrack] EXHAUSTED search space (2299 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (639 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1880 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (4326 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3160 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2553 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1679 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2916 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1211 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2876 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1460 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3209 backtracks in 0.01s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 4, 5, 6, 7, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3] → J=209, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 2, 2, 2, 2, 3] → J=201, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 2, 2, 2, 2, 3] → J=208, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 2, 2, 2, 2, 3] → J=201, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 3] → J=207, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 3, 2, 3] → J=207, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 4] → J=210, T=200, cost=3 → queued

[Iter 20] cost=2, J=211, T=200, edges=36, frontier=102, MILP_calls=122
  V_MIN=[2, 3, 2, 3, 2, 2, 3, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (2299 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (639 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1880 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (4326 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3160 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2553 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1679 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2916 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1211 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2876 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1460 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3209 backtracks in 0.01s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 4, 5, 6, 7, 9, 11] → expanding 8 children
    V_MIN=[2, 4, 2, 3, 2, 2, 3, 2, 2, 2, 1, 3] → J=208, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 4, 2, 2, 2, 1, 3] → J=201, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 3, 2, 2, 1, 3] → J=207, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 2, 2, 3, 1, 3] → J=207, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 2, 2, 2, 1, 4] → J=210, T=200, cost=3 → queued

[Iter 21] cost=2, J=211, T=200, edges=34, frontier=106, MILP_calls=127
  V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 3, 2, 1, 3]
  [backtrack] EXHAUSTED search space (713 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1095 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (680 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (713 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (914 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (999 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (421 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (411 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (239 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (268 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (177 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (266 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 6, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 3, 2, 2, 2, 3, 2, 1, 3] → J=206, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 2, 2, 3, 2, 1, 3] → J=198, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 2, 3, 2, 1, 3] → J=201, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 3, 3, 2, 1, 3] → J=198, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 4, 2, 1, 3] → J=209, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 3, 3, 1, 3] → J=200, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 3] → J=209, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 3, 2, 1, 4] → J=208, T=197, cost=3 → queued

[Iter 22] cost=2, J=211, T=200, edges=34, frontier=113, MILP_calls=135
  V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 3, 2, 1, 3]
  [backtrack] EXHAUSTED search space (415 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (639 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (839 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (389 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1032 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1003 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (598 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (545 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (274 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (341 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (318 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (632 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 5, 6, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 3, 2, 2, 3, 2, 1, 3] → J=210, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 2, 2, 3, 2, 1, 3] → J=203, T=197, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 2, 3, 2, 1, 3] → J=208, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 3, 3, 2, 1, 3] → J=206, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 4, 2, 1, 3] → J=209, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 3, 3, 1, 3] → J=203, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 3, 2, 2, 3] → J=210, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 3, 2, 1, 4] → J=210, T=197, cost=3 → queued

[Iter 23] cost=2, J=210, T=198, edges=34, frontier=120, MILP_calls=143
  V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3]
  [backtrack] Found solution with 785 backtracks in 0.00s
  [backtrack] Found solution with 1036 backtracks in 0.00s
  [backtrack] Found solution with 1071 backtracks in 0.00s
  [backtrack] Found solution with 126 backtracks in 0.00s
  [backtrack] Found solution with 141 backtracks in 0.00s
  [backtrack] Found solution with 969 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1066 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1340 backtracks in 0.00s)
  [backtrack] Found solution with 543 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (978 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1210 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (469 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=177.1s)
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3] → J=210, T=197, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 2, 2, 2, 2, 2, 3] → J=210, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 2, 2, 2, 2, 2, 3] → J=203, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 3, 2, 2, 2, 3] → J=206, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 2, 3, 2, 3] → J=202, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 4] → J=210, T=199, cost=3 → queued

[Iter 24] cost=2, J=210, T=200, edges=34, frontier=125, MILP_calls=149
  V_MIN=[3, 3, 2, 2, 2, 3, 2, 2, 2, 2, 1, 3]
  [backtrack] Found solution with 6 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.9s
  *** SOLUTION FOUND! J=210, T_tour=199.9s ***

============================================================
Search done: 24 iters, 149 MILP calls, 149 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, 0, 0, -3, 2, 3, -5, 2, 0, 0, 2, -1, -2, 1, 0, -2, 0, 1, 0, 2, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, 0, 0, -3, 2, 3, -5, 2, 0, 0, 2, -1, -2, 1, 0, -2, 0, 1, 0, 2, 2]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 5), np.int64(-3)), ((2, 3), np.int64(2)), ((2, 8), np.int64(3)), ((2, 11), np.int64(-5)), ((3, 4), np.int64(2)), ((4, 5), np.int64(2)), ((5, 6), np.int64(-1)), ((6, 7), np.int64(-2)), ((6, 9), np.int64(1)), ((7, 8), np.int64(-2)), ((8, 9), np.int64(1)), ((9, 10), np.int64(2)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=5, edge=(2, 3), flow_B=2  →  need Cm[5]=-2
Blocked edge 2: idx=20, edge=(9, 10), flow_B=2  →  need Cm[20]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=21   ||Cm||_1=15

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, 1, 0, -2, -1, 0, 0, 0, 1, 0, 0]

Cm = C_oriented @ beta*:
  [0, 0, -1, 1, 0, -2, 1, 0, 0, 0, -1, 0, 0, 1, -2, 1, 1, 0, 0, 1, -2, -1]

Original flow_B:
  [-3, 3, 0, 0, -3, 2, 3, -5, 2, 0, 0, 2, -1, -2, 1, 0, -2, 0, 1, 0, 2, 2]

flow_B + Cm (corrected flow):
  [-3, 3, -1, 1, -3, 0, 4, -5, 2, 0, -1, 2, -1, -1, -1, 1, -1, 0, 1, 1, 0, 1]

Verification:
  flow_corrected[5] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[20] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 21  (minimized by MIQP)
  ||Cm||_1  = 15
  ||flow_B||_2² = 92
  ||flow_corrected||_2² = 87

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       0          -3    7.5          
    1     (0, 11)         3       0           3    5.2          
    2      (1, 2)         0      -1          -1    6.4     +6.4s
    3      (1, 3)         0       1           1    7.9     +7.9s
    4      (1, 5)        -3       0          -3    7.4          
    5      (2, 3)         2      -2           0    4.3     -8.6s ← BLOCKED
    6      (2, 8)         3       1           4    5.2     +5.2s
    7     (2, 11)        -5       0          -5    5.2          
    8      (3, 4)         2       0           2    7.3          
    9      (3, 6)         0       0           0    6.5          
   10      (3, 8)         0      -1          -1    4.4     +4.4s
   11      (4, 5)         2       0           2    4.0          
   12      (5, 6)        -1       0          -1    7.8          
   13      (6, 7)        -2       1          -1    4.6     -4.6s
   14      (6, 9)         1      -2          -1    5.7          
   15     (6, 10)         0       1           1    5.4     +5.4s
   16      (7, 8)        -2       1          -1    7.5     -7.5s
   17     (7, 10)         0       0           0    5.7          
   18      (8, 9)         1       0           1    7.3          
   19     (8, 11)         0       1           1    6.9     +6.9s
   20     (9, 10)         2      -2           0    4.5     -9.0s ← BLOCKED
   21    (10, 11)         2      -1           1    6.4     -6.4s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=4, out=4  OK
  Node 2: in=5, out=5  OK
  Node 3: in=2, out=2  OK
  Node 4: in=2, out=2  OK
  Node 5: in=3, out=3  OK
  Node 6: in=2, out=2  OK
  Node 7: in=1, out=1  OK
  Node 8: in=4, out=4  OK
  Node 9: in=1, out=1  OK
  Node 10: in=1, out=1  OK
  Node 11: in=5, out=5  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 33 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 15

  Summary:
    Original path length:  34 edges
    Spliced path length:   33 edges
    Splices performed:     15
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -3        -3  ✓
    1     (0, 11)           3         3  ✓
    2      (1, 2)          -1        -1  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)          -3        -3  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           4         4  ✓
    7     (2, 11)          -5        -5  ✓
    8      (3, 4)           2         2  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           2         2  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)          -1        -1  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)           1         1  ✓
   19     (8, 11)           1         1  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 24
================================================================================
✗ STATUS: FAILED EXCEPTION
Traceback (most recent call last):
  File "/Users/richardguo/Desktop/IROS_main/edge_block_batch_full.py", line 447, in <module>
    raise RuntimeError("Could not obtain a latency-feasible flow_B.")
RuntimeError: Could not obtain a latency-feasible flow_B.

================================================================================
TRIAL 25
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1] → J=178, T=199, cost=0 → queued

[Iter 1] cost=0, J=178, T=199, edges=35, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1]
  [backtrack] Found solution with 18 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.1s
  *** SOLUTION FOUND! J=178, T_tour=199.1s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, -2, 0, -1, 0, -2, 0, 2, -1, -1, 2, 1, -2, 4, -2, -1, -1, -4, 0, 0, -3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, -2, 0, -1, 0, -2, 0, 2, -1, -1, 2, 1, -2, 4, -2, -1, -1, -4, 0, 0, -3]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 2), np.int64(-2)), ((1, 5), np.int64(-1)), ((2, 8), np.int64(-2)), ((3, 4), np.int64(2)), ((3, 6), np.int64(-1)), ((3, 8), np.int64(-1)), ((4, 5), np.int64(2)), ((5, 6), np.int64(1)), ((6, 7), np.int64(-2)), ((6, 9), np.int64(4)), ((6, 10), np.int64(-2)), ((7, 8), np.int64(-1)), ((7, 10), np.int64(-1)), ((8, 9), np.int64(-4)), ((10, 11), np.int64(-3))]

Blocked edge 1: idx=15, edge=(6, 10), flow_B=-2  →  need Cm[15]=2
Blocked edge 2: idx=8, edge=(3, 4), flow_B=2  →  need Cm[8]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=26   ||Cm||_1=18

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, -1, 1, -1, 0, 0, 0, 0, 0, -2, 0]

Cm = C_oriented @ beta*:
  [0, 0, -1, -1, 2, -1, 1, -1, -2, 0, 0, -2, 0, -1, -1, 2, 0, -1, 0, 1, -1, 0]

Original flow_B:
  [-3, 3, -2, 0, -1, 0, -2, 0, 2, -1, -1, 2, 1, -2, 4, -2, -1, -1, -4, 0, 0, -3]

flow_B + Cm (corrected flow):
  [-3, 3, -3, -1, 1, -1, -1, -1, 0, -1, -1, 0, 1, -3, 3, 0, -1, -2, -4, 1, -1, -3]

Verification:
  flow_corrected[15] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[8] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 26  (minimized by MIQP)
  ||Cm||_1  = 18
  ||flow_B||_2² = 89
  ||flow_corrected||_2² = 85

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       0          -3    5.8          
    1     (0, 11)         3       0           3    6.3          
    2      (1, 2)        -2      -1          -3    4.6     +4.6s
    3      (1, 3)         0      -1          -1    6.1     +6.1s
    4      (1, 5)        -1       2           1    5.3          
    5      (2, 3)         0      -1          -1    6.8     +6.8s
    6      (2, 8)        -2       1          -1    5.5     -5.5s
    7     (2, 11)         0      -1          -1    7.3     +7.3s
    8      (3, 4)         2      -2           0    5.9    -11.8s ← BLOCKED
    9      (3, 6)        -1       0          -1    6.1          
   10      (3, 8)        -1       0          -1    5.5          
   11      (4, 5)         2      -2           0    8.0    -16.0s
   12      (5, 6)         1       0           1    6.1          
   13      (6, 7)        -2      -1          -3    6.2     +6.2s
   14      (6, 9)         4      -1           3    4.1     -4.1s
   15     (6, 10)        -2       2           0    6.9    -13.8s ← BLOCKED
   16      (7, 8)        -1       0          -1    5.7          
   17     (7, 10)        -1      -1          -2    5.7     +5.7s
   18      (8, 9)        -4       0          -4    5.1          
   19     (8, 11)         0       1           1    7.6     +7.6s
   20     (9, 10)         0      -1          -1    6.7     +6.7s
   21    (10, 11)        -3       0          -3    5.8          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=4, out=4  OK
  Node 2: in=3, out=3  OK
  Node 3: in=2, out=2  OK
  Node 5: in=1, out=1  OK
  Node 6: in=4, out=4  OK
  Node 7: in=3, out=3  OK
  Node 8: in=4, out=4  OK
  Node 9: in=4, out=4  OK
  Node 10: in=3, out=3  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 26

  Summary:
    Original path length:  35 edges
    Spliced path length:   35 edges
    Splices performed:     26
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -3        -3  ✓
    1     (0, 11)           3         3  ✓
    2      (1, 2)          -3        -3  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)          -1        -1  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)          -3        -3  ✓
   14      (6, 9)           3         3  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)          -4        -4  ✓
   19     (8, 11)           1         1  ✓
   20     (9, 10)          -1        -1  ✓
   21    (10, 11)          -3        -3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 26
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2] → J=187, T=200, cost=0 → queued

[Iter 1] cost=0, J=187, T=200, edges=32, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (1084 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (831 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (255 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (691 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (862 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1028 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (302 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (569 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (288 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (624 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (392 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (767 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 6, 7, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2] → J=181, T=197, cost=1 → queued
    V_MIN=[2, 2, 4, 3, 3, 2, 2, 2, 2, 2, 1, 2] → J=187, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 4, 2, 2, 2, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 3, 3, 2, 3, 2, 2, 2, 1, 2] → J=185, T=198, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 3, 2, 2, 1, 2] → J=185, T=197, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 3, 1, 2] → J=182, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2] → J=182, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 3] → J=186, T=199, cost=1 → queued

[Iter 2] cost=1, J=187, T=199, edges=32, frontier=6, MILP_calls=9
  V_MIN=[2, 2, 4, 3, 3, 2, 2, 2, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (755 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (238 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (274 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (622 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (636 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (798 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (329 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (377 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (153 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (198 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (207 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (565 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 6, 7, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 2, 4, 3, 3, 2, 2, 2, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 5, 3, 3, 2, 2, 2, 2, 2, 1, 2] → J=181, T=200, cost=2 → queued
    V_MIN=[2, 2, 4, 4, 3, 2, 2, 2, 2, 2, 1, 2] → J=182, T=200, cost=2 → queued
    V_MIN=[2, 2, 4, 3, 4, 2, 2, 2, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 4, 3, 3, 2, 3, 2, 2, 2, 1, 2] → J=185, T=199, cost=2 → queued
    V_MIN=[2, 2, 4, 3, 3, 2, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 4, 3, 3, 2, 2, 2, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 4, 3, 3, 2, 2, 2, 2, 2, 2, 2] → J=182, T=200, cost=2 → queued
    V_MIN=[2, 2, 4, 3, 3, 2, 2, 2, 2, 2, 1, 3] → J=185, T=199, cost=2 → queued

[Iter 3] cost=1, J=186, T=199, edges=32, frontier=10, MILP_calls=18
  V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (64 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (73 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (51 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (51 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (64 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (74 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (73 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (46 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (35 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (32 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (47 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 6, 7, 8, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 3] → J=181, T=198, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 4, 2, 2, 2, 2, 2, 1, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 3, 3, 2, 3, 2, 2, 2, 1, 3] → J=183, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 3, 2, 2, 1, 3] → J=179, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 3, 2, 1, 3] → J=185, T=198, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 3, 1, 3] → J=176, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3] → J=182, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 4] → J=174, T=200, cost=2 → queued

[Iter 4] cost=1, J=185, T=198, edges=32, frontier=16, MILP_calls=26
  V_MIN=[2, 2, 3, 3, 3, 2, 3, 2, 2, 2, 1, 2]
  [backtrack] Found solution with 4 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.2s
  *** SOLUTION FOUND! J=185, T_tour=198.2s ***

============================================================
Search done: 4 iters, 26 MILP calls, 26 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 1, -4, 1, 0, 3, -2, -3, -1, 0, -3, -2, -2, -1, 0, -1, -1, 2, 0, 1, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 1, -4, 1, 0, 3, -2, -3, -1, 0, -3, -2, -2, -1, 0, -1, -1, 2, 0, 1, 0]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(1)), ((1, 3), np.int64(-4)), ((1, 5), np.int64(1)), ((2, 8), np.int64(3)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(-3)), ((3, 6), np.int64(-1)), ((4, 5), np.int64(-3)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(-2)), ((6, 9), np.int64(-1)), ((7, 8), np.int64(-1)), ((7, 10), np.int64(-1)), ((8, 9), np.int64(2)), ((9, 10), np.int64(1))]

Blocked edge 1: idx=6, edge=(2, 8), flow_B=3  →  need Cm[6]=-3
Blocked edge 2: idx=12, edge=(5, 6), flow_B=-2  →  need Cm[12]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=27   ||Cm||_1=17

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, -1, -1, 0, 2, 2, 0, 1, -1, -1, 1]

Cm = C_oriented @ beta*:
  [0, 0, -1, 0, 1, 1, -3, 1, 1, -1, 1, 1, 2, 0, 0, 1, 0, 0, 0, -2, 0, 1]

Original flow_B:
  [-2, 2, 1, -4, 1, 0, 3, -2, -3, -1, 0, -3, -2, -2, -1, 0, -1, -1, 2, 0, 1, 0]

flow_B + Cm (corrected flow):
  [-2, 2, 0, -4, 2, 1, 0, -1, -2, -2, 1, -2, 0, -2, -1, 1, -1, -1, 2, -2, 1, 1]

Verification:
  flow_corrected[6] = 0  (should be 0, Cm=-3, d=-3)
  flow_corrected[12] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 27  (minimized by MIQP)
  ||Cm||_1  = 17
  ||flow_B||_2² = 74
  ||flow_corrected||_2² = 61

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    5.1          
    1     (0, 11)         2       0           2    7.0          
    2      (1, 2)         1      -1           0    5.1     -5.1s
    3      (1, 3)        -4       0          -4    5.2          
    4      (1, 5)         1       1           2    7.8     +7.8s
    5      (2, 3)         0       1           1    7.7     +7.7s
    6      (2, 8)         3      -3           0    6.3    -18.9s ← BLOCKED
    7     (2, 11)        -2       1          -1    5.9     -5.9s
    8      (3, 4)        -3       1          -2    6.6     -6.6s
    9      (3, 6)        -1      -1          -2    6.1     +6.1s
   10      (3, 8)         0       1           1    8.0     +8.0s
   11      (4, 5)        -3       1          -2    4.6     -4.6s
   12      (5, 6)        -2       2           0    7.9    -15.8s ← BLOCKED
   13      (6, 7)        -2       0          -2    6.5          
   14      (6, 9)        -1       0          -1    6.9          
   15     (6, 10)         0       1           1    5.2     +5.2s
   16      (7, 8)        -1       0          -1    6.4          
   17     (7, 10)        -1       0          -1    7.0          
   18      (8, 9)         2       0           2    6.6          
   19     (8, 11)         0      -2          -2    7.7    +15.4s
   20     (9, 10)         1       0           1    7.6          
   21    (10, 11)         0       1           1    6.6     +6.6s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=4, out=4  OK
  Node 2: in=1, out=1  OK
  Node 3: in=5, out=5  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=3, out=3  OK
  Node 7: in=2, out=2  OK
  Node 8: in=3, out=3  OK
  Node 9: in=2, out=2  OK
  Node 10: in=2, out=2  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 31 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 18

  Summary:
    Original path length:  32 edges
    Spliced path length:   31 edges
    Splices performed:     18
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)          -4        -4  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           1         1  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)          -1        -1  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)           1         1  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)          -2        -2  ✓
   14      (6, 9)          -1        -1  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)           2         2  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 27
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 2, 2, 3, 3] → J=296, T=200, cost=0 → queued

[Iter 1] cost=0, J=296, T=200, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 2, 2, 3, 3]
  [backtrack] Found solution with 141 backtracks in 0.00s
  [backtrack] Found solution with 674 backtracks in 0.00s
  [backtrack] Found solution with 385 backtracks in 0.00s
  [backtrack] Found solution with 4 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 28 backtracks in 0.00s
  [backtrack] Found solution with 28 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=7, T_tour=199.6s
  DFS: latency violated (1 nodes, worst_gap=143.6s)
  Boundary nodes: [0, 2, 3, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 3, 3] → J=283, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 2, 3, 3, 1, 2, 2, 3, 3] → J=296, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 4, 2, 3, 3, 1, 2, 2, 3, 3] → J=295, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 2, 2, 2, 3, 3] → J=290, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 3, 2, 3, 3] → J=293, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3, 3] → J=292, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 2, 2, 4, 3] → J=288, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 2, 2, 3, 4] → J=296, T=199, cost=1 → queued

[Iter 2] cost=1, J=296, T=199, edges=37, frontier=7, MILP_calls=9
  V_MIN=[2, 2, 3, 3, 2, 3, 3, 1, 2, 2, 3, 3]
  [backtrack] Found solution with 61 backtracks in 0.00s
  [backtrack] Found solution with 31 backtracks in 0.00s
  [backtrack] Found solution with 63 backtracks in 0.00s
  [backtrack] Found solution with 449 backtracks in 0.00s
  [backtrack] Found solution with 234 backtracks in 0.00s
  [backtrack] Found solution with 62 backtracks in 0.00s
  [backtrack] Found solution with 69 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (2174 backtracks in 0.00s)
  [backtrack] Found solution with 359 backtracks in 0.00s
  [backtrack] Found solution with 389 backtracks in 0.00s
  [backtrack] Found solution with 266 backtracks in 0.00s
  [backtrack] Found solution with 62 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=152.9s)
  Boundary nodes: [0, 3, 4, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[3, 2, 3, 3, 2, 3, 3, 1, 2, 2, 3, 3] → J=282, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 4, 2, 3, 3, 1, 2, 2, 3, 3] → J=295, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 3, 3, 1, 2, 2, 3, 3] → J=294, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 3, 3, 2, 2, 2, 3, 3] → J=290, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 3, 3, 1, 3, 2, 3, 3] → J=293, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 3, 3, 1, 2, 3, 3, 3] → J=292, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 3, 3, 1, 2, 2, 4, 3] → J=287, T=199, cost=2 → queued

[Iter 3] cost=1, J=296, T=199, edges=37, frontier=13, MILP_calls=16
  V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 2, 2, 3, 4]
  [backtrack] Found solution with 3 backtracks in 0.00s
  [backtrack] Found solution with 66 backtracks in 0.00s
  [backtrack] Found solution with 62 backtracks in 0.00s
  [backtrack] Found solution with 676 backtracks in 0.00s
  [backtrack] Found solution with 615 backtracks in 0.00s
  [backtrack] Found solution with 193 backtracks in 0.00s
  [backtrack] Found solution with 169 backtracks in 0.00s
  [backtrack] Found solution with 1124 backtracks in 0.00s
  [backtrack] Found solution with 430 backtracks in 0.00s
  [backtrack] Found solution with 609 backtracks in 0.00s
  [backtrack] Found solution with 412 backtracks in 0.00s
  [backtrack] Found solution with 63 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=123.8s)
  Boundary nodes: [0, 3, 4, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 3, 4] → J=278, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 4, 2, 3, 3, 1, 2, 2, 3, 4] → J=295, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 3, 3, 1, 2, 2, 3, 4] → J=292, T=197, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 2, 2, 2, 3, 4] → J=286, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 3, 2, 3, 4] → J=293, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3, 4] → J=292, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 2, 2, 4, 4] → J=285, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 2, 2, 3, 5] → J=293, T=200, cost=2 → queued

[Iter 4] cost=1, J=295, T=200, edges=37, frontier=20, MILP_calls=24
  V_MIN=[2, 2, 2, 4, 2, 3, 3, 1, 2, 2, 3, 3]
  [backtrack] Found solution with 12 backtracks in 0.00s
  [backtrack] Found solution with 48 backtracks in 0.00s
  [backtrack] Found solution with 79 backtracks in 0.00s
  [backtrack] Found solution with 140 backtracks in 0.00s
  [backtrack] Found solution with 631 backtracks in 0.00s
  [backtrack] Found solution with 624 backtracks in 0.00s
  [backtrack] Found solution with 129 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1923 backtracks in 0.00s)
  [backtrack] Found solution with 1091 backtracks in 0.00s
  [backtrack] Found solution with 444 backtracks in 0.00s
  [backtrack] Found solution with 115 backtracks in 0.00s
  [backtrack] Found solution with 79 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=124.5s)
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[3, 2, 2, 4, 2, 3, 3, 1, 2, 2, 3, 3] → J=280, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 5, 2, 3, 3, 1, 2, 2, 3, 3] → J=293, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 4, 3, 3, 3, 1, 2, 2, 3, 3] → J=294, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 4, 2, 4, 3, 1, 2, 2, 3, 3] → J=294, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 4, 2, 3, 3, 2, 2, 2, 3, 3] → J=288, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 4, 2, 3, 3, 1, 3, 2, 3, 3] → J=292, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 4, 2, 3, 3, 1, 2, 3, 3, 3] → J=290, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 4, 2, 3, 3, 1, 2, 2, 4, 3] → J=286, T=200, cost=2 → queued

[Iter 5] cost=1, J=293, T=200, edges=37, frontier=27, MILP_calls=32
  V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 3, 2, 3, 3]
  [backtrack] Found solution with 307 backtracks in 0.00s
  [backtrack] Found solution with 71 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=199.9s
  DFS: latency violated (1 nodes, worst_gap=109.4s)
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[3, 2, 2, 3, 2, 3, 3, 1, 3, 2, 3, 3] → J=282, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 3, 3, 1, 3, 2, 3, 3] → J=292, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 4, 3, 1, 3, 2, 3, 3] → J=292, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 2, 3, 2, 3, 3] → J=288, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 4, 2, 3, 3] → J=289, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 3, 3, 3, 3] → J=292, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 3, 2, 4, 3] → J=285, T=200, cost=2 → queued

[Iter 6] cost=1, J=292, T=199, edges=37, frontier=33, MILP_calls=39
  V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3, 3]
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 87 backtracks in 0.00s
  [backtrack] Found solution with 309 backtracks in 0.00s
    ✓ Latency-feasible! source=2, T_tour=198.9s
  DFS: latency violated (1 nodes, worst_gap=95.7s)
  Boundary nodes: [0, 3, 4, 5, 7, 9, 10] → expanding 7 children
    V_MIN=[3, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3, 3] → J=282, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 3, 3, 1, 2, 3, 3, 3] → J=292, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 4, 3, 1, 2, 3, 3, 3] → J=292, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 2, 2, 3, 3, 3] → J=290, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 2, 4, 3, 3] → J=291, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 1, 2, 3, 4, 3] → J=287, T=199, cost=2 → queued

[Iter 7] cost=1, J=290, T=200, edges=37, frontier=38, MILP_calls=45
  V_MIN=[2, 2, 2, 3, 2, 3, 3, 2, 2, 2, 3, 3]
  [backtrack] Found solution with 1040 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.7s
  *** SOLUTION FOUND! J=290, T_tour=199.7s ***

============================================================
Search done: 7 iters, 45 MILP calls, 45 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 3, 1, -2, 0, 0, 3, -2, 3, 0, -2, -4, 0, -3, 2, 2, -2, 2, 0, -1, -1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 3, 1, -2, 0, 0, 3, -2, 3, 0, -2, -4, 0, -3, 2, 2, -2, 2, 0, -1, -1]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(3)), ((1, 3), np.int64(1)), ((1, 5), np.int64(-2)), ((2, 11), np.int64(3)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(3)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-4)), ((6, 9), np.int64(-3)), ((6, 10), np.int64(2)), ((7, 8), np.int64(2)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(2)), ((9, 10), np.int64(-1)), ((10, 11), np.int64(-1))]

Blocked edge 1: idx=2, edge=(1, 2), flow_B=3  →  need Cm[2]=-3
Blocked edge 2: idx=11, edge=(4, 5), flow_B=-2  →  need Cm[11]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=38   ||Cm||_1=20

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-2, 0, 0, 0, 0, 1, -1, 1, 0, 1, 1]

Cm = C_oriented @ beta*:
  [-1, 1, -3, 3, -1, -2, 0, -1, 2, 0, -1, 2, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0]

Original flow_B:
  [2, -2, 3, 1, -2, 0, 0, 3, -2, 3, 0, -2, -4, 0, -3, 2, 2, -2, 2, 0, -1, -1]

flow_B + Cm (corrected flow):
  [1, -1, 0, 4, -3, -2, 0, 2, 0, 3, -1, 0, -3, 1, -3, 2, 3, -2, 2, 0, -1, -1]

Verification:
  flow_corrected[2] = 0  (should be 0, Cm=-3, d=-3)
  flow_corrected[11] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 38  (minimized by MIQP)
  ||Cm||_1  = 20
  ||flow_B||_2² = 91
  ||flow_corrected||_2² = 87

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2      -1           1    7.0     -7.0s
    1     (0, 11)        -2       1          -1    7.5     -7.5s
    2      (1, 2)         3      -3           0    4.7    -14.1s ← BLOCKED
    3      (1, 3)         1       3           4    5.3    +15.9s
    4      (1, 5)        -2      -1          -3    5.5     +5.5s
    5      (2, 3)         0      -2          -2    7.2    +14.4s
    6      (2, 8)         0       0           0    4.6          
    7     (2, 11)         3      -1           2    4.7     -4.7s
    8      (3, 4)        -2       2           0    4.3     -8.6s
    9      (3, 6)         3       0           3    5.2          
   10      (3, 8)         0      -1          -1    7.1     +7.1s
   11      (4, 5)        -2       2           0    4.7     -9.4s ← BLOCKED
   12      (5, 6)        -4       1          -3    4.3     -4.3s
   13      (6, 7)         0       1           1    6.8     +6.8s
   14      (6, 9)        -3       0          -3    4.7          
   15     (6, 10)         2       0           2    6.4          
   16      (7, 8)         2       1           3    5.7     +5.7s
   17     (7, 10)        -2       0          -2    6.1          
   18      (8, 9)         2       0           2    4.9          
   19     (8, 11)         0       0           0    6.9          
   20     (9, 10)        -1       0          -1    7.4          
   21    (10, 11)        -1       0          -1    7.7          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=1, out=1  OK
  Node 1: in=4, out=4  OK
  Node 2: in=2, out=2  OK
  Node 3: in=5, out=5  OK
  Node 5: in=3, out=3  OK
  Node 6: in=6, out=6  OK
  Node 7: in=3, out=3  OK
  Node 8: in=3, out=3  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 17

  Summary:
    Original path length:  37 edges
    Spliced path length:   35 edges
    Splices performed:     17
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           1         1  ✓
    1     (0, 11)          -1        -1  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)           4         4  ✓
    4      (1, 5)          -3        -3  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           2         2  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)           3         3  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)          -3        -3  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)          -3        -3  ✓
   15     (6, 10)           2         2  ✓
   16      (7, 8)           3         3  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           2         2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)          -1        -1  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 28
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 3] → J=254, T=200, cost=0 → queued

[Iter 1] cost=0, J=254, T=200, edges=35, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (393 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (385 backtracks in 0.00s)
  [backtrack] Found solution with 161 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (265 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (307 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (377 backtracks in 0.00s)
  [backtrack] Found solution with 94 backtracks in 0.00s
  [backtrack] Found solution with 131 backtracks in 0.00s
  [backtrack] Found solution with 74 backtracks in 0.00s
  [backtrack] Found solution with 74 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 187 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=102.8s)
  Boundary nodes: [0, 1, 2, 3, 4, 5, 6, 7, 11] → expanding 9 children
    V_MIN=[3, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 3] → J=251, T=198, cost=1 → queued
    V_MIN=[2, 3, 1, 2, 2, 2, 2, 3, 3, 3, 2, 3] → J=251, T=198, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 3] → J=249, T=200, cost=1 → queued
    V_MIN=[2, 2, 1, 3, 2, 2, 2, 3, 3, 3, 2, 3] → J=250, T=199, cost=1 → queued
    V_MIN=[2, 2, 1, 2, 3, 2, 2, 3, 3, 3, 2, 3] → J=250, T=198, cost=1 → queued
    V_MIN=[2, 2, 1, 2, 2, 3, 2, 3, 3, 3, 2, 3] → J=251, T=198, cost=1 → queued
    V_MIN=[2, 2, 1, 2, 2, 2, 3, 3, 3, 3, 2, 3] → J=249, T=200, cost=1 → queued
    V_MIN=[2, 2, 1, 2, 2, 2, 2, 4, 3, 3, 2, 3] → J=250, T=199, cost=1 → queued
    V_MIN=[2, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 4] → J=247, T=200, cost=1 → queued

[Iter 2] cost=1, J=251, T=198, edges=35, frontier=8, MILP_calls=10
  V_MIN=[3, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (88 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (111 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (90 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (153 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (110 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (97 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 6, 7, 11] → expanding 7 children
    V_MIN=[4, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 3] → J=245, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 3] → J=249, T=200, cost=2 → queued
    V_MIN=[3, 2, 1, 3, 2, 2, 2, 3, 3, 3, 2, 3] → J=250, T=199, cost=2 → queued
    V_MIN=[3, 2, 1, 2, 3, 2, 2, 3, 3, 3, 2, 3] → J=250, T=198, cost=2 → queued
    V_MIN=[3, 2, 1, 2, 2, 2, 3, 3, 3, 3, 2, 3] → J=248, T=200, cost=2 → queued
    V_MIN=[3, 2, 1, 2, 2, 2, 2, 4, 3, 3, 2, 3] → J=250, T=199, cost=2 → queued
    V_MIN=[3, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 4] → J=247, T=199, cost=2 → queued

[Iter 3] cost=1, J=251, T=198, edges=35, frontier=14, MILP_calls=17
  V_MIN=[2, 3, 1, 2, 2, 2, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (88 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (111 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (90 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (153 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (110 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (97 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [1, 2, 3, 4, 6, 7, 11] → expanding 7 children
    V_MIN=[2, 4, 1, 2, 2, 2, 2, 3, 3, 3, 2, 3] → J=245, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 3, 3, 2, 3] → J=249, T=200, cost=2 → queued
    V_MIN=[2, 3, 1, 3, 2, 2, 2, 3, 3, 3, 2, 3] → J=250, T=199, cost=2 → queued
    V_MIN=[2, 3, 1, 2, 3, 2, 2, 3, 3, 3, 2, 3] → J=250, T=198, cost=2 → queued
    V_MIN=[2, 3, 1, 2, 2, 2, 3, 3, 3, 3, 2, 3] → J=248, T=200, cost=2 → queued
    V_MIN=[2, 3, 1, 2, 2, 2, 2, 4, 3, 3, 2, 3] → J=250, T=199, cost=2 → queued
    V_MIN=[2, 3, 1, 2, 2, 2, 2, 3, 3, 3, 2, 4] → J=247, T=199, cost=2 → queued

[Iter 4] cost=1, J=251, T=198, edges=35, frontier=20, MILP_calls=24
  V_MIN=[2, 2, 1, 2, 2, 3, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (156 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (185 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (101 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (48 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (107 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (151 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (123 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (168 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (154 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (154 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [2, 3, 4, 5, 6, 7, 11] → expanding 7 children
    V_MIN=[2, 2, 2, 2, 2, 3, 2, 3, 3, 3, 2, 3] → J=249, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3] → J=250, T=198, cost=2 → queued
    V_MIN=[2, 2, 1, 2, 3, 3, 2, 3, 3, 3, 2, 3] → J=250, T=198, cost=2 → queued
    V_MIN=[2, 2, 1, 2, 2, 4, 2, 3, 3, 3, 2, 3] → J=244, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 2, 2, 3, 3, 3, 3, 3, 2, 3] → J=247, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 2, 2, 3, 2, 4, 3, 3, 2, 3] → J=246, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 2, 2, 3, 2, 3, 3, 3, 2, 4] → J=247, T=200, cost=2 → queued

[Iter 5] cost=1, J=250, T=199, edges=35, frontier=26, MILP_calls=31
  V_MIN=[2, 2, 1, 3, 2, 2, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (244 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (132 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (93 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (138 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (191 backtracks in 0.00s)
  [backtrack] Found solution with 85 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (210 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (249 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (223 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (220 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=101.6s)
  Boundary nodes: [2, 3, 4, 5, 6, 7, 11] → expanding 7 children
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 3, 3, 3, 2, 3] → J=246, T=198, cost=2 → queued
    V_MIN=[2, 2, 1, 4, 2, 2, 2, 3, 3, 3, 2, 3] → J=244, T=199, cost=2 → queued
    V_MIN=[2, 2, 1, 3, 3, 2, 2, 3, 3, 3, 2, 3] → J=250, T=198, cost=2 → queued
    V_MIN=[2, 2, 1, 3, 2, 2, 3, 3, 3, 3, 2, 3] → J=247, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 3, 2, 2, 2, 4, 3, 3, 2, 3] → J=246, T=198, cost=2 → queued
    V_MIN=[2, 2, 1, 3, 2, 2, 2, 3, 3, 3, 2, 4] → J=247, T=200, cost=2 → queued

[Iter 6] cost=1, J=250, T=199, edges=36, frontier=31, MILP_calls=37
  V_MIN=[2, 2, 1, 2, 2, 2, 2, 4, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (191 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (165 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (95 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (145 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (149 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (122 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (142 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (142 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (170 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (41 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [2, 3, 4, 5, 6, 7, 11] → expanding 7 children
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 4, 3, 3, 2, 3] → J=248, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 2, 3, 2, 2, 4, 3, 3, 2, 3] → J=246, T=199, cost=2 → queued
    V_MIN=[2, 2, 1, 2, 2, 2, 3, 4, 3, 3, 2, 3] → J=249, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 2, 2, 2, 2, 5, 3, 3, 2, 3] → J=247, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 2, 2, 2, 2, 4, 3, 3, 2, 4] → J=247, T=199, cost=2 → queued

[Iter 7] cost=1, J=250, T=198, edges=37, frontier=35, MILP_calls=42
  V_MIN=[2, 2, 1, 2, 3, 2, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (44 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (46 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (97 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (36 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (45 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [2, 4, 6, 7, 8, 11] → expanding 6 children
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 3, 3, 3, 2, 3] → J=246, T=198, cost=2 → queued
    V_MIN=[2, 2, 1, 2, 4, 2, 2, 3, 3, 3, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 1, 2, 3, 2, 3, 3, 3, 3, 2, 3] → J=247, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 2, 3, 2, 2, 3, 4, 3, 2, 3] → J=247, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 2, 3, 2, 2, 3, 3, 3, 2, 4] → J=247, T=200, cost=2 → queued

[Iter 8] cost=1, J=249, T=200, edges=37, frontier=38, MILP_calls=47
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (655 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (652 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (340 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (386 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (386 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (600 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (277 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (561 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (452 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (386 backtracks in 0.00s)
  [backtrack] Found solution with 429 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (223 backtracks in 0.00s)
  DFS: latency violated (4 nodes, worst_gap=123.8s)
  Boundary nodes: [2, 3, 4, 6, 7, 11] → expanding 6 children
    V_MIN=[2, 2, 3, 2, 2, 2, 2, 3, 3, 3, 2, 3] → J=246, T=198, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 2, 3] → J=245, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 4] → J=246, T=200, cost=2 → queued

[Iter 9] cost=1, J=249, T=200, edges=36, frontier=40, MILP_calls=50
  V_MIN=[2, 2, 1, 2, 2, 2, 3, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (262 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (279 backtracks in 0.00s)
  [backtrack] Found solution with 143 backtracks in 0.00s
  [backtrack] Found solution with 268 backtracks in 0.00s
  [backtrack] Found solution with 237 backtracks in 0.00s
  [backtrack] Found solution with 222 backtracks in 0.00s
  [backtrack] Found solution with 228 backtracks in 0.00s
  [backtrack] Found solution with 201 backtracks in 0.00s
  [backtrack] Found solution with 197 backtracks in 0.00s
  [backtrack] Found solution with 39 backtracks in 0.00s
  [backtrack] Found solution with 199 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (164 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=139.6s)
  Boundary nodes: [0, 1, 2, 3, 4, 5, 6, 11] → expanding 8 children
    V_MIN=[2, 2, 1, 2, 2, 2, 4, 3, 3, 3, 2, 3] → J=243, T=199, cost=2 → queued
    V_MIN=[2, 2, 1, 2, 2, 2, 3, 3, 3, 3, 2, 4] → J=247, T=200, cost=2 → queued

[Iter 10] cost=1, J=247, T=200, edges=35, frontier=41, MILP_calls=52
  V_MIN=[2, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 4]
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] Found solution with 42 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1181 backtracks in 0.00s)
  [backtrack] Found solution with 90 backtracks in 0.00s
  [backtrack] Found solution with 102 backtracks in 0.00s
  [backtrack] Found solution with 95 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 15 backtracks in 0.00s
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] Found solution with 78 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 7 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=99.0s)
  Boundary nodes: [0, 1, 2, 3, 4, 5, 6, 7, 11] → expanding 9 children
    V_MIN=[2, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 5] → J=241, T=199, cost=2 → queued

[Iter 11] cost=2, J=250, T=199, edges=35, frontier=41, MILP_calls=53
  V_MIN=[3, 2, 1, 3, 2, 2, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (201 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (196 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (133 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (155 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (184 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (215 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (136 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (117 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 11] → expanding 8 children
    V_MIN=[4, 2, 1, 3, 2, 2, 2, 3, 3, 3, 2, 3] → J=244, T=198, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 3, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[3, 2, 1, 4, 2, 2, 2, 3, 3, 3, 2, 3] → J=244, T=199, cost=3 → queued
    V_MIN=[3, 2, 1, 3, 3, 2, 2, 3, 3, 3, 2, 3] → J=250, T=198, cost=3 → queued
    V_MIN=[3, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3] → J=250, T=198, cost=3 → queued
    V_MIN=[3, 2, 1, 3, 2, 2, 3, 3, 3, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[3, 2, 1, 3, 2, 2, 2, 4, 3, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[3, 2, 1, 3, 2, 2, 2, 3, 3, 3, 2, 4] → J=247, T=200, cost=3 → queued

[Iter 12] cost=2, J=250, T=199, edges=35, frontier=48, MILP_calls=61
  V_MIN=[2, 3, 1, 3, 2, 2, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (244 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (132 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (93 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (138 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (191 backtracks in 0.00s)
  [backtrack] Found solution with 85 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (210 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (249 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (223 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (220 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=101.6s)
  Boundary nodes: [1, 2, 3, 4, 5, 6, 7, 11] → expanding 8 children
    V_MIN=[2, 4, 1, 3, 2, 2, 2, 3, 3, 3, 2, 3] → J=244, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 3, 3, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[2, 3, 1, 4, 2, 2, 2, 3, 3, 3, 2, 3] → J=244, T=199, cost=3 → queued
    V_MIN=[2, 3, 1, 3, 3, 2, 2, 3, 3, 3, 2, 3] → J=250, T=198, cost=3 → queued
    V_MIN=[2, 3, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3] → J=250, T=198, cost=3 → queued
    V_MIN=[2, 3, 1, 3, 2, 2, 3, 3, 3, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 3, 1, 3, 2, 2, 2, 4, 3, 3, 2, 3] → J=246, T=199, cost=3 → queued
    V_MIN=[2, 3, 1, 3, 2, 2, 2, 3, 3, 3, 2, 4] → J=247, T=200, cost=3 → queued

[Iter 13] cost=2, J=250, T=199, edges=36, frontier=55, MILP_calls=69
  V_MIN=[3, 2, 1, 2, 2, 2, 2, 4, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (58 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (173 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (117 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (177 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (242 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (67 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (229 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (63 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (116 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 11] → expanding 8 children
    V_MIN=[4, 2, 1, 2, 2, 2, 2, 4, 3, 3, 2, 3] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 4, 3, 3, 2, 3] → J=245, T=200, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 3, 2, 2, 4, 3, 3, 2, 3] → J=246, T=199, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 2, 3, 2, 4, 3, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 2, 2, 3, 4, 3, 3, 2, 3] → J=246, T=200, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 2, 2, 2, 5, 3, 3, 2, 3] → J=243, T=200, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 2, 2, 2, 4, 3, 3, 2, 4] → J=247, T=199, cost=3 → queued

[Iter 14] cost=2, J=250, T=199, edges=36, frontier=60, MILP_calls=76
  V_MIN=[2, 3, 1, 2, 2, 2, 2, 4, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (191 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (165 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (95 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (145 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (149 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (122 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (142 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (142 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (170 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (41 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [1, 2, 3, 4, 5, 6, 7, 11] → expanding 8 children
    V_MIN=[2, 4, 1, 2, 2, 2, 2, 4, 3, 3, 2, 3] → J=239, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 4, 3, 3, 2, 3] → J=245, T=200, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 3, 2, 2, 4, 3, 3, 2, 3] → J=246, T=199, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 2, 3, 2, 4, 3, 3, 2, 3] → J=246, T=197, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 2, 2, 3, 4, 3, 3, 2, 3] → J=246, T=200, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 2, 2, 2, 5, 3, 3, 2, 3] → J=243, T=200, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 2, 2, 2, 4, 3, 3, 2, 4] → J=247, T=199, cost=3 → queued

[Iter 15] cost=2, J=250, T=198, edges=37, frontier=66, MILP_calls=83
  V_MIN=[3, 2, 1, 2, 3, 2, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (44 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (46 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (97 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (36 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (45 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 6, 7, 8, 11] → expanding 7 children
    V_MIN=[4, 2, 1, 2, 3, 2, 2, 3, 3, 3, 2, 3] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 2, 3, 2, 2, 3, 3, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 4, 2, 2, 3, 3, 3, 2, 3] → MILP infeasible, pruned
    V_MIN=[3, 2, 1, 2, 3, 2, 3, 3, 3, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 3, 2, 2, 3, 4, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 3, 2, 2, 3, 3, 3, 2, 4] → J=247, T=200, cost=3 → queued

[Iter 16] cost=2, J=250, T=198, edges=37, frontier=69, MILP_calls=89
  V_MIN=[2, 3, 1, 2, 3, 2, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (46 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (40 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (76 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (70 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (75 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (64 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [1, 2, 4, 6, 7, 8, 11] → expanding 7 children
    V_MIN=[2, 4, 1, 2, 3, 2, 2, 3, 3, 3, 2, 3] → J=244, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 3, 3, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 4, 2, 2, 3, 3, 3, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 3, 1, 2, 3, 2, 3, 3, 3, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 3, 2, 2, 3, 4, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 3, 2, 2, 3, 3, 3, 2, 4] → J=247, T=200, cost=3 → queued

[Iter 17] cost=2, J=250, T=198, edges=37, frontier=73, MILP_calls=95
  V_MIN=[2, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (44 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (46 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (97 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (36 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (45 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [2, 3, 5, 6, 7, 8, 11] → expanding 7 children
    V_MIN=[2, 2, 2, 3, 2, 3, 2, 3, 3, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[2, 2, 1, 4, 2, 3, 2, 3, 3, 3, 2, 3] → J=244, T=199, cost=3 → queued
    V_MIN=[2, 2, 1, 3, 2, 4, 2, 3, 3, 3, 2, 3] → J=239, T=199, cost=3 → queued
    V_MIN=[2, 2, 1, 3, 2, 3, 3, 3, 3, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 2, 1, 3, 2, 3, 2, 4, 3, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[2, 2, 1, 3, 2, 3, 2, 3, 4, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 2, 1, 3, 2, 3, 2, 3, 3, 3, 2, 4] → J=247, T=200, cost=3 → queued

[Iter 18] cost=2, J=250, T=198, edges=37, frontier=79, MILP_calls=102
  V_MIN=[2, 2, 1, 2, 3, 3, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (44 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (46 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (97 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (36 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (45 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [2, 4, 5, 6, 7, 8, 11] → expanding 7 children
    V_MIN=[2, 2, 2, 2, 3, 3, 2, 3, 3, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 4, 3, 2, 3, 3, 3, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 1, 2, 3, 4, 2, 3, 3, 3, 2, 3] → J=239, T=198, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 3, 3, 3, 3, 3, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 3, 3, 2, 4, 3, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 3, 3, 2, 3, 4, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 3, 3, 2, 3, 3, 3, 2, 4] → J=247, T=200, cost=3 → queued

[Iter 19] cost=2, J=250, T=198, edges=37, frontier=84, MILP_calls=109
  V_MIN=[2, 2, 1, 3, 3, 2, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (46 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (40 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (76 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (70 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (75 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (64 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [2, 3, 4, 6, 7, 8, 11] → expanding 7 children
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 3, 3, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[2, 2, 1, 4, 3, 2, 2, 3, 3, 3, 2, 3] → J=244, T=199, cost=3 → queued
    V_MIN=[2, 2, 1, 3, 4, 2, 2, 3, 3, 3, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 1, 3, 3, 2, 3, 3, 3, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 2, 1, 3, 3, 2, 2, 4, 3, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[2, 2, 1, 3, 3, 2, 2, 3, 4, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 2, 1, 3, 3, 2, 2, 3, 3, 3, 2, 4] → J=247, T=200, cost=3 → queued

[Iter 20] cost=2, J=249, T=200, edges=37, frontier=89, MILP_calls=116
  V_MIN=[3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (655 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (652 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (340 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (386 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (386 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (600 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (277 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (561 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (452 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (386 backtracks in 0.00s)
  [backtrack] Found solution with 429 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (223 backtracks in 0.00s)
  DFS: latency violated (4 nodes, worst_gap=123.8s)
  Boundary nodes: [0, 2, 3, 4, 6, 7, 11] → expanding 7 children
    V_MIN=[4, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 3] → J=245, T=198, cost=3 → queued
    V_MIN=[3, 2, 3, 2, 2, 2, 2, 3, 3, 3, 2, 3] → J=246, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 3, 3, 3, 2, 3] → J=243, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 4] → J=245, T=199, cost=3 → queued

[Iter 21] cost=2, J=249, T=200, edges=37, frontier=92, MILP_calls=120
  V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (620 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (771 backtracks in 0.00s)
  [backtrack] Found solution with 271 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (529 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (419 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (361 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (644 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (653 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (173 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (856 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (178 backtracks in 0.00s)
  [backtrack] Found solution with 417 backtracks in 0.00s
  DFS: latency violated (3 nodes, worst_gap=119.0s)
  Boundary nodes: [1, 2, 3, 4, 6, 7, 11] → expanding 7 children
    V_MIN=[2, 4, 2, 2, 2, 2, 2, 3, 3, 3, 2, 3] → J=245, T=198, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 2, 3, 3, 3, 2, 3] → J=246, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 3, 3, 2, 3] → J=243, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 3, 3, 2, 4] → J=245, T=199, cost=3 → queued

[Iter 22] cost=2, J=249, T=200, edges=37, frontier=95, MILP_calls=124
  V_MIN=[2, 2, 2, 2, 2, 3, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (620 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (771 backtracks in 0.00s)
  [backtrack] Found solution with 271 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (529 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (419 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (361 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (644 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (653 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (173 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (856 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (178 backtracks in 0.00s)
  [backtrack] Found solution with 417 backtracks in 0.00s
  DFS: latency violated (3 nodes, worst_gap=119.0s)
  Boundary nodes: [2, 3, 4, 5, 6, 7, 11] → expanding 7 children
    V_MIN=[2, 2, 3, 2, 2, 3, 2, 3, 3, 3, 2, 3] → J=244, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 4, 2, 3, 3, 3, 2, 3] → J=243, T=197, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 2, 3] → J=243, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 2, 4, 3, 3, 2, 3] → J=245, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 2, 3, 3, 3, 2, 4] → J=245, T=199, cost=3 → queued

[Iter 23] cost=2, J=249, T=200, edges=36, frontier=99, MILP_calls=129
  V_MIN=[2, 2, 1, 2, 2, 2, 3, 4, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (363 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (351 backtracks in 0.00s)
  [backtrack] Found solution with 67 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (315 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (327 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (339 backtracks in 0.00s)
  [backtrack] Found solution with 137 backtracks in 0.00s
  [backtrack] Found solution with 14 backtracks in 0.00s
  [backtrack] Found solution with 8 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 10 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (509 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=125.6s)
  Boundary nodes: [0, 1, 2, 3, 4, 5, 6, 7, 11] → expanding 9 children
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 4, 3, 3, 2, 3] → J=244, T=200, cost=3 → queued
    V_MIN=[2, 2, 1, 3, 2, 2, 3, 4, 3, 3, 2, 3] → J=245, T=199, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 3, 2, 3, 4, 3, 3, 2, 3] → J=239, T=197, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 2, 3, 3, 4, 3, 3, 2, 3] → J=246, T=200, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 2, 2, 4, 4, 3, 3, 2, 3] → J=242, T=199, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 2, 2, 3, 5, 3, 3, 2, 3] → J=240, T=200, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 2, 2, 3, 4, 3, 3, 2, 4] → J=242, T=198, cost=3 → queued

[Iter 24] cost=2, J=248, T=200, edges=35, frontier=105, MILP_calls=136
  V_MIN=[3, 2, 1, 2, 2, 2, 3, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (270 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (261 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (140 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (183 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (212 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (232 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (167 backtracks in 0.00s)
  [backtrack] Found solution with 116 backtracks in 0.00s
  [backtrack] Found solution with 143 backtracks in 0.00s
  [backtrack] Found solution with 151 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (212 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=125.3s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 11] → expanding 8 children
    V_MIN=[4, 2, 1, 2, 2, 2, 3, 3, 3, 3, 2, 3] → J=244, T=200, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 2, 3, 3, 3, 3, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 2, 2, 4, 3, 3, 3, 2, 3] → J=243, T=198, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 2, 2, 3, 3, 3, 3, 2, 4] → J=247, T=200, cost=3 → queued

[Iter 25] cost=2, J=248, T=200, edges=35, frontier=108, MILP_calls=140
  V_MIN=[2, 3, 1, 2, 2, 2, 3, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (214 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (74 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (82 backtracks in 0.00s)
  [backtrack] Found solution with 160 backtracks in 0.00s
  [backtrack] Found solution with 151 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (192 backtracks in 0.00s)
  [backtrack] Found solution with 115 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (138 backtracks in 0.00s)
  [backtrack] Found solution with 138 backtracks in 0.00s
  [backtrack] Found solution with 154 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (174 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=102.5s)
  Boundary nodes: [1, 2, 3, 4, 5, 6, 7, 11] → expanding 8 children
    V_MIN=[2, 4, 1, 2, 2, 2, 3, 3, 3, 3, 2, 3] → J=244, T=198, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 2, 3, 3, 3, 3, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 2, 2, 4, 3, 3, 3, 2, 3] → J=243, T=198, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 2, 2, 3, 3, 3, 3, 2, 4] → J=247, T=200, cost=3 → queued

[Iter 26] cost=2, J=248, T=200, edges=36, frontier=111, MILP_calls=144
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 4, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (239 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (227 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (138 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (162 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (215 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (264 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (530 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (334 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (295 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (189 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 3, 4, 5, 6, 7, 11] → expanding 9 children
    V_MIN=[2, 2, 3, 2, 2, 2, 2, 4, 3, 3, 2, 3] → J=243, T=198, cost=3 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 4, 3, 3, 2, 3] → J=244, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 4, 3, 3, 2, 3] → J=242, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 5, 3, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 4, 3, 3, 2, 4] → J=245, T=199, cost=3 → queued

[Iter 27] cost=2, J=247, T=200, edges=36, frontier=115, MILP_calls=149
  V_MIN=[2, 2, 1, 2, 3, 2, 2, 3, 4, 3, 2, 3]
  [backtrack] EXHAUSTED search space (574 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (565 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (259 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (397 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (501 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (556 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (239 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (395 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (474 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (537 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (556 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (347 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [2, 4, 6, 7, 8, 11] → expanding 6 children
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 3, 4, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 4, 2, 2, 3, 4, 3, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 1, 2, 3, 2, 3, 3, 4, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 3, 2, 2, 4, 4, 3, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 3, 2, 2, 3, 5, 3, 2, 3] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 3, 2, 2, 3, 4, 3, 2, 4] → J=247, T=200, cost=3 → queued

[Iter 28] cost=2, J=247, T=200, edges=36, frontier=119, MILP_calls=155
  V_MIN=[2, 2, 1, 2, 2, 2, 2, 5, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (311 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (304 backtracks in 0.00s)
  [backtrack] Found solution with 198 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (182 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (217 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (297 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] Found solution with 94 backtracks in 0.00s
  [backtrack] Found solution with 8 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 97 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=135.3s)
  Boundary nodes: [0, 1, 3, 4, 5, 6, 7, 11] → expanding 8 children
    V_MIN=[2, 2, 1, 3, 2, 2, 2, 5, 3, 3, 2, 3] → J=240, T=198, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 3, 2, 2, 5, 3, 3, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 1, 2, 2, 3, 2, 5, 3, 3, 2, 3] → J=238, T=200, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 2, 2, 2, 6, 3, 3, 2, 3] → J=239, T=199, cost=3 → queued
    V_MIN=[2, 2, 1, 2, 2, 2, 2, 5, 3, 3, 2, 4] → J=245, T=199, cost=3 → queued

[Iter 29] cost=2, J=247, T=199, edges=35, frontier=122, MILP_calls=160
  V_MIN=[3, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 4]
  [backtrack] Found solution with 192 backtracks in 0.00s
  [backtrack] Found solution with 190 backtracks in 0.00s
  [backtrack] Found solution with 6 backtracks in 0.00s
  [backtrack] Found solution with 110 backtracks in 0.00s
  [backtrack] Found solution with 113 backtracks in 0.00s
  [backtrack] Found solution with 148 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 48 backtracks in 0.00s
  [backtrack] Found solution with 30 backtracks in 0.00s
  [backtrack] Found solution with 5 backtracks in 0.00s
  [backtrack] Found solution with 120 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=90.6s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 9, 11] → expanding 8 children
    V_MIN=[4, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 4] → J=245, T=200, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 2, 3, 2, 3, 3, 3, 2, 4] → J=247, T=200, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 2, 2, 2, 3, 3, 4, 2, 4] → J=247, T=200, cost=3 → queued
    V_MIN=[3, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 5] → J=241, T=199, cost=3 → queued

[Iter 30] cost=2, J=247, T=199, edges=35, frontier=125, MILP_calls=164
  V_MIN=[2, 3, 1, 2, 2, 2, 2, 3, 3, 3, 2, 4]
  [backtrack] Found solution with 192 backtracks in 0.00s
  [backtrack] Found solution with 190 backtracks in 0.00s
  [backtrack] Found solution with 6 backtracks in 0.00s
  [backtrack] Found solution with 110 backtracks in 0.00s
  [backtrack] Found solution with 113 backtracks in 0.00s
  [backtrack] Found solution with 148 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 48 backtracks in 0.00s
  [backtrack] Found solution with 30 backtracks in 0.00s
  [backtrack] Found solution with 5 backtracks in 0.00s
  [backtrack] Found solution with 120 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=90.6s)
  Boundary nodes: [1, 2, 3, 4, 5, 6, 9, 11] → expanding 8 children
    V_MIN=[2, 4, 1, 2, 2, 2, 2, 3, 3, 3, 2, 4] → J=245, T=197, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 2, 3, 2, 3, 3, 3, 2, 4] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 2, 2, 2, 3, 3, 4, 2, 4] → J=247, T=200, cost=3 → queued
    V_MIN=[2, 3, 1, 2, 2, 2, 2, 3, 3, 3, 2, 5] → J=241, T=199, cost=3 → queued

[Iter 31] cost=2, J=247, T=200, edges=36, frontier=128, MILP_calls=168
  V_MIN=[2, 2, 1, 2, 2, 3, 3, 3, 3, 3, 2, 3]
  [backtrack] Found solution with 2 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=200.0s
  *** SOLUTION FOUND! J=247, T_tour=200.0s ***

============================================================
Search done: 31 iters, 168 MILP calls, 168 states visited

Original flow_B is latency-feasible ✓
  flow_B = [3, -3, 0, 0, 3, 0, -1, 1, -3, 3, 0, -3, 0, 0, 3, 0, -3, 3, -4, 0, -1, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [3, -3, 0, 0, 3, 0, -1, 1, -3, 3, 0, -3, 0, 0, 3, 0, -3, 3, -4, 0, -1, 2]
  Non-zero edges: [((0, 1), np.int64(3)), ((0, 11), np.int64(-3)), ((1, 5), np.int64(3)), ((2, 8), np.int64(-1)), ((2, 11), np.int64(1)), ((3, 4), np.int64(-3)), ((3, 6), np.int64(3)), ((4, 5), np.int64(-3)), ((6, 9), np.int64(3)), ((7, 8), np.int64(-3)), ((7, 10), np.int64(3)), ((8, 9), np.int64(-4)), ((9, 10), np.int64(-1)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=20, edge=(9, 10), flow_B=-1  →  need Cm[20]=1
Blocked edge 2: idx=16, edge=(7, 8), flow_B=-3  →  need Cm[16]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=25   ||Cm||_1=15

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, -1, 0, 1, 0, 0, 0, 3, 0, 0, 1]

Cm = C_oriented @ beta*:
  [0, 0, -1, 1, 0, -1, 0, 0, 0, 1, -1, 0, 0, 2, -1, 0, 3, -1, 2, 0, 1, 0]

Original flow_B:
  [3, -3, 0, 0, 3, 0, -1, 1, -3, 3, 0, -3, 0, 0, 3, 0, -3, 3, -4, 0, -1, 2]

flow_B + Cm (corrected flow):
  [3, -3, -1, 1, 3, -1, -1, 1, -3, 4, -1, -3, 0, 2, 2, 0, 0, 2, -2, 0, 0, 2]

Verification:
  flow_corrected[20] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[16] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 25  (minimized by MIQP)
  ||Cm||_1  = 15
  ||flow_B||_2² = 104
  ||flow_corrected||_2² = 87

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         3       0           3    4.9          
    1     (0, 11)        -3       0          -3    4.1          
    2      (1, 2)         0      -1          -1    7.8     +7.8s
    3      (1, 3)         0       1           1    7.7     +7.7s
    4      (1, 5)         3       0           3    5.2          
    5      (2, 3)         0      -1          -1    4.7     +4.7s
    6      (2, 8)        -1       0          -1    5.6          
    7     (2, 11)         1       0           1    6.0          
    8      (3, 4)        -3       0          -3    5.2          
    9      (3, 6)         3       1           4    5.7     +5.7s
   10      (3, 8)         0      -1          -1    7.3     +7.3s
   11      (4, 5)        -3       0          -3    6.2          
   12      (5, 6)         0       0           0    7.3          
   13      (6, 7)         0       2           2    8.0    +16.0s
   14      (6, 9)         3      -1           2    5.3     -5.3s
   15     (6, 10)         0       0           0    4.4          
   16      (7, 8)        -3       3           0    7.1    -21.3s ← BLOCKED
   17     (7, 10)         3      -1           2    4.6     -4.6s
   18      (8, 9)        -4       2          -2    6.9    -13.8s
   19     (8, 11)         0       0           0    7.8          
   20     (9, 10)        -1       1           0    4.3     -4.3s ← BLOCKED
   21    (10, 11)         2       0           2    5.8          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=4, out=4  OK
  Node 2: in=2, out=2  OK
  Node 3: in=5, out=5  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=4, out=4  OK
  Node 7: in=2, out=2  OK
  Node 8: in=2, out=2  OK
  Node 9: in=2, out=2  OK
  Node 10: in=2, out=2  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 25

  Summary:
    Original path length:  36 edges
    Spliced path length:   35 edges
    Splices performed:     25
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           3         3  ✓
    1     (0, 11)          -3        -3  ✓
    2      (1, 2)          -1        -1  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)           3         3  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           1         1  ✓
    8      (3, 4)          -3        -3  ✓
    9      (3, 6)           4         4  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)          -3        -3  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)           2         2  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)           2         2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 29
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 1, 3, 2, 2, 2, 3, 3, 2, 2, 2] → J=235, T=200, cost=0 → queued

[Iter 1] cost=0, J=235, T=200, edges=35, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 1, 3, 2, 2, 2, 3, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (44 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (40 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (64 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (94 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (95 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (74 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7] → expanding 7 children
    V_MIN=[4, 2, 1, 3, 2, 2, 2, 3, 3, 2, 2, 2] → J=232, T=199, cost=1 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 3, 2, 2, 2] → J=226, T=200, cost=1 → queued
    V_MIN=[3, 2, 1, 4, 2, 2, 2, 3, 3, 2, 2, 2] → J=232, T=200, cost=1 → queued
    V_MIN=[3, 2, 1, 3, 3, 2, 2, 3, 3, 2, 2, 2] → J=228, T=198, cost=1 → queued
    V_MIN=[3, 2, 1, 3, 2, 3, 2, 3, 3, 2, 2, 2] → J=230, T=199, cost=1 → queued
    V_MIN=[3, 2, 1, 3, 2, 2, 3, 3, 3, 2, 2, 2] → J=232, T=198, cost=1 → queued
    V_MIN=[3, 2, 1, 3, 2, 2, 2, 4, 3, 2, 2, 2] → J=231, T=200, cost=1 → queued

[Iter 2] cost=1, J=232, T=199, edges=35, frontier=6, MILP_calls=8
  V_MIN=[4, 2, 1, 3, 2, 2, 2, 3, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (247 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (184 backtracks in 0.00s)
  [backtrack] Found solution with 89 backtracks in 0.00s
  [backtrack] Found solution with 121 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (145 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] Found solution with 29 backtracks in 0.00s
  [backtrack] Found solution with 41 backtracks in 0.00s
  [backtrack] Found solution with 28 backtracks in 0.00s
  [backtrack] Found solution with 29 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (185 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=137.4s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7] → expanding 7 children
    V_MIN=[5, 2, 1, 3, 2, 2, 2, 3, 3, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 3, 3, 2, 2, 2] → J=226, T=200, cost=2 → queued
    V_MIN=[4, 2, 1, 4, 2, 2, 2, 3, 3, 2, 2, 2] → J=232, T=200, cost=2 → queued
    V_MIN=[4, 2, 1, 3, 3, 2, 2, 3, 3, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[4, 2, 1, 3, 2, 3, 2, 3, 3, 2, 2, 2] → J=230, T=199, cost=2 → queued
    V_MIN=[4, 2, 1, 3, 2, 2, 3, 3, 3, 2, 2, 2] → J=232, T=200, cost=2 → queued
    V_MIN=[4, 2, 1, 3, 2, 2, 2, 4, 3, 2, 2, 2] → MILP infeasible, pruned

[Iter 3] cost=1, J=232, T=200, edges=35, frontier=9, MILP_calls=15
  V_MIN=[3, 2, 1, 4, 2, 2, 2, 3, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (110 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (111 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (94 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (34 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (68 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (69 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (64 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (68 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (128 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [2, 3, 4, 5, 7, 8, 9] → expanding 7 children
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 3, 2, 2, 2] → J=223, T=200, cost=2 → queued
    V_MIN=[3, 2, 1, 5, 2, 2, 2, 3, 3, 2, 2, 2] → J=228, T=200, cost=2 → queued
    V_MIN=[3, 2, 1, 4, 3, 2, 2, 3, 3, 2, 2, 2] → J=228, T=198, cost=2 → queued
    V_MIN=[3, 2, 1, 4, 2, 3, 2, 3, 3, 2, 2, 2] → J=228, T=198, cost=2 → queued
    V_MIN=[3, 2, 1, 4, 2, 2, 2, 4, 3, 2, 2, 2] → J=229, T=200, cost=2 → queued
    V_MIN=[3, 2, 1, 4, 2, 2, 2, 3, 4, 2, 2, 2] → J=231, T=200, cost=2 → queued
    V_MIN=[3, 2, 1, 4, 2, 2, 2, 3, 3, 3, 2, 2] → J=231, T=200, cost=2 → queued

[Iter 4] cost=1, J=232, T=198, edges=34, frontier=15, MILP_calls=22
  V_MIN=[3, 2, 1, 3, 2, 2, 3, 3, 3, 2, 2, 2]
  [backtrack] Found solution with 4 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.2s
  *** SOLUTION FOUND! J=232, T_tour=198.2s ***

============================================================
Search done: 4 iters, 22 MILP calls, 22 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, 0, -3, 0, 1, -1, 0, -2, 0, 0, -2, -2, 1, -3, 0, 3, -2, 4, -2, 1, -1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, 0, -3, 0, 1, -1, 0, -2, 0, 0, -2, -2, 1, -3, 0, 3, -2, 4, -2, 1, -1]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 3), np.int64(-3)), ((2, 3), np.int64(1)), ((2, 8), np.int64(-1)), ((3, 4), np.int64(-2)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(1)), ((6, 9), np.int64(-3)), ((7, 8), np.int64(3)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(4)), ((8, 11), np.int64(-2)), ((9, 10), np.int64(1)), ((10, 11), np.int64(-1))]

Blocked edge 1: idx=5, edge=(2, 3), flow_B=1  →  need Cm[5]=-1
Blocked edge 2: idx=0, edge=(0, 1), flow_B=-3  →  need Cm[0]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=33   ||Cm||_1=17

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-2, -1, 1, 0, 1, 1, 3, 1, -1, -2, 1]

Cm = C_oriented @ beta*:
  [3, -3, 1, 0, 2, -1, 0, 2, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]

Original flow_B:
  [-3, 3, 0, -3, 0, 1, -1, 0, -2, 0, 0, -2, -2, 1, -3, 0, 3, -2, 4, -2, 1, -1]

flow_B + Cm (corrected flow):
  [0, 0, 1, -3, 2, 0, -1, 2, -3, 0, 0, -3, -1, 1, -3, 1, 3, -2, 4, -2, 1, 0]

Verification:
  flow_corrected[5] = 0  (should be 0, Cm=-1, d=-1)
  flow_corrected[0] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 33  (minimized by MIQP)
  ||Cm||_1  = 17
  ||flow_B||_2² = 86
  ||flow_corrected||_2² = 83

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       3           0    4.2    -12.6s ← BLOCKED
    1     (0, 11)         3      -3           0    5.6    -16.8s
    2      (1, 2)         0       1           1    6.4     +6.4s
    3      (1, 3)        -3       0          -3    5.0          
    4      (1, 5)         0       2           2    5.1    +10.2s
    5      (2, 3)         1      -1           0    6.7     -6.7s ← BLOCKED
    6      (2, 8)        -1       0          -1    7.4          
    7     (2, 11)         0       2           2    7.2    +14.4s
    8      (3, 4)        -2      -1          -3    4.0     +4.0s
    9      (3, 6)         0       0           0    7.7          
   10      (3, 8)         0       0           0    7.2          
   11      (4, 5)        -2      -1          -3    7.8     +7.8s
   12      (5, 6)        -2       1          -1    5.9     -5.9s
   13      (6, 7)         1       0           1    6.7          
   14      (6, 9)        -3       0          -3    6.9          
   15     (6, 10)         0       1           1    5.9     +5.9s
   16      (7, 8)         3       0           3    7.2          
   17     (7, 10)        -2       0          -2    5.8          
   18      (8, 9)         4       0           4    4.5          
   19     (8, 11)        -2       0          -2    6.6          
   20     (9, 10)         1       0           1    5.9          
   21    (10, 11)        -1       1           0    6.6     -6.6s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=3, out=3  OK
  Node 2: in=2, out=2  OK
  Node 3: in=3, out=3  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=3, out=3  OK
  Node 7: in=3, out=3  OK
  Node 8: in=5, out=5  OK
  Node 9: in=4, out=4  OK
  Node 10: in=2, out=2  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 33 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 18

  Summary:
    Original path length:  34 edges
    Spliced path length:   33 edges
    Splices performed:     18
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           1         1  ✓
    3      (1, 3)          -3        -3  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           2         2  ✓
    8      (3, 4)          -3        -3  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -3        -3  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)          -3        -3  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)           3         3  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           4         4  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 30
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 1, 2] → J=215, T=200, cost=0 → queued

[Iter 1] cost=0, J=215, T=200, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (269 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (309 backtracks in 0.00s)
  [backtrack] Found solution with 357 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (241 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (333 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (322 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (445 backtracks in 0.00s)
  [backtrack] Found solution with 317 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (377 backtracks in 0.00s)
  [backtrack] Found solution with 14 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (232 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=107.3s)
  Boundary nodes: [0, 4, 9] → expanding 3 children
    V_MIN=[3, 2, 2, 2, 3, 2, 3, 2, 2, 2, 1, 2] → J=213, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 4, 2, 3, 2, 2, 2, 1, 2] → J=214, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 3, 1, 2] → J=211, T=198, cost=1 → queued

[Iter 2] cost=1, J=214, T=200, edges=37, frontier=2, MILP_calls=4
  V_MIN=[2, 2, 2, 2, 4, 2, 3, 2, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (375 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (485 backtracks in 0.00s)
  [backtrack] Found solution with 368 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (280 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (537 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (524 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (241 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (280 backtracks in 0.00s)
  [backtrack] Found solution with 197 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (306 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (267 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (338 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=89.8s)
  Boundary nodes: [0, 4, 7, 9] → expanding 4 children
    V_MIN=[3, 2, 2, 2, 4, 2, 3, 2, 2, 2, 1, 2] → J=202, T=198, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 5, 2, 3, 2, 2, 2, 1, 2] → J=209, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 4, 2, 3, 3, 2, 2, 1, 2] → J=213, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 4, 2, 3, 2, 2, 3, 1, 2] → J=206, T=199, cost=2 → queued

[Iter 3] cost=1, J=213, T=200, edges=36, frontier=5, MILP_calls=8
  V_MIN=[3, 2, 2, 2, 3, 2, 3, 2, 2, 2, 1, 2]
  [backtrack] Found solution with 32 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.9s
  *** SOLUTION FOUND! J=213, T_tour=199.9s ***

============================================================
Search done: 3 iters, 8 MILP calls, 8 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, 0, 0, -3, 0, 2, -2, 3, -3, 0, 3, 0, -4, 2, -1, -4, 0, -1, -1, 1, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, 0, 0, -3, 0, 2, -2, 3, -3, 0, 3, 0, -4, 2, -1, -4, 0, -1, -1, 1, 0]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 5), np.int64(-3)), ((2, 8), np.int64(2)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(3)), ((3, 6), np.int64(-3)), ((4, 5), np.int64(3)), ((6, 7), np.int64(-4)), ((6, 9), np.int64(2)), ((6, 10), np.int64(-1)), ((7, 8), np.int64(-4)), ((8, 9), np.int64(-1)), ((8, 11), np.int64(-1)), ((9, 10), np.int64(1))]

Blocked edge 1: idx=18, edge=(8, 9), flow_B=-1  →  need Cm[18]=1
Blocked edge 2: idx=9, edge=(3, 6), flow_B=-3  →  need Cm[9]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=29   ||Cm||_1=19

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, -2, 2, 1, 1, -1, 1, 3, -2, 1, 2]

Cm = C_oriented @ beta*:
  [1, -1, 0, 2, -1, 0, 1, -1, 0, 3, -1, 0, -1, 1, 0, 1, 1, 0, 1, 0, 1, 2]

Original flow_B:
  [-3, 3, 0, 0, -3, 0, 2, -2, 3, -3, 0, 3, 0, -4, 2, -1, -4, 0, -1, -1, 1, 0]

flow_B + Cm (corrected flow):
  [-2, 2, 0, 2, -4, 0, 3, -3, 3, 0, -1, 3, -1, -3, 2, 0, -3, 0, 0, -1, 2, 2]

Verification:
  flow_corrected[18] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[9] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 29  (minimized by MIQP)
  ||Cm||_1  = 19
  ||flow_B||_2² = 102
  ||flow_corrected||_2² = 97

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       1          -2    6.1     -6.1s
    1     (0, 11)         3      -1           2    7.1     -7.1s
    2      (1, 2)         0       0           0    7.7          
    3      (1, 3)         0       2           2    4.4     +8.8s
    4      (1, 5)        -3      -1          -4    4.8     +4.8s
    5      (2, 3)         0       0           0    8.0          
    6      (2, 8)         2       1           3    4.9     +4.9s
    7     (2, 11)        -2      -1          -3    5.0     +5.0s
    8      (3, 4)         3       0           3    6.5          
    9      (3, 6)        -3       3           0    6.9    -20.7s ← BLOCKED
   10      (3, 8)         0      -1          -1    6.8     +6.8s
   11      (4, 5)         3       0           3    4.1          
   12      (5, 6)         0      -1          -1    7.6     +7.6s
   13      (6, 7)        -4       1          -3    5.1     -5.1s
   14      (6, 9)         2       0           2    6.2          
   15     (6, 10)        -1       1           0    5.5     -5.5s
   16      (7, 8)        -4       1          -3    4.1     -4.1s
   17     (7, 10)         0       0           0    6.0          
   18      (8, 9)        -1       1           0    7.3     -7.3s ← BLOCKED
   19     (8, 11)        -1       0          -1    5.5          
   20     (9, 10)         1       1           2    6.1     +6.1s
   21    (10, 11)         0       2           2    5.9    +11.8s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=4, out=4  OK
  Node 2: in=3, out=3  OK
  Node 3: in=3, out=3  OK
  Node 4: in=3, out=3  OK
  Node 5: in=4, out=4  OK
  Node 6: in=3, out=3  OK
  Node 7: in=3, out=3  OK
  Node 8: in=4, out=4  OK
  Node 9: in=2, out=2  OK
  Node 10: in=2, out=2  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 37 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 22

  Summary:
    Original path length:  36 edges
    Spliced path length:   37 edges
    Splices performed:     22
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)           2         2  ✓
    4      (1, 5)          -4        -4  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           3         3  ✓
    7     (2, 11)          -3        -3  ✓
    8      (3, 4)           3         3  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           3         3  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)          -3        -3  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)          -3        -3  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           2         2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 31
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 1, 2, 2, 2, 2] → J=260, T=199, cost=0 → queued

[Iter 1] cost=0, J=260, T=199, edges=38, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 2, 3, 2, 2, 3, 1, 2, 2, 2, 2]
  [backtrack] Found solution with 53 backtracks in 0.00s
  [backtrack] Found solution with 70 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1132 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1272 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (553 backtracks in 0.00s)
  [backtrack] Found solution with 263 backtracks in 0.00s
  [backtrack] Found solution with 4 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1078 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (649 backtracks in 0.00s)
  [backtrack] Found solution with 48 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=91.7s)
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 3, 2, 3, 2, 2, 3, 1, 2, 2, 2, 2] → J=241, T=198, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 3, 2, 3, 1, 2, 2, 2, 2] → J=238, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2, 2] → J=251, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 4, 1, 2, 2, 2, 2] → J=258, T=198, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2] → J=254, T=199, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 1, 3, 2, 2, 2] → J=250, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 1, 2, 3, 2, 2] → J=254, T=199, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 1, 2, 2, 3, 2] → J=244, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 1, 2, 2, 2, 3] → J=247, T=199, cost=1 → queued

[Iter 2] cost=1, J=258, T=198, edges=38, frontier=8, MILP_calls=10
  V_MIN=[2, 3, 2, 3, 2, 2, 4, 1, 2, 2, 2, 2]
  [backtrack] Found solution with 187 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.3s
  *** SOLUTION FOUND! J=258, T_tour=198.3s ***

============================================================
Search done: 2 iters, 10 MILP calls, 10 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 5, -3, 0, 6, -1, 0, -2, 4, 1, -2, -2, 0, 2, 0, 1, -1, 0, 1, 2, 1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 5, -3, 0, 6, -1, 0, -2, 4, 1, -2, -2, 0, 2, 0, 1, -1, 0, 1, 2, 1]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(5)), ((1, 3), np.int64(-3)), ((2, 3), np.int64(6)), ((2, 8), np.int64(-1)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(4)), ((3, 8), np.int64(1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-2)), ((6, 9), np.int64(2)), ((7, 8), np.int64(1)), ((7, 10), np.int64(-1)), ((8, 11), np.int64(1)), ((9, 10), np.int64(2)), ((10, 11), np.int64(1))]

Blocked edge 1: idx=9, edge=(3, 6), flow_B=4  →  need Cm[9]=-4
Blocked edge 2: idx=16, edge=(7, 8), flow_B=1  →  need Cm[16]=-1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=33   ||Cm||_1=19

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 1, -1, 0, -2, 1, 0, -2, 1, -1, -3]

Cm = C_oriented @ beta*:
  [0, 0, 1, -2, 1, -1, 1, 1, 0, -4, 1, 0, 1, -1, -1, -1, -1, 0, 1, 0, 0, -1]

Original flow_B:
  [2, -2, 5, -3, 0, 6, -1, 0, -2, 4, 1, -2, -2, 0, 2, 0, 1, -1, 0, 1, 2, 1]

flow_B + Cm (corrected flow):
  [2, -2, 6, -5, 1, 5, 0, 1, -2, 0, 2, -2, -1, -1, 1, -1, 0, -1, 1, 1, 2, 0]

Verification:
  flow_corrected[9] = 0  (should be 0, Cm=-4, d=-4)
  flow_corrected[16] = 0  (should be 0, Cm=-1, d=-1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 33  (minimized by MIQP)
  ||Cm||_1  = 19
  ||flow_B||_2² = 120
  ||flow_corrected||_2² = 119

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    6.7          
    1     (0, 11)        -2       0          -2    5.7          
    2      (1, 2)         5       1           6    4.2     +4.2s
    3      (1, 3)        -3      -2          -5    4.8     +9.6s
    4      (1, 5)         0       1           1    5.8     +5.8s
    5      (2, 3)         6      -1           5    4.3     -4.3s
    6      (2, 8)        -1       1           0    5.2     -5.2s
    7     (2, 11)         0       1           1    7.8     +7.8s
    8      (3, 4)        -2       0          -2    5.1          
    9      (3, 6)         4      -4           0    5.1    -20.4s ← BLOCKED
   10      (3, 8)         1       1           2    5.6     +5.6s
   11      (4, 5)        -2       0          -2    7.3          
   12      (5, 6)        -2       1          -1    6.0     -6.0s
   13      (6, 7)         0      -1          -1    5.1     +5.1s
   14      (6, 9)         2      -1           1    5.4     -5.4s
   15     (6, 10)         0      -1          -1    7.9     +7.9s
   16      (7, 8)         1      -1           0    4.7     -4.7s ← BLOCKED
   17     (7, 10)        -1       0          -1    5.0          
   18      (8, 9)         0       1           1    6.8     +6.8s
   19     (8, 11)         1       0           1    5.5          
   20     (9, 10)         2       0           2    5.8          
   21    (10, 11)         1      -1           0    6.7     -6.7s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=7, out=7  OK
  Node 2: in=6, out=6  OK
  Node 3: in=7, out=7  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=2, out=2  OK
  Node 7: in=1, out=1  OK
  Node 8: in=2, out=2  OK
  Node 9: in=2, out=2  OK
  Node 10: in=2, out=2  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 37 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 22

  Summary:
    Original path length:  38 edges
    Spliced path length:   37 edges
    Splices performed:     22
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           6         6  ✓
    3      (1, 3)          -5        -5  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)           5         5  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           1         1  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           2         2  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)           1         1  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)           1         1  ✓
   19     (8, 11)           1         1  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 32
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 1, 2] → J=225, T=200, cost=0 → queued

[Iter 1] cost=0, J=225, T=200, edges=34, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 1, 2]
  [backtrack] Found solution with 59 backtracks in 0.00s
  [backtrack] Found solution with 59 backtracks in 0.00s
  [backtrack] Found solution with 4 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1158 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (995 backtracks in 0.00s)
  [backtrack] Found solution with 162 backtracks in 0.00s
  [backtrack] Found solution with 218 backtracks in 0.00s
  [backtrack] Found solution with 4 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (541 backtracks in 0.00s)
  [backtrack] Found solution with 97 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  DFS: latency violated (3 nodes, worst_gap=130.5s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 3, 2, 2, 1, 2] → J=215, T=200, cost=1 → queued
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 2] → J=225, T=200, cost=1 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 1, 2] → J=225, T=200, cost=1 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 3, 2, 2, 1, 2] → J=224, T=199, cost=1 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 2, 1, 2] → J=223, T=200, cost=1 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 3, 1, 2] → J=225, T=199, cost=1 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2] → J=224, T=199, cost=1 → queued

[Iter 2] cost=1, J=225, T=200, edges=34, frontier=6, MILP_calls=8
  V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 2]
  [backtrack] Found solution with 34 backtracks in 0.00s
  [backtrack] Found solution with 34 backtracks in 0.00s
  [backtrack] Found solution with 60 backtracks in 0.00s
  [backtrack] Found solution with 34 backtracks in 0.00s
  [backtrack] Found solution with 34 backtracks in 0.00s
  [backtrack] Found solution with 34 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (99 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] Found solution with 60 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (102 backtracks in 0.00s)
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 34 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=129.8s)
  Boundary nodes: [0, 3, 4, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 1, 2] → J=224, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 4, 2, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 3, 3, 2, 2, 1, 2] → J=221, T=197, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 3, 1, 2] → J=225, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 2, 2, 2] → J=224, T=200, cost=2 → queued

[Iter 3] cost=1, J=225, T=200, edges=34, frontier=9, MILP_calls=15
  V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 1, 2]
  [backtrack] Found solution with 115 backtracks in 0.00s
  [backtrack] Found solution with 73 backtracks in 0.00s
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] Found solution with 44 backtracks in 0.00s
  [backtrack] Found solution with 72 backtracks in 0.00s
  [backtrack] Found solution with 73 backtracks in 0.00s
  [backtrack] Found solution with 30 backtracks in 0.00s
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (70 backtracks in 0.00s)
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (116 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=129.8s)
  Boundary nodes: [0, 3, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 3, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 3, 2, 3, 2, 2, 1, 2] → J=224, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 4, 2, 3, 2, 2, 1, 2] → J=219, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 3, 3, 2, 2, 1, 2] → J=223, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 4, 2, 2, 1, 2] → J=218, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 3, 1, 2] → J=225, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 2] → J=224, T=200, cost=2 → queued

[Iter 4] cost=1, J=225, T=199, edges=34, frontier=14, MILP_calls=22
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (122 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (40 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (39 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (123 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (67 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (41 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 6, 7, 9, 10] → expanding 6 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 3, 1, 2] → J=225, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 3, 2, 3, 1, 2] → J=224, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 3, 1, 2] → J=223, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 4, 1, 2] → J=224, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 3, 2, 2] → J=224, T=199, cost=2 → queued

[Iter 5] cost=1, J=224, T=199, edges=35, frontier=18, MILP_calls=28
  V_MIN=[3, 2, 2, 3, 2, 2, 3, 3, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (948 backtracks in 0.00s)
  [backtrack] Found solution with 79 backtracks in 0.00s
  [backtrack] Found solution with 178 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (180 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (339 backtracks in 0.00s)
  [backtrack] Found solution with 124 backtracks in 0.00s
  [backtrack] Found solution with 156 backtracks in 0.00s
  [backtrack] Found solution with 156 backtracks in 0.00s
  [backtrack] Found solution with 52 backtracks in 0.00s
  [backtrack] Found solution with 95 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1003 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=126.5s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 2, 3, 3, 2, 2, 1, 2] → J=211, T=198, cost=2 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 3, 3, 2, 2, 1, 2] → J=224, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 3, 3, 2, 2, 1, 2] → J=223, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 1, 2] → J=223, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 4, 2, 2, 1, 2] → J=223, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 3, 2, 2, 2, 2] → J=223, T=200, cost=2 → queued

[Iter 6] cost=1, J=224, T=199, edges=35, frontier=23, MILP_calls=34
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (970 backtracks in 0.00s)
  [backtrack] Found solution with 85 backtracks in 0.00s
  [backtrack] Found solution with 163 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (358 backtracks in 0.00s)
  [backtrack] Found solution with 85 backtracks in 0.00s
  [backtrack] Found solution with 142 backtracks in 0.00s
  [backtrack] Found solution with 142 backtracks in 0.00s
  [backtrack] Found solution with 94 backtracks in 0.00s
  [backtrack] Found solution with 134 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1004 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=126.5s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2] → J=215, T=200, cost=2 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 3, 2, 2, 2, 2] → J=224, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 2, 2, 2] → J=224, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 2, 2, 2] → J=223, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 2] → J=223, T=199, cost=2 → queued

[Iter 7] cost=1, J=223, T=200, edges=35, frontier=27, MILP_calls=39
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (129 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (55 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (108 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (215 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (66 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7] → expanding 6 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 4, 2, 2, 1, 2] → J=220, T=198, cost=2 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 4, 2, 2, 1, 2] → J=222, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 5, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 8] cost=1, J=215, T=200, edges=34, frontier=28, MILP_calls=43
  V_MIN=[4, 2, 2, 3, 2, 2, 2, 3, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (465 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (388 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (312 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (130 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (241 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (302 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (185 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (362 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (233 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (296 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (277 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (464 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7, 9] → expanding 7 children
    V_MIN=[5, 2, 2, 3, 2, 2, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[4, 2, 2, 4, 2, 2, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 9] cost=2, J=225, T=199, edges=34, frontier=27, MILP_calls=45
  V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (115 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (40 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (39 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (38 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (21 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (41 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (41 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 3, 2, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 3, 2, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 4, 2, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 3, 3, 2, 3, 1, 2] → J=221, T=197, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 4, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 3, 2, 2] → J=221, T=198, cost=3 → queued

[Iter 10] cost=2, J=225, T=199, edges=34, frontier=28, MILP_calls=52
  V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (122 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (40 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (39 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (123 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (67 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (41 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 3, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 3, 2, 3, 2, 3, 1, 2] → J=220, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 4, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 3, 3, 3, 2, 3, 1, 2] → J=221, T=198, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 4, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 4, 1, 2] → J=222, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 2] → J=222, T=200, cost=3 → queued

[Iter 11] cost=2, J=225, T=199, edges=34, frontier=31, MILP_calls=59
  V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (149 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (190 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (157 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (159 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (145 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (55 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (186 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (100 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 4, 2, 2, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 2, 2, 2, 3, 2, 3, 1, 2] → J=222, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 3, 3, 2, 3, 1, 2] → J=223, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 4, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 4, 1, 2] → J=223, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 3, 2, 2] → J=223, T=200, cost=3 → queued

[Iter 12] cost=2, J=224, T=199, edges=35, frontier=34, MILP_calls=65
  V_MIN=[3, 2, 2, 3, 2, 2, 3, 3, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (948 backtracks in 0.00s)
  [backtrack] Found solution with 79 backtracks in 0.00s
  [backtrack] Found solution with 178 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (180 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (339 backtracks in 0.00s)
  [backtrack] Found solution with 124 backtracks in 0.00s
  [backtrack] Found solution with 156 backtracks in 0.00s
  [backtrack] Found solution with 156 backtracks in 0.00s
  [backtrack] Found solution with 52 backtracks in 0.00s
  [backtrack] Found solution with 95 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1003 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=126.5s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 2, 3, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 3, 3, 2, 3, 1, 2] → J=224, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 4, 3, 2, 3, 1, 2] → J=223, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 4, 2, 3, 1, 2] → J=223, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 3, 2, 3, 2, 2] → J=223, T=200, cost=3 → queued

[Iter 13] cost=2, J=224, T=199, edges=35, frontier=37, MILP_calls=70
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 4, 1, 2]
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (644 backtracks in 0.00s)
  [backtrack] Found solution with 41 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (526 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (480 backtracks in 0.00s)
  [backtrack] Found solution with 256 backtracks in 0.00s
  [backtrack] Found solution with 133 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (290 backtracks in 0.00s)
  [backtrack] Found solution with 275 backtracks in 0.00s
  [backtrack] Found solution with 99 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=129.9s)
  Boundary nodes: [0, 2, 3, 4, 5, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 3, 2, 4, 1, 2] → J=224, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 4, 1, 2] → J=223, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 5, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 4, 2, 2] → J=224, T=199, cost=3 → queued

[Iter 14] cost=2, J=224, T=199, edges=35, frontier=39, MILP_calls=75
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 3, 2, 2]
  [backtrack] EXHAUSTED search space (970 backtracks in 0.00s)
  [backtrack] Found solution with 85 backtracks in 0.00s
  [backtrack] Found solution with 163 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (358 backtracks in 0.00s)
  [backtrack] Found solution with 85 backtracks in 0.00s
  [backtrack] Found solution with 142 backtracks in 0.00s
  [backtrack] Found solution with 142 backtracks in 0.00s
  [backtrack] Found solution with 94 backtracks in 0.00s
  [backtrack] Found solution with 134 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1004 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=126.5s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 3, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2] → J=224, T=199, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 3, 2, 2] → J=223, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 3, 3, 2] → J=223, T=200, cost=3 → queued

[Iter 15] cost=2, J=224, T=200, edges=34, frontier=41, MILP_calls=79
  V_MIN=[3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 1, 2]
  [backtrack] Found solution with 39 backtracks in 0.00s
  [backtrack] Found solution with 422 backtracks in 0.00s
  [backtrack] Found solution with 71 backtracks in 0.00s
  [backtrack] Found solution with 214 backtracks in 0.00s
  [backtrack] Found solution with 239 backtracks in 0.00s
  [backtrack] Found solution with 323 backtracks in 0.00s
  [backtrack] Found solution with 389 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (480 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (487 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (440 backtracks in 0.00s)
  [backtrack] Found solution with 41 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=99.0s)
  Boundary nodes: [0, 2, 3, 4, 6, 7, 9] → expanding 7 children
    V_MIN=[4, 2, 2, 4, 3, 2, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 3, 2, 2, 3, 2, 2, 1, 2] → J=224, T=199, cost=3 → queued
    V_MIN=[3, 2, 2, 5, 3, 2, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 4, 2, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 3, 2, 3, 3, 2, 2, 1, 2] → J=220, T=198, cost=3 → queued
    V_MIN=[3, 2, 2, 4, 3, 2, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 16] cost=2, J=224, T=200, edges=34, frontier=42, MILP_calls=85
  V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 477 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (423 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (285 backtracks in 0.00s)
  [backtrack] Found solution with 305 backtracks in 0.00s
  [backtrack] Found solution with 307 backtracks in 0.00s
  [backtrack] Found solution with 173 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (262 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (552 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (409 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (340 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (389 backtracks in 0.00s)
  [backtrack] Found solution with 269 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=99.0s)
  Boundary nodes: [0, 2, 4, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 3, 2, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 3, 2, 2, 2, 2] → J=224, T=199, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 4, 2, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 3, 3, 2, 2, 2, 2] → J=220, T=198, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 4, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 2, 3, 2] → J=219, T=197, cost=3 → queued

[Iter 17] cost=2, J=224, T=200, edges=34, frontier=44, MILP_calls=91
  V_MIN=[3, 2, 2, 4, 2, 3, 2, 3, 2, 2, 1, 2]
  [backtrack] Found solution with 39 backtracks in 0.00s
  [backtrack] Found solution with 422 backtracks in 0.00s
  [backtrack] Found solution with 71 backtracks in 0.00s
  [backtrack] Found solution with 214 backtracks in 0.00s
  [backtrack] Found solution with 239 backtracks in 0.00s
  [backtrack] Found solution with 323 backtracks in 0.00s
  [backtrack] Found solution with 389 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (480 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (487 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (440 backtracks in 0.00s)
  [backtrack] Found solution with 41 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=99.0s)
  Boundary nodes: [0, 2, 3, 5, 6, 7, 9] → expanding 7 children
    V_MIN=[4, 2, 2, 4, 2, 3, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 2, 3, 2, 3, 2, 2, 1, 2] → J=224, T=199, cost=3 → queued
    V_MIN=[3, 2, 2, 5, 2, 3, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 4, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 3, 3, 3, 2, 2, 1, 2] → J=223, T=199, cost=3 → queued
    V_MIN=[3, 2, 2, 4, 2, 3, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 18] cost=2, J=224, T=200, edges=34, frontier=45, MILP_calls=97
  V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 39 backtracks in 0.00s
  [backtrack] Found solution with 422 backtracks in 0.00s
  [backtrack] Found solution with 71 backtracks in 0.00s
  [backtrack] Found solution with 214 backtracks in 0.00s
  [backtrack] Found solution with 239 backtracks in 0.00s
  [backtrack] Found solution with 323 backtracks in 0.00s
  [backtrack] Found solution with 389 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (480 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (487 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (440 backtracks in 0.00s)
  [backtrack] Found solution with 41 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=99.0s)
  Boundary nodes: [0, 2, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 3, 2, 3, 2, 2, 2, 2] → J=224, T=199, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 4, 2, 3, 2, 2, 2, 2] → J=219, T=199, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 3, 3, 2, 2, 2, 2] → J=220, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 4, 2, 2, 2, 2] → J=218, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2] → J=222, T=200, cost=3 → queued

[Iter 19] cost=2, J=224, T=200, edges=34, frontier=49, MILP_calls=103
  V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 39 backtracks in 0.00s
  [backtrack] Found solution with 422 backtracks in 0.00s
  [backtrack] Found solution with 71 backtracks in 0.00s
  [backtrack] Found solution with 214 backtracks in 0.00s
  [backtrack] Found solution with 239 backtracks in 0.00s
  [backtrack] Found solution with 323 backtracks in 0.00s
  [backtrack] Found solution with 389 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (480 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (487 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (440 backtracks in 0.00s)
  [backtrack] Found solution with 41 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=99.0s)
  Boundary nodes: [0, 2, 3, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 4, 2, 2, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 2, 2, 2, 3, 2, 2, 2, 2] → J=224, T=199, cost=3 → queued
    V_MIN=[3, 2, 2, 5, 2, 2, 2, 3, 2, 2, 2, 2] → J=224, T=199, cost=3 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 3, 3, 2, 2, 2, 2] → J=223, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 4, 2, 2, 2, 2] → J=222, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 2, 3, 2] → J=223, T=200, cost=3 → queued

[Iter 20] cost=2, J=224, T=200, edges=35, frontier=53, MILP_calls=109
  V_MIN=[3, 2, 3, 3, 2, 2, 3, 3, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (366 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (330 backtracks in 0.00s)
  [backtrack] Found solution with 127 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (103 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (199 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (243 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (196 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (162 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (270 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (148 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=122.0s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 3, 3, 2, 2, 3, 3, 2, 2, 1, 2] → J=209, T=200, cost=3 → queued
    V_MIN=[3, 2, 4, 3, 2, 2, 3, 3, 2, 2, 1, 2] → J=224, T=200, cost=3 → queued
    V_MIN=[3, 2, 3, 4, 2, 2, 3, 3, 2, 2, 1, 2] → J=223, T=200, cost=3 → queued
    V_MIN=[3, 2, 3, 3, 3, 2, 3, 3, 2, 2, 1, 2] → J=220, T=200, cost=3 → queued
    V_MIN=[3, 2, 3, 3, 2, 3, 3, 3, 2, 2, 1, 2] → J=223, T=199, cost=3 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 4, 3, 2, 2, 1, 2] → J=222, T=200, cost=3 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 3, 4, 2, 2, 1, 2] → J=220, T=200, cost=3 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 3, 3, 2, 2, 2, 2] → J=221, T=199, cost=3 → queued

[Iter 21] cost=2, J=224, T=199, edges=35, frontier=60, MILP_calls=117
  V_MIN=[3, 2, 3, 3, 2, 2, 2, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (794 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (687 backtracks in 0.00s)
  [backtrack] Found solution with 252 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (213 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (251 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (387 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (468 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (363 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (451 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (630 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (463 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (313 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=121.3s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 3, 3, 2, 2, 2, 3, 2, 2, 2, 2] → J=215, T=200, cost=3 → queued
    V_MIN=[3, 2, 4, 3, 2, 2, 2, 3, 2, 2, 2, 2] → J=223, T=199, cost=3 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 4, 2, 2, 2, 2] → J=220, T=199, cost=3 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 3, 2, 2, 3, 2] → J=221, T=198, cost=3 → queued

[Iter 22] cost=2, J=223, T=200, edges=34, frontier=63, MILP_calls=121
  V_MIN=[3, 2, 2, 4, 2, 2, 3, 3, 2, 2, 1, 2]
  [backtrack] Found solution with 86 backtracks in 0.00s
  [backtrack] Found solution with 133 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (103 backtracks in 0.00s)
  [backtrack] Found solution with 133 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (289 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (226 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (148 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (202 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (283 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (157 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (98 backtracks in 0.00s)
  [backtrack] Found solution with 36 backtracks in 0.00s
  DFS: latency violated (3 nodes, worst_gap=124.0s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 4, 2, 2, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 2, 4, 3, 2, 2, 1, 2] → J=223, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 3, 4, 2, 2, 1, 2] → J=221, T=200, cost=3 → queued

[Iter 23] cost=2, J=223, T=200, edges=35, frontier=64, MILP_calls=124
  V_MIN=[3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (591 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (565 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (320 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (271 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (547 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (354 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (155 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (359 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (499 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (561 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (332 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (488 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 6, 7, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 2, 4, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 4, 3, 2, 2, 1, 2] → J=216, T=198, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 4, 3, 2, 2, 1, 2] → J=218, T=199, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 5, 3, 2, 2, 1, 2] → J=222, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 4, 4, 2, 2, 1, 2] → J=221, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 2, 2] → J=222, T=200, cost=3 → queued

[Iter 24] cost=2, J=223, T=200, edges=35, frontier=68, MILP_calls=130
  V_MIN=[3, 2, 2, 3, 2, 2, 3, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 110 backtracks in 0.00s
  [backtrack] Found solution with 135 backtracks in 0.00s
  [backtrack] Found solution with 201 backtracks in 0.00s
  [backtrack] Found solution with 170 backtracks in 0.00s
  [backtrack] Found solution with 483 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (2476 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (931 backtracks in 0.00s)
  [backtrack] Found solution with 694 backtracks in 0.00s
  [backtrack] Found solution with 582 backtracks in 0.00s
  [backtrack] Found solution with 130 backtracks in 0.00s
  [backtrack] Found solution with 761 backtracks in 0.00s
  [backtrack] Found solution with 94 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=101.3s)
  Boundary nodes: [0, 2, 4, 5, 6, 7, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 2, 3, 3, 2, 2, 2, 2] → J=211, T=198, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 4, 2, 2, 2, 2] → J=223, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 3, 2, 2, 3, 2] → J=222, T=200, cost=3 → queued

[Iter 25] cost=2, J=223, T=199, edges=35, frontier=70, MILP_calls=133
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 2]
  [backtrack] Found solution with 554 backtracks in 0.00s
  [backtrack] Found solution with 342 backtracks in 0.00s
  [backtrack] Found solution with 510 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (429 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (634 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (397 backtracks in 0.00s)
  [backtrack] Found solution with 333 backtracks in 0.00s
  [backtrack] Found solution with 367 backtracks in 0.00s
  [backtrack] Found solution with 423 backtracks in 0.00s
  [backtrack] Found solution with 101 backtracks in 0.00s
  [backtrack] Found solution with 234 backtracks in 0.00s
  [backtrack] Found solution with 378 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=107.9s)
  Boundary nodes: [0, 2, 4, 5, 6, 7, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 2] → J=211, T=197, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 2, 3, 2] → J=223, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 4, 2] → J=221, T=200, cost=3 → queued

[Iter 26] cost=2, J=223, T=200, edges=35, frontier=72, MILP_calls=136
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (129 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (55 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (108 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (215 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (66 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7] → expanding 6 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 4, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 4, 2, 3, 1, 2] → J=220, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 5, 2, 3, 1, 2] → MILP infeasible, pruned

[Iter 27] cost=2, J=223, T=200, edges=35, frontier=72, MILP_calls=139
  V_MIN=[3, 2, 2, 3, 2, 2, 3, 4, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (129 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (55 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (108 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (215 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (66 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 2, 3, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 3, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 3, 3, 4, 2, 2, 1, 2] → J=218, T=200, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 5, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 28] cost=2, J=223, T=200, edges=35, frontier=72, MILP_calls=143
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (165 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (86 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (102 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (82 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (111 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (58 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (144 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (110 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (73 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 4, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 5, 2, 2, 2, 2] → MILP infeasible, pruned

[Iter 29] cost=2, J=223, T=199, edges=34, frontier=71, MILP_calls=145
  V_MIN=[3, 2, 2, 3, 2, 3, 3, 3, 2, 2, 1, 2]
  [backtrack] Found solution with 271 backtracks in 0.00s
  [backtrack] Found solution with 387 backtracks in 0.00s
  [backtrack] Found solution with 596 backtracks in 0.00s
  [backtrack] Found solution with 515 backtracks in 0.00s
  [backtrack] Found solution with 423 backtracks in 0.00s
  [backtrack] Found solution with 396 backtracks in 0.00s
  [backtrack] Found solution with 886 backtracks in 0.00s
  [backtrack] Found solution with 474 backtracks in 0.00s
  [backtrack] Found solution with 421 backtracks in 0.00s
  [backtrack] Found solution with 356 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (626 backtracks in 0.00s)
  [backtrack] Found solution with 48 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=110.5s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 3, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 1, 2] → J=221, T=197, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 4, 3, 3, 2, 2, 1, 2] → J=219, T=200, cost=3 → queued

[Iter 30] cost=2, J=222, T=200, edges=34, frontier=72, MILP_calls=148
  V_MIN=[3, 2, 2, 4, 2, 2, 2, 4, 2, 2, 1, 2]
  [backtrack] Found solution with 50 backtracks in 0.00s
  [backtrack] Found solution with 246 backtracks in 0.00s
  [backtrack] Found solution with 265 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (246 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (289 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (367 backtracks in 0.00s)
  [backtrack] Found solution with 304 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (308 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (422 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (318 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (259 backtracks in 0.00s)
  [backtrack] Found solution with 202 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=106.6s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 9] → expanding 8 children
    V_MIN=[4, 2, 2, 4, 2, 2, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 2, 2, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 2, 2, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 5, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 31] cost=2, J=221, T=197, edges=34, frontier=71, MILP_calls=152
  V_MIN=[3, 2, 2, 3, 3, 2, 3, 3, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (135 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (218 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (108 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (209 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (293 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (290 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (213 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (140 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (159 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (216 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (68 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (136 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 6, 7, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 3, 2, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 4, 2, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 32] cost=2, J=220, T=198, edges=34, frontier=70, MILP_calls=154
  V_MIN=[3, 2, 3, 3, 2, 2, 2, 4, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (101 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (55 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (42 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (105 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (88 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (47 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (75 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (64 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (61 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (102 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7, 10] → expanding 7 children
    V_MIN=[4, 2, 3, 3, 2, 2, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 3, 2, 2, 2, 4, 2, 2, 1, 2] → J=220, T=199, cost=3 → queued
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 3, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 5, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 33] cost=2, J=219, T=200, edges=34, frontier=70, MILP_calls=159
  V_MIN=[3, 2, 2, 3, 2, 4, 2, 3, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (243 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (208 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (218 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (127 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (178 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (246 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (165 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (158 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (210 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (176 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (195 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 4, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 4, 2, 3, 2, 2, 1, 2] → J=219, T=199, cost=3 → queued
    V_MIN=[3, 2, 2, 3, 2, 5, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 4, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 34] cost=2, J=218, T=200, edges=34, frontier=70, MILP_calls=163
  V_MIN=[3, 2, 2, 3, 2, 3, 2, 4, 2, 2, 1, 2]
  [backtrack] Found solution with 518 backtracks in 0.00s
  [backtrack] Found solution with 572 backtracks in 0.00s
  [backtrack] Found solution with 266 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (260 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (560 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (477 backtracks in 0.00s)
  [backtrack] Found solution with 171 backtracks in 0.00s
  [backtrack] Found solution with 144 backtracks in 0.00s
  [backtrack] Found solution with 121 backtracks in 0.00s
  [backtrack] Found solution with 118 backtracks in 0.00s
  [backtrack] Found solution with 30 backtracks in 0.00s
  [backtrack] Found solution with 463 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=121.4s)
  Boundary nodes: [0, 2, 3, 4, 5, 7, 9] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 3, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 3, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 5, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 35] cost=2, J=215, T=200, edges=34, frontier=69, MILP_calls=166
  V_MIN=[4, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (766 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (249 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (151 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (389 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (370 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (355 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (210 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (117 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (278 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (225 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (449 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (701 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[5, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned

[Iter 36] cost=2, J=211, T=198, edges=34, frontier=68, MILP_calls=167
  V_MIN=[4, 2, 2, 3, 2, 2, 3, 3, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (212 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (144 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (89 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (177 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (176 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (83 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (132 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (188 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 9] → expanding 8 children
    V_MIN=[5, 2, 2, 3, 2, 2, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 37] cost=3, J=224, T=199, edges=35, frontier=67, MILP_calls=168
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 4, 2, 2]
  [backtrack] EXHAUSTED search space (970 backtracks in 0.00s)
  [backtrack] Found solution with 85 backtracks in 0.00s
  [backtrack] Found solution with 163 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (358 backtracks in 0.00s)
  [backtrack] Found solution with 85 backtracks in 0.00s
  [backtrack] Found solution with 142 backtracks in 0.00s
  [backtrack] Found solution with 142 backtracks in 0.00s
  [backtrack] Found solution with 94 backtracks in 0.00s
  [backtrack] Found solution with 134 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1004 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=126.5s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 9, 10] → expanding 9 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 3, 2, 4, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 3, 2, 4, 2, 2] → J=224, T=199, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 4, 2, 2] → J=223, T=199, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 4, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 4, 2, 2] → J=222, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 3, 2, 4, 2, 2] → J=223, T=199, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 4, 2, 2] → J=223, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 5, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 4, 3, 2] → J=223, T=198, cost=4 → queued

[Iter 38] cost=3, J=224, T=200, edges=35, frontier=72, MILP_calls=177
  V_MIN=[3, 2, 3, 3, 2, 2, 3, 3, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (189 backtracks in 0.00s)
  [backtrack] Found solution with 150 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (231 backtracks in 0.00s)
  [backtrack] Found solution with 275 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (212 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (122 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (177 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (268 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (81 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (86 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (190 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=122.0s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 3, 3, 2, 2, 3, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 3, 2, 2, 3, 3, 2, 3, 1, 2] → J=224, T=200, cost=4 → queued
    V_MIN=[3, 2, 3, 4, 2, 2, 3, 3, 2, 3, 1, 2] → J=221, T=197, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 3, 2, 3, 3, 2, 3, 1, 2] → J=220, T=200, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 3, 3, 3, 2, 3, 1, 2] → J=220, T=200, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 4, 3, 2, 3, 1, 2] → J=221, T=199, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 3, 4, 2, 3, 1, 2] → J=220, T=198, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 3, 3, 2, 3, 2, 2] → J=221, T=199, cost=4 → queued

[Iter 39] cost=3, J=224, T=200, edges=35, frontier=78, MILP_calls=185
  V_MIN=[3, 2, 3, 3, 2, 2, 2, 3, 2, 4, 1, 2]
  [backtrack] EXHAUSTED search space (366 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (330 backtracks in 0.00s)
  [backtrack] Found solution with 127 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (103 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (199 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (243 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (196 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (162 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (270 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (148 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=122.0s)
  Boundary nodes: [0, 2, 3, 4, 5, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 3, 3, 2, 2, 2, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 3, 2, 2, 2, 3, 2, 4, 1, 2] → J=224, T=200, cost=4 → queued
    V_MIN=[3, 2, 3, 4, 2, 2, 2, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 3, 2, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 4, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 3, 2, 5, 1, 2] → MILP infeasible, pruned

[Iter 40] cost=3, J=224, T=199, edges=35, frontier=78, MILP_calls=192
  V_MIN=[3, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2]
  [backtrack] EXHAUSTED search space (794 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (687 backtracks in 0.00s)
  [backtrack] Found solution with 252 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (213 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (251 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (387 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (468 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (363 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (451 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (630 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (463 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (313 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=121.3s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 3, 2, 2, 2, 3, 2, 3, 2, 2] → J=223, T=199, cost=4 → queued
    V_MIN=[3, 2, 3, 4, 2, 2, 2, 3, 2, 3, 2, 2] → J=221, T=196, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 3, 2, 3, 2, 2] → J=220, T=200, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 3, 2, 3, 2, 3, 2, 2] → J=220, T=200, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 4, 2, 3, 2, 2] → J=220, T=199, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 3, 2, 3, 3, 2] → J=221, T=198, cost=4 → queued

[Iter 41] cost=3, J=224, T=199, edges=34, frontier=83, MILP_calls=199
  V_MIN=[3, 2, 3, 4, 2, 2, 2, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 877 backtracks in 0.00s
  [backtrack] Found solution with 268 backtracks in 0.00s
  [backtrack] Found solution with 563 backtracks in 0.00s
  [backtrack] Found solution with 693 backtracks in 0.00s
  [backtrack] Found solution with 1024 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (481 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1394 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (476 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1192 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1212 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1050 backtracks in 0.00s)
  [backtrack] Found solution with 462 backtracks in 0.00s
  DFS: latency violated (3 nodes, worst_gap=117.2s)
  Boundary nodes: [0, 2, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 3, 4, 2, 2, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 4, 2, 2, 2, 3, 2, 2, 2, 2] → J=223, T=199, cost=4 → queued
    V_MIN=[3, 2, 3, 4, 3, 2, 2, 3, 2, 2, 2, 2] → J=224, T=199, cost=4 → queued
    V_MIN=[3, 2, 3, 4, 2, 3, 2, 3, 2, 2, 2, 2] → J=224, T=199, cost=4 → queued
    V_MIN=[3, 2, 3, 4, 2, 2, 3, 3, 2, 2, 2, 2] → J=220, T=199, cost=4 → queued
    V_MIN=[3, 2, 3, 4, 2, 2, 2, 4, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 2, 2, 2, 3, 2, 2, 3, 2] → J=220, T=198, cost=4 → queued

[Iter 42] cost=3, J=224, T=199, edges=34, frontier=87, MILP_calls=206
  V_MIN=[3, 2, 2, 5, 2, 2, 2, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 412 backtracks in 0.00s
  [backtrack] Found solution with 807 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (803 backtracks in 0.00s)
  [backtrack] Found solution with 681 backtracks in 0.00s
  [backtrack] Found solution with 559 backtracks in 0.00s
  [backtrack] Found solution with 633 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (607 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1482 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (624 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (963 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1059 backtracks in 0.00s)
  [backtrack] Found solution with 48 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=123.4s)
  Boundary nodes: [0, 3, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 5, 2, 2, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 6, 2, 2, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 3, 2, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 2, 3, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 2, 2, 3, 3, 2, 2, 2, 2] → J=222, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 5, 2, 2, 2, 4, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 2, 2, 2, 3, 2, 3, 2, 2] → J=222, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 5, 2, 2, 2, 3, 2, 2, 3, 2] → J=222, T=200, cost=4 → queued

[Iter 43] cost=3, J=224, T=199, edges=34, frontier=89, MILP_calls=214
  V_MIN=[3, 2, 3, 4, 3, 2, 2, 3, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (747 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (340 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (258 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (677 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (803 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (779 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (319 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (229 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (589 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (454 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (269 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (693 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 6, 7, 9] → expanding 7 children
    V_MIN=[4, 2, 3, 4, 3, 2, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 4, 3, 2, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 5, 3, 2, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 4, 2, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 3, 2, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 3, 2, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 3, 2, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned

[Iter 44] cost=3, J=224, T=199, edges=34, frontier=88, MILP_calls=221
  V_MIN=[3, 2, 3, 3, 3, 2, 2, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (747 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (340 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (258 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (677 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (803 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (779 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (319 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (229 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (589 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (454 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (269 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (693 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 3, 3, 3, 2, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 3, 3, 2, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 4, 2, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 3, 2, 3, 3, 2, 2, 2, 2] → J=216, T=199, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 4, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 3, 2, 2, 3, 2] → J=216, T=199, cost=4 → queued

[Iter 45] cost=3, J=224, T=199, edges=34, frontier=89, MILP_calls=227
  V_MIN=[3, 2, 3, 4, 2, 3, 2, 3, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (747 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (340 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (258 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (677 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (803 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (779 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (319 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (229 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (589 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (454 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (269 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (693 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 5, 6, 7, 9] → expanding 7 children
    V_MIN=[4, 2, 3, 4, 2, 3, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 4, 2, 3, 2, 3, 2, 2, 1, 2] → J=222, T=197, cost=4 → queued
    V_MIN=[3, 2, 3, 5, 2, 3, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 2, 4, 2, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 2, 3, 3, 3, 2, 2, 1, 2] → J=223, T=199, cost=4 → queued
    V_MIN=[3, 2, 3, 4, 2, 3, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 2, 3, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned

[Iter 46] cost=3, J=224, T=199, edges=34, frontier=90, MILP_calls=234
  V_MIN=[3, 2, 3, 3, 2, 3, 2, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (657 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (564 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (659 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (564 backtracks in 0.00s)
  [backtrack] Found solution with 118 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (458 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (266 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (588 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (263 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (278 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (458 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (530 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=106.4s)
  Boundary nodes: [0, 2, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 3, 3, 2, 3, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 3, 2, 3, 2, 3, 2, 2, 2, 2] → J=222, T=196, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 4, 2, 3, 2, 2, 2, 2] → J=219, T=199, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 3, 3, 3, 2, 2, 2, 2] → J=216, T=200, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 3, 2, 4, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 3, 2, 3, 2, 2, 3, 2] → J=218, T=199, cost=4 → queued

[Iter 47] cost=3, J=224, T=200, edges=35, frontier=93, MILP_calls=240
  V_MIN=[3, 2, 4, 3, 2, 2, 3, 3, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (116 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (52 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (115 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (39 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (54 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (53 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (165 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (98 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (154 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (209 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (95 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (149 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 4, 3, 2, 2, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 5, 3, 2, 2, 3, 3, 2, 2, 1, 2] → J=215, T=199, cost=4 → queued
    V_MIN=[3, 2, 4, 4, 2, 2, 3, 3, 2, 2, 1, 2] → J=223, T=200, cost=4 → queued
    V_MIN=[3, 2, 4, 3, 3, 2, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 3, 2, 3, 3, 3, 2, 2, 1, 2] → J=222, T=197, cost=4 → queued
    V_MIN=[3, 2, 4, 3, 2, 2, 4, 3, 2, 2, 1, 2] → J=222, T=200, cost=4 → queued
    V_MIN=[3, 2, 4, 3, 2, 2, 3, 4, 2, 2, 1, 2] → J=220, T=199, cost=4 → queued
    V_MIN=[3, 2, 4, 3, 2, 2, 3, 3, 2, 2, 2, 2] → J=220, T=199, cost=4 → queued

[Iter 48] cost=3, J=223, T=200, edges=34, frontier=98, MILP_calls=248
  V_MIN=[3, 2, 3, 4, 2, 2, 3, 3, 2, 2, 1, 2]
  [backtrack] Found solution with 110 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 174 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (204 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (327 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (344 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (246 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (285 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (117 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (154 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  [backtrack] Found solution with 169 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=106.1s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 3, 4, 2, 2, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 2, 2, 4, 3, 2, 2, 1, 2] → J=222, T=200, cost=4 → queued
    V_MIN=[3, 2, 3, 4, 2, 2, 3, 4, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 49] cost=3, J=223, T=199, edges=35, frontier=98, MILP_calls=251
  V_MIN=[3, 2, 4, 3, 2, 2, 2, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (142 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (61 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (89 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (101 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (60 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (64 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (59 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (108 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (90 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 4, 3, 2, 2, 2, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 5, 3, 2, 2, 2, 3, 2, 2, 2, 2] → J=220, T=197, cost=4 → queued
    V_MIN=[3, 2, 4, 3, 2, 2, 2, 4, 2, 2, 2, 2] → J=220, T=198, cost=4 → queued
    V_MIN=[3, 2, 4, 3, 2, 2, 2, 3, 2, 2, 3, 2] → J=220, T=198, cost=4 → queued

[Iter 50] cost=3, J=223, T=200, edges=35, frontier=100, MILP_calls=255
  V_MIN=[3, 2, 2, 4, 2, 2, 3, 3, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (591 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (565 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (320 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (271 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (547 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (354 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (155 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (359 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (499 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (561 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (332 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (488 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 4, 2, 2, 3, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 2, 2, 3, 3, 2, 3, 1, 2] → J=222, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 3, 2, 3, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 3, 3, 3, 2, 3, 1, 2] → J=220, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 3, 4, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 2, 3, 3, 2, 3, 2, 2] → J=223, T=200, cost=4 → queued

[Iter 51] cost=3, J=223, T=200, edges=35, frontier=102, MILP_calls=261
  V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 4, 1, 2]
  [backtrack] EXHAUSTED search space (260 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (156 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (161 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (129 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (228 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (196 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (281 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (140 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (281 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (85 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (245 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 4, 2, 2, 2, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 2, 2, 2, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 3, 2, 2, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 3, 2, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 4, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 5, 1, 2] → MILP infeasible, pruned

[Iter 52] cost=3, J=223, T=200, edges=35, frontier=101, MILP_calls=267
  V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 3, 2, 2]
  [backtrack] Found solution with 239 backtracks in 0.00s
  [backtrack] Found solution with 226 backtracks in 0.00s
  [backtrack] Found solution with 671 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (632 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (960 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1149 backtracks in 0.00s)
  [backtrack] Found solution with 489 backtracks in 0.00s
  [backtrack] Found solution with 517 backtracks in 0.00s
  [backtrack] Found solution with 383 backtracks in 0.00s
  [backtrack] Found solution with 55 backtracks in 0.00s
  [backtrack] Found solution with 24 backtracks in 0.00s
  [backtrack] Found solution with 221 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=119.5s)
  Boundary nodes: [0, 2, 3, 4, 5, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 4, 2, 2, 2, 3, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 3, 2, 2, 3, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 3, 2, 3, 2, 3, 2, 2] → J=220, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 4, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 3, 3, 2] → J=223, T=199, cost=4 → queued

[Iter 53] cost=3, J=223, T=200, edges=35, frontier=102, MILP_calls=272
  V_MIN=[3, 2, 2, 3, 2, 2, 4, 3, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (542 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (435 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (429 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (295 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (342 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (142 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (331 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (448 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (729 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (204 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (266 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (361 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 6, 7, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 2, 4, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 4, 3, 2, 3, 1, 2] → J=216, T=198, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 4, 3, 2, 3, 1, 2] → J=217, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 5, 3, 2, 3, 1, 2] → J=218, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 4, 4, 2, 3, 1, 2] → J=216, T=199, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 4, 3, 2, 3, 2, 2] → J=222, T=200, cost=4 → queued

[Iter 54] cost=3, J=223, T=200, edges=35, frontier=106, MILP_calls=278
  V_MIN=[3, 2, 2, 3, 2, 2, 3, 3, 2, 3, 2, 2]
  [backtrack] Found solution with 676 backtracks in 0.00s
  [backtrack] Found solution with 127 backtracks in 0.00s
  [backtrack] Found solution with 1251 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1302 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1927 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1095 backtracks in 0.00s)
  [backtrack] Found solution with 310 backtracks in 0.00s
  [backtrack] Found solution with 807 backtracks in 0.00s
  [backtrack] Found solution with 884 backtracks in 0.00s
  [backtrack] Found solution with 79 backtracks in 0.00s
  [backtrack] Found solution with 148 backtracks in 0.00s
  [backtrack] Found solution with 851 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=107.9s)
  Boundary nodes: [0, 2, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 2, 3, 3, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 3, 3, 2, 3, 2, 2] → J=218, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 3, 3, 2, 3, 2, 2] → J=220, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 4, 2, 3, 2, 2] → J=223, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 3, 2, 3, 3, 2] → J=221, T=199, cost=4 → queued

[Iter 55] cost=3, J=223, T=200, edges=35, frontier=109, MILP_calls=283
  V_MIN=[3, 2, 2, 4, 2, 2, 3, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 110 backtracks in 0.00s
  [backtrack] Found solution with 135 backtracks in 0.00s
  [backtrack] Found solution with 201 backtracks in 0.00s
  [backtrack] Found solution with 170 backtracks in 0.00s
  [backtrack] Found solution with 483 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (2476 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (931 backtracks in 0.00s)
  [backtrack] Found solution with 694 backtracks in 0.00s
  [backtrack] Found solution with 582 backtracks in 0.00s
  [backtrack] Found solution with 130 backtracks in 0.00s
  [backtrack] Found solution with 761 backtracks in 0.00s
  [backtrack] Found solution with 94 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=101.3s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 4, 2, 2, 3, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 3, 2, 3, 3, 2, 2, 2, 2] → J=220, T=198, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 3, 3, 3, 2, 2, 2, 2] → J=220, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 4, 3, 2, 2, 2, 2] → J=222, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 3, 4, 2, 2, 2, 2] → J=221, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 3, 3, 2, 2, 3, 2] → J=222, T=200, cost=4 → queued

[Iter 56] cost=3, J=223, T=200, edges=35, frontier=113, MILP_calls=289
  V_MIN=[3, 2, 2, 4, 2, 2, 4, 3, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (591 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (565 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (320 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (271 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (547 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (354 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (155 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (359 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (499 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (561 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (332 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (488 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 4, 2, 2, 4, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 2, 2, 4, 3, 2, 2, 1, 2] → J=222, T=199, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 3, 2, 4, 3, 2, 2, 1, 2] → J=213, T=198, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 3, 4, 3, 2, 2, 1, 2] → J=218, T=199, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 5, 3, 2, 2, 1, 2] → J=222, T=199, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 4, 4, 2, 2, 1, 2] → J=221, T=200, cost=4 → queued

[Iter 57] cost=3, J=223, T=200, edges=35, frontier=117, MILP_calls=295
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 3, 3, 2]
  [backtrack] Found solution with 150 backtracks in 0.00s
  [backtrack] Found solution with 23 backtracks in 0.00s
  [backtrack] Found solution with 472 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (461 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (664 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (357 backtracks in 0.00s)
  [backtrack] Found solution with 395 backtracks in 0.00s
  [backtrack] Found solution with 205 backtracks in 0.00s
  [backtrack] Found solution with 193 backtracks in 0.00s
  [backtrack] Found solution with 193 backtracks in 0.00s
  [backtrack] Found solution with 158 backtracks in 0.00s
  [backtrack] Found solution with 151 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=119.7s)
  Boundary nodes: [0, 2, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 3, 2, 3, 3, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 3, 3, 2] → J=218, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 3, 3, 2] → J=222, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 3, 3, 2] → J=223, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 3, 4, 2] → J=218, T=200, cost=4 → queued

[Iter 58] cost=3, J=223, T=200, edges=35, frontier=120, MILP_calls=300
  V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 2, 3, 2]
  [backtrack] Found solution with 1167 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1187 backtracks in 0.00s)
  [backtrack] Found solution with 289 backtracks in 0.00s
  [backtrack] Found solution with 330 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1760 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1478 backtracks in 0.00s)
  [backtrack] Found solution with 390 backtracks in 0.00s
  [backtrack] Found solution with 425 backtracks in 0.00s
  [backtrack] Found solution with 360 backtracks in 0.00s
  [backtrack] Found solution with 299 backtracks in 0.00s
  [backtrack] Found solution with 754 backtracks in 0.00s
  [backtrack] Found solution with 832 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=119.6s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 4, 2, 2, 2, 3, 2, 2, 3, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 3, 2] → J=219, T=197, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 3, 2, 3, 2, 2, 3, 2] → J=220, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 4, 2, 2, 3, 2] → J=221, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 3, 2, 2, 4, 2] → J=221, T=200, cost=4 → queued

[Iter 59] cost=3, J=223, T=200, edges=35, frontier=123, MILP_calls=305
  V_MIN=[3, 2, 2, 3, 2, 2, 3, 4, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (129 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (55 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (108 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (215 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (66 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 2, 3, 4, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 3, 4, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 3, 3, 4, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 5, 2, 3, 1, 2] → MILP infeasible, pruned

[Iter 60] cost=3, J=223, T=200, edges=35, frontier=122, MILP_calls=309
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 4, 1, 2]
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (129 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (55 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (108 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (215 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (66 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7, 9] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 4, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 4, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 4, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 5, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 5, 1, 2] → MILP infeasible, pruned

[Iter 61] cost=3, J=223, T=200, edges=35, frontier=121, MILP_calls=314
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 3, 2, 2]
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (129 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (55 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (108 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (215 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (66 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 4, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 4, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 4, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 5, 2, 3, 2, 2] → MILP infeasible, pruned

[Iter 62] cost=3, J=223, T=200, edges=35, frontier=120, MILP_calls=318
  V_MIN=[3, 2, 2, 3, 2, 2, 3, 4, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (129 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (55 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (108 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (215 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (66 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 2, 3, 4, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 3, 4, 2, 2, 2, 2] → J=216, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 3, 2, 3, 4, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 3, 3, 4, 2, 2, 2, 2] → J=218, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 4, 4, 2, 2, 2, 2] → J=221, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 5, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 4, 2, 2, 3, 2] → J=218, T=200, cost=4 → queued

[Iter 63] cost=3, J=223, T=200, edges=35, frontier=123, MILP_calls=325
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 2, 3, 2]
  [backtrack] Found solution with 156 backtracks in 0.00s
  [backtrack] Found solution with 147 backtracks in 0.00s
  [backtrack] Found solution with 285 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (304 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (562 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (734 backtracks in 0.00s)
  [backtrack] Found solution with 171 backtracks in 0.00s
  [backtrack] Found solution with 317 backtracks in 0.00s
  [backtrack] Found solution with 434 backtracks in 0.00s
  [backtrack] Found solution with 140 backtracks in 0.00s
  [backtrack] Found solution with 247 backtracks in 0.00s
  [backtrack] Found solution with 252 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=137.4s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 4, 2, 2, 3, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 4, 2, 2, 3, 2] → J=216, T=199, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 4, 2, 2, 3, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 4, 2, 2, 3, 2] → J=218, T=199, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 5, 2, 2, 3, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 4, 2, 2, 4, 2] → J=221, T=200, cost=4 → queued

[Iter 64] cost=3, J=223, T=199, edges=34, frontier=125, MILP_calls=331
  V_MIN=[3, 2, 2, 4, 2, 3, 3, 3, 2, 2, 1, 2]
  [backtrack] Found solution with 318 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 334 backtracks in 0.00s
  [backtrack] Found solution with 336 backtracks in 0.00s
  [backtrack] Found solution with 365 backtracks in 0.00s
  [backtrack] Found solution with 184 backtracks in 0.00s
  [backtrack] Found solution with 93 backtracks in 0.00s
  [backtrack] Found solution with 1608 backtracks in 0.00s
  [backtrack] Found solution with 130 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (743 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (825 backtracks in 0.00s)
  [backtrack] Found solution with 330 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=105.3s)
  Boundary nodes: [0, 3, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 4, 2, 3, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 2, 3, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 3, 3, 3, 3, 2, 2, 1, 2] → J=220, T=198, cost=4 → queued
    V_MIN=[3, 2, 2, 4, 2, 4, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 3, 3, 4, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 65] cost=3, J=223, T=199, edges=34, frontier=125, MILP_calls=336
  V_MIN=[3, 2, 3, 3, 2, 3, 3, 3, 2, 2, 1, 2]
  [backtrack] Found solution with 271 backtracks in 0.00s
  [backtrack] Found solution with 387 backtracks in 0.00s
  [backtrack] Found solution with 596 backtracks in 0.00s
  [backtrack] Found solution with 515 backtracks in 0.00s
  [backtrack] Found solution with 423 backtracks in 0.00s
  [backtrack] Found solution with 396 backtracks in 0.00s
  [backtrack] Found solution with 886 backtracks in 0.00s
  [backtrack] Found solution with 474 backtracks in 0.00s
  [backtrack] Found solution with 421 backtracks in 0.00s
  [backtrack] Found solution with 356 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (626 backtracks in 0.00s)
  [backtrack] Found solution with 48 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=110.5s)
  Boundary nodes: [0, 2, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 3, 3, 2, 3, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 3, 3, 3, 3, 2, 2, 1, 2] → J=220, T=200, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 4, 3, 3, 2, 2, 1, 2] → J=219, T=200, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 3, 4, 3, 2, 2, 1, 2] → J=218, T=200, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 3, 3, 4, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 66] cost=3, J=222, T=200, edges=35, frontier=127, MILP_calls=341
  V_MIN=[3, 2, 3, 3, 2, 2, 4, 3, 2, 2, 1, 2]
  [backtrack] Found solution with 347 backtracks in 0.00s
  [backtrack] Found solution with 477 backtracks in 0.00s
  [backtrack] Found solution with 642 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (470 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (604 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (644 backtracks in 0.00s)
  [backtrack] Found solution with 156 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (509 backtracks in 0.00s)
  [backtrack] Found solution with 125 backtracks in 0.00s
  [backtrack] Found solution with 81 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (177 backtracks in 0.00s)
  [backtrack] Found solution with 130 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=130.3s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 3, 3, 2, 2, 4, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 3, 2, 4, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 5, 3, 2, 2, 1, 2] → J=218, T=199, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 4, 4, 2, 2, 1, 2] → J=216, T=197, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 4, 3, 2, 2, 2, 2] → J=221, T=199, cost=4 → queued

[Iter 67] cost=3, J=222, T=200, edges=34, frontier=129, MILP_calls=346
  V_MIN=[3, 2, 2, 4, 2, 2, 2, 4, 2, 2, 2, 2]
  [backtrack] Found solution with 50 backtracks in 0.00s
  [backtrack] Found solution with 246 backtracks in 0.00s
  [backtrack] Found solution with 265 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (246 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (289 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (367 backtracks in 0.00s)
  [backtrack] Found solution with 304 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (308 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (422 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (318 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (259 backtracks in 0.00s)
  [backtrack] Found solution with 202 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=106.6s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 9, 10] → expanding 9 children
    V_MIN=[4, 2, 2, 4, 2, 2, 2, 4, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 3, 2, 2, 4, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 3, 2, 4, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 2, 2, 5, 2, 2, 2, 2] → MILP infeasible, pruned

[Iter 68] cost=3, J=222, T=200, edges=35, frontier=128, MILP_calls=350
  V_MIN=[3, 2, 2, 3, 2, 2, 5, 3, 2, 2, 1, 2]
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 160 backtracks in 0.00s
  [backtrack] Found solution with 149 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (587 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (499 backtracks in 0.00s)
  [backtrack] Found solution with 149 backtracks in 0.00s
  [backtrack] Found solution with 219 backtracks in 0.00s
  [backtrack] Found solution with 42 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 44 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=121.3s)
  Boundary nodes: [0, 2, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 2, 5, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 5, 3, 2, 2, 1, 2] → J=205, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 5, 3, 2, 2, 1, 2] → J=214, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 6, 3, 2, 2, 1, 2] → J=208, T=199, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 5, 4, 2, 2, 1, 2] → J=212, T=199, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 5, 3, 2, 2, 2, 2] → J=217, T=197, cost=4 → queued

[Iter 69] cost=3, J=222, T=200, edges=35, frontier=132, MILP_calls=356
  V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 4, 1, 2]
  [backtrack] EXHAUSTED search space (199 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (179 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (170 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (133 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (149 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (120 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (174 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (206 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (175 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (159 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 9] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 3, 2, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 3, 2, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 4, 2, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 3, 3, 3, 2, 4, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 5, 1, 2] → MILP infeasible, pruned

[Iter 70] cost=3, J=222, T=200, edges=35, frontier=131, MILP_calls=361
  V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 2]
  [backtrack] EXHAUSTED search space (199 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (179 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (170 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (133 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (149 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (120 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (174 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (206 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (175 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (159 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 3, 2, 3, 2, 3, 2, 2] → J=221, T=197, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 4, 2, 3, 2, 3, 2, 2] → MILP infeasible, pruned

[Iter 71] cost=3, J=222, T=200, edges=35, frontier=131, MILP_calls=364
  V_MIN=[3, 2, 2, 5, 2, 2, 2, 3, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (229 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (465 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (132 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (387 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (218 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (187 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (154 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (387 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (283 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (171 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7, 9] → expanding 7 children
    V_MIN=[4, 2, 2, 5, 2, 2, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 5, 2, 2, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 6, 2, 2, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 3, 2, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 2, 3, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 2, 2, 2, 4, 2, 3, 1, 2] → MILP infeasible, pruned

[Iter 72] cost=3, J=222, T=200, edges=35, frontier=130, MILP_calls=370
  V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (199 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (179 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (170 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (133 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (149 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (120 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (174 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (206 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (175 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (159 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 3, 2, 3, 2, 2, 3, 2] → J=219, T=197, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 4, 2, 3, 2, 2, 3, 2] → J=215, T=198, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 3, 3, 2, 2, 3, 2] → J=220, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 2, 3, 2, 2, 4, 2] → J=212, T=198, cost=4 → queued

[Iter 73] cost=3, J=222, T=200, edges=35, frontier=133, MILP_calls=375
  V_MIN=[3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (229 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (465 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (132 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (387 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (218 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (187 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (154 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (387 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (283 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (171 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 6, 7, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 2, 4, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 4, 3, 2, 2, 2, 2] → J=212, T=199, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 3, 4, 3, 2, 2, 2, 2] → J=217, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2] → J=220, T=200, cost=4 → queued

[Iter 74] cost=3, J=222, T=200, edges=35, frontier=135, MILP_calls=379
  V_MIN=[3, 2, 2, 3, 2, 2, 3, 3, 2, 2, 3, 2]
  [backtrack] Found solution with 151 backtracks in 0.00s
  [backtrack] Found solution with 54 backtracks in 0.00s
  [backtrack] Found solution with 213 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (169 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (260 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (312 backtracks in 0.00s)
  [backtrack] Found solution with 299 backtracks in 0.00s
  [backtrack] Found solution with 171 backtracks in 0.00s
  [backtrack] Found solution with 183 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (179 backtracks in 0.00s)
  [backtrack] Found solution with 101 backtracks in 0.00s
  [backtrack] Found solution with 85 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=119.7s)
  Boundary nodes: [0, 2, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 2, 3, 3, 2, 2, 3, 2] → J=206, T=198, cost=4 → queued
    V_MIN=[3, 2, 3, 3, 2, 2, 3, 3, 2, 2, 3, 2] → J=221, T=198, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 3, 2, 3, 3, 2, 2, 3, 2] → J=218, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 3, 2, 2, 4, 2] → J=216, T=200, cost=4 → queued

[Iter 75] cost=3, J=221, T=200, edges=35, frontier=138, MILP_calls=383
  V_MIN=[3, 2, 2, 4, 2, 2, 3, 4, 2, 2, 1, 2]
  [backtrack] Found solution with 223 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (167 backtracks in 0.00s)
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (320 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (264 backtracks in 0.00s)
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 145 backtracks in 0.00s
  [backtrack] Found solution with 188 backtracks in 0.00s
  [backtrack] Found solution with 160 backtracks in 0.00s
  [backtrack] Found solution with 157 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=122.0s)
  Boundary nodes: [0, 2, 3, 4, 5, 7, 9] → expanding 7 children
    V_MIN=[4, 2, 2, 4, 2, 2, 3, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 5, 2, 2, 3, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 3, 2, 3, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 2, 3, 5, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 76] cost=3, J=221, T=200, edges=35, frontier=137, MILP_calls=387
  V_MIN=[3, 2, 2, 3, 2, 2, 4, 4, 2, 2, 1, 2]
  [backtrack] Found solution with 36 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (85 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  [backtrack] Found solution with 175 backtracks in 0.00s
  [backtrack] Found solution with 139 backtracks in 0.00s
  [backtrack] Found solution with 79 backtracks in 0.00s
  [backtrack] Found solution with 68 backtracks in 0.00s
  [backtrack] Found solution with 42 backtracks in 0.00s
  [backtrack] Found solution with 59 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=109.3s)
  Boundary nodes: [0, 2, 4, 5, 6, 7, 9] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 2, 4, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 4, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 3, 4, 4, 2, 2, 1, 2] → J=212, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 4, 5, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 77] cost=3, J=221, T=200, edges=35, frontier=137, MILP_calls=391
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 4, 2]
  [backtrack] Found solution with 61 backtracks in 0.00s
  [backtrack] Found solution with 76 backtracks in 0.00s
  [backtrack] Found solution with 168 backtracks in 0.00s
  [backtrack] Found solution with 100 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (305 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (299 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (132 backtracks in 0.00s)
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 81 backtracks in 0.00s
  [backtrack] Found solution with 61 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 55 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=127.0s)
  Boundary nodes: [0, 2, 4, 5, 6, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 3, 2, 2, 2, 3, 2, 2, 4, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 3, 2, 2, 4, 2] → J=216, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 2, 4, 2] → J=212, T=199, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 5, 2] → J=206, T=199, cost=4 → queued

[Iter 78] cost=3, J=221, T=199, edges=36, frontier=139, MILP_calls=395
  V_MIN=[3, 2, 3, 3, 2, 2, 3, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 70 backtracks in 0.00s
  [backtrack] Found solution with 70 backtracks in 0.00s
  [backtrack] Found solution with 80 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (133 backtracks in 0.00s)
  [backtrack] Found solution with 32 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (72 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (144 backtracks in 0.00s)
  [backtrack] Found solution with 182 backtracks in 0.00s
  [backtrack] Found solution with 66 backtracks in 0.00s
  [backtrack] Found solution with 70 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=131.2s)
  Boundary nodes: [0, 2, 3, 4, 5, 7, 10] → expanding 7 children
    V_MIN=[4, 2, 3, 3, 2, 2, 3, 3, 2, 2, 2, 2] → MILP infeasible, pruned

[Iter 79] cost=3, J=221, T=198, edges=36, frontier=138, MILP_calls=396
  V_MIN=[3, 2, 3, 3, 2, 2, 2, 3, 2, 2, 3, 2]
  [backtrack] Found solution with 130 backtracks in 0.00s
  [backtrack] Found solution with 130 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (172 backtracks in 0.00s)
  [backtrack] Found solution with 40 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (89 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (87 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 8 backtracks in 0.00s
  [backtrack] Found solution with 8 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 89 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=120.8s)
  Boundary nodes: [0, 2, 3, 4, 5, 7, 10] → expanding 7 children
    V_MIN=[4, 2, 3, 3, 2, 2, 2, 3, 2, 2, 3, 2] → MILP infeasible, pruned

[Iter 80] cost=3, J=221, T=197, edges=34, frontier=137, MILP_calls=397
  V_MIN=[3, 2, 2, 3, 3, 2, 3, 3, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (358 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (355 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (128 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (127 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (204 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (272 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (182 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (254 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (55 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (236 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (115 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 3, 2, 3, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 4, 2, 3, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 2, 3, 3, 2, 4, 1, 2] → MILP infeasible, pruned

[Iter 81] cost=3, J=221, T=198, edges=34, frontier=136, MILP_calls=400
  V_MIN=[3, 2, 2, 3, 2, 3, 3, 3, 2, 3, 1, 2]
  [backtrack] Found solution with 98 backtracks in 0.00s
  [backtrack] Found solution with 233 backtracks in 0.00s
  [backtrack] Found solution with 116 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (156 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (222 backtracks in 0.00s)
  [backtrack] Found solution with 203 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (258 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (242 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (281 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (174 backtracks in 0.00s)
  [backtrack] Found solution with 102 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=106.9s)
  Boundary nodes: [0, 2, 3, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 2, 3, 3, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 4, 3, 3, 2, 3, 1, 2] → MILP infeasible, pruned

[Iter 82] cost=3, J=221, T=197, edges=34, frontier=135, MILP_calls=402
  V_MIN=[3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (358 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (355 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (128 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (127 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (204 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (272 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (182 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (254 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (55 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (236 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (115 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 3, 3, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 4, 3, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 4, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 3, 4, 3, 2, 2, 1, 2] → J=216, T=200, cost=4 → queued
    V_MIN=[3, 2, 2, 3, 3, 3, 3, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 2, 2] → J=220, T=198, cost=4 → queued

[Iter 83] cost=3, J=221, T=198, edges=34, frontier=136, MILP_calls=408
  V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 3, 2, 2]
  [backtrack] Found solution with 159 backtracks in 0.00s
  [backtrack] Found solution with 396 backtracks in 0.00s
  [backtrack] Found solution with 185 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (271 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (392 backtracks in 0.00s)
  [backtrack] Found solution with 348 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (117 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (306 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (467 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (507 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (402 backtracks in 0.00s)
  [backtrack] Found solution with 165 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=106.9s)
  Boundary nodes: [0, 2, 3, 4, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 2, 3, 3, 2, 2, 3, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 4, 2, 2, 3, 2, 3, 2, 2] → MILP infeasible, pruned

[Iter 84] cost=3, J=220, T=200, edges=34, frontier=135, MILP_calls=410
  V_MIN=[3, 2, 3, 3, 3, 2, 3, 3, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (23 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (45 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (16 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (42 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (43 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (44 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (39 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (40 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (21 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (22 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (17 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (24 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 6, 7, 10] → expanding 7 children
    V_MIN=[4, 2, 3, 3, 3, 2, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 4, 2, 3, 3, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 3, 2, 3, 4, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 85] cost=3, J=220, T=200, edges=34, frontier=134, MILP_calls=413
  V_MIN=[3, 2, 3, 3, 2, 2, 3, 4, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (178 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (137 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (72 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (116 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (35 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (47 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (71 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (136 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 10] → expanding 8 children
    V_MIN=[4, 2, 3, 3, 2, 2, 3, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 3, 5, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 86] cost=3, J=220, T=199, edges=34, frontier=133, MILP_calls=415
  V_MIN=[3, 2, 3, 3, 2, 2, 2, 4, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (122 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (105 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (75 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (56 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (57 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (44 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (45 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (24 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (38 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (107 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (122 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 9, 10] → expanding 9 children
    V_MIN=[4, 2, 3, 3, 2, 2, 2, 4, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 5, 2, 2, 2, 2] → MILP infeasible, pruned

[Iter 87] cost=3, J=220, T=200, edges=34, frontier=132, MILP_calls=417
  V_MIN=[3, 2, 3, 3, 2, 2, 2, 4, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (178 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (137 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (72 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (116 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (35 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (47 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (71 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (136 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 3, 3, 2, 2, 2, 4, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 3, 2, 2, 2, 4, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 4, 2, 2, 2, 4, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 4, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 3, 2, 4, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 5, 2, 3, 1, 2] → MILP infeasible, pruned

[Iter 88] cost=3, J=220, T=200, edges=35, frontier=131, MILP_calls=423
  V_MIN=[3, 2, 2, 4, 2, 3, 2, 3, 2, 3, 1, 2]
  [backtrack] EXHAUSTED search space (189 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (144 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (208 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (85 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (176 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (115 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (153 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (128 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (88 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7, 9] → expanding 7 children
    V_MIN=[4, 2, 2, 4, 2, 3, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 3, 3, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 4, 2, 3, 2, 3, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 4, 2, 3, 2, 4, 2, 3, 1, 2] → MILP infeasible, pruned

[Iter 89] cost=3, J=220, T=200, edges=35, frontier=130, MILP_calls=427
  V_MIN=[3, 2, 2, 3, 2, 3, 3, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (168 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (131 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (82 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (137 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (196 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (148 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (114 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (115 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (95 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (89 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (163 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 6, 7] → expanding 6 children
    V_MIN=[4, 2, 2, 3, 2, 3, 3, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 3, 2, 4, 3, 3, 2, 2, 2, 2] → J=215, T=198, cost=4 → queued

[Iter 90] cost=3, J=220, T=199, edges=34, frontier=130, MILP_calls=429
  V_MIN=[3, 2, 4, 3, 2, 2, 2, 4, 2, 2, 1, 2]
  [backtrack] EXHAUSTED search space (306 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (178 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (217 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (274 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (207 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (199 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (93 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (214 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (266 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (220 backtracks in 0.00s)
  [backtrack] Found solution with 151 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (274 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=106.8s)
  Boundary nodes: [0, 2, 3, 4, 5, 7, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 4, 3, 2, 2, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 5, 3, 2, 2, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 4, 2, 2, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 3, 3, 2, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 3, 2, 3, 2, 4, 2, 2, 1, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 3, 2, 2, 2, 5, 2, 2, 1, 2] → MILP infeasible, pruned

[Iter 91] cost=3, J=220, T=198, edges=34, frontier=129, MILP_calls=435
  V_MIN=[3, 2, 2, 4, 3, 2, 3, 3, 2, 2, 1, 2]
  [backtrack] Found solution with 308 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=197.6s
  *** SOLUTION FOUND! J=220, T_tour=197.6s ***

============================================================
Search done: 91 iters, 435 MILP calls, 435 states visited

Original flow_B is latency-feasible ✓
  flow_B = [3, -3, 0, 1, 2, -2, 1, 1, -3, 2, 0, -3, -1, -1, 2, 0, -3, 2, -2, 0, 0, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [3, -3, 0, 1, 2, -2, 1, 1, -3, 2, 0, -3, -1, -1, 2, 0, -3, 2, -2, 0, 0, 2]
  Non-zero edges: [((0, 1), np.int64(3)), ((0, 11), np.int64(-3)), ((1, 3), np.int64(1)), ((1, 5), np.int64(2)), ((2, 3), np.int64(-2)), ((2, 8), np.int64(1)), ((2, 11), np.int64(1)), ((3, 4), np.int64(-3)), ((3, 6), np.int64(2)), ((4, 5), np.int64(-3)), ((5, 6), np.int64(-1)), ((6, 7), np.int64(-1)), ((6, 9), np.int64(2)), ((7, 8), np.int64(-3)), ((7, 10), np.int64(2)), ((8, 9), np.int64(-2)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=13, edge=(6, 7), flow_B=-1  →  need Cm[13]=1
Blocked edge 2: idx=11, edge=(4, 5), flow_B=-3  →  need Cm[11]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=35   ||Cm||_1=19

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, 0, 1, 0, 1, 2, 1, 1, -1, 1, 2]

Cm = C_oriented @ beta*:
  [1, -1, 0, 2, -1, 0, 0, 0, 3, 0, -1, 3, 2, 1, 1, 0, 0, 1, -1, 0, 0, 1]

Original flow_B:
  [3, -3, 0, 1, 2, -2, 1, 1, -3, 2, 0, -3, -1, -1, 2, 0, -3, 2, -2, 0, 0, 2]

flow_B + Cm (corrected flow):
  [4, -4, 0, 3, 1, -2, 1, 1, 0, 2, -1, 0, 1, 0, 3, 0, -3, 3, -3, 0, 0, 3]

Verification:
  flow_corrected[13] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[11] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 35  (minimized by MIQP)
  ||Cm||_1  = 19
  ||flow_B||_2² = 78
  ||flow_corrected||_2² = 99

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         3       1           4    6.7     +6.7s
    1     (0, 11)        -3      -1          -4    5.8     +5.8s
    2      (1, 2)         0       0           0    6.2          
    3      (1, 3)         1       2           3    6.8    +13.6s
    4      (1, 5)         2      -1           1    6.4     -6.4s
    5      (2, 3)        -2       0          -2    4.2          
    6      (2, 8)         1       0           1    6.2          
    7     (2, 11)         1       0           1    7.1          
    8      (3, 4)        -3       3           0    7.6    -22.8s
    9      (3, 6)         2       0           2    4.4          
   10      (3, 8)         0      -1          -1    7.6     +7.6s
   11      (4, 5)        -3       3           0    5.8    -17.4s ← BLOCKED
   12      (5, 6)        -1       2           1    5.8          
   13      (6, 7)        -1       1           0    8.0     -8.0s ← BLOCKED
   14      (6, 9)         2       1           3    4.6     +4.6s
   15     (6, 10)         0       0           0    6.8          
   16      (7, 8)        -3       0          -3    4.6          
   17     (7, 10)         2       1           3    7.2     +7.2s
   18      (8, 9)        -2      -1          -3    4.1     +4.1s
   19     (8, 11)         0       0           0    6.1          
   20     (9, 10)         0       0           0    4.7          
   21    (10, 11)         2       1           3    5.2     +5.2s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=4, out=4  OK
  Node 1: in=4, out=4  OK
  Node 2: in=2, out=2  OK
  Node 3: in=4, out=4  OK
  Node 5: in=1, out=1  OK
  Node 6: in=3, out=3  OK
  Node 7: in=3, out=3  OK
  Node 8: in=4, out=4  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 20

  Summary:
    Original path length:  34 edges
    Spliced path length:   35 edges
    Splices performed:     20
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           4         4  ✓
    1     (0, 11)          -4        -4  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)           3         3  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)           1         1  ✓
    7     (2, 11)           1         1  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)           2         2  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           3         3  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)          -3        -3  ✓
   17     (7, 10)           3         3  ✓
   18      (8, 9)          -3        -3  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)           3         3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 33
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 3, 2, 1, 3, 2, 2, 3, 2] → J=207, T=199, cost=0 → queued

[Iter 1] cost=0, J=207, T=199, edges=36, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 3, 2, 1, 3, 2, 2, 3, 2]
  [backtrack] Found solution with 40 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.1s
  *** SOLUTION FOUND! J=207, T_tour=199.1s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 2, 0, 0, 2, 0, 0, 3, -1, 0, 3, 3, -2, 0, 4, 2, -4, 2, 0, 2, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 2, 0, 0, 2, 0, 0, 3, -1, 0, 3, 3, -2, 0, 4, 2, -4, 2, 0, 2, 2]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(2)), ((2, 3), np.int64(2)), ((3, 4), np.int64(3)), ((3, 6), np.int64(-1)), ((4, 5), np.int64(3)), ((5, 6), np.int64(3)), ((6, 7), np.int64(-2)), ((6, 10), np.int64(4)), ((7, 8), np.int64(2)), ((7, 10), np.int64(-4)), ((8, 9), np.int64(2)), ((9, 10), np.int64(2)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=13, edge=(6, 7), flow_B=-2  →  need Cm[13]=2
Blocked edge 2: idx=0, edge=(0, 1), flow_B=2  →  need Cm[0]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=25   ||Cm||_1=17

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 1, -1, 1, -1, 0, -2, 1, 0, 0, 0]

Cm = C_oriented @ beta*:
  [-2, 2, -1, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, 2, 0, -2, 1, 1, 1, -1, 1, 0]

Original flow_B:
  [2, -2, 2, 0, 0, 2, 0, 0, 3, -1, 0, 3, 3, -2, 0, 4, 2, -4, 2, 0, 2, 2]

flow_B + Cm (corrected flow):
  [0, 0, 1, -1, 0, 2, 0, -1, 3, -1, -1, 3, 3, 0, 0, 2, 3, -3, 3, -1, 3, 2]

Verification:
  flow_corrected[13] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[0] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 25  (minimized by MIQP)
  ||Cm||_1  = 17
  ||flow_B||_2² = 96
  ||flow_corrected||_2² = 81

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2      -2           0    4.3     -8.6s ← BLOCKED
    1     (0, 11)        -2       2           0    5.4    -10.8s
    2      (1, 2)         2      -1           1    4.7     -4.7s
    3      (1, 3)         0      -1          -1    7.9     +7.9s
    4      (1, 5)         0       0           0    7.5          
    5      (2, 3)         2       0           2    6.0          
    6      (2, 8)         0       0           0    5.6          
    7     (2, 11)         0      -1          -1    5.8     +5.8s
    8      (3, 4)         3       0           3    6.9          
    9      (3, 6)        -1       0          -1    5.0          
   10      (3, 8)         0      -1          -1    6.5     +6.5s
   11      (4, 5)         3       0           3    4.6          
   12      (5, 6)         3       0           3    4.8          
   13      (6, 7)        -2       2           0    4.3     -8.6s ← BLOCKED
   14      (6, 9)         0       0           0    7.8          
   15     (6, 10)         4      -2           2    4.2     -8.4s
   16      (7, 8)         2       1           3    6.4     +6.4s
   17     (7, 10)        -4       1          -3    6.9     -6.9s
   18      (8, 9)         2       1           3    7.9     +7.9s
   19     (8, 11)         0      -1          -1    7.3     +7.3s
   20     (9, 10)         2       1           3    6.1     +6.1s
   21    (10, 11)         2       0           2    5.3          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=1, out=1  OK
  Node 2: in=2, out=2  OK
  Node 3: in=4, out=4  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=3, out=3  OK
  Node 7: in=3, out=3  OK
  Node 8: in=4, out=4  OK
  Node 9: in=3, out=3  OK
  Node 10: in=5, out=5  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 33 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 11

  Summary:
    Original path length:  36 edges
    Spliced path length:   33 edges
    Splices performed:     11
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           1         1  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)           2         2  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)          -1        -1  ✓
    8      (3, 4)           3         3  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           3         3  ✓
   12      (5, 6)           3         3  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           2         2  ✓
   16      (7, 8)           3         3  ✓
   17     (7, 10)          -3        -3  ✓
   18      (8, 9)           3         3  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           3         3  ✓
   21    (10, 11)           2         2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 34
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 1, 3, 2, 2, 2, 2, 1, 2] → J=177, T=199, cost=0 → queued

[Iter 1] cost=0, J=177, T=199, edges=33, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 1, 3, 2, 2, 2, 2, 1, 2]
  [backtrack] Found solution with 154 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.9s
  *** SOLUTION FOUND! J=177, T_tour=198.9s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 0, 3, -5, 0, 2, -2, 1, 1, 1, 1, -4, -2, -2, 1, -1, -1, 2, 0, 0, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 0, 3, -5, 0, 2, -2, 1, 1, 1, 1, -4, -2, -2, 1, -1, -1, 2, 0, 0, 0]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 3), np.int64(3)), ((1, 5), np.int64(-5)), ((2, 8), np.int64(2)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(1)), ((3, 6), np.int64(1)), ((3, 8), np.int64(1)), ((4, 5), np.int64(1)), ((5, 6), np.int64(-4)), ((6, 7), np.int64(-2)), ((6, 9), np.int64(-2)), ((6, 10), np.int64(1)), ((7, 8), np.int64(-1)), ((7, 10), np.int64(-1)), ((8, 9), np.int64(2))]

Blocked edge 1: idx=3, edge=(1, 3), flow_B=3  →  need Cm[3]=-3
Blocked edge 2: idx=7, edge=(2, 11), flow_B=-2  →  need Cm[7]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=33   ||Cm||_1=17

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [3, 1, -2, 0, -3, -1, 0, -1, 1, 0, -1]

Cm = C_oriented @ beta*:
  [0, 0, 3, -3, 0, 0, 1, 2, -1, 0, -2, -1, -1, 0, 0, -1, 0, 0, 0, -1, 0, -1]

Original flow_B:
  [-2, 2, 0, 3, -5, 0, 2, -2, 1, 1, 1, 1, -4, -2, -2, 1, -1, -1, 2, 0, 0, 0]

flow_B + Cm (corrected flow):
  [-2, 2, 3, 0, -5, 0, 3, 0, 0, 1, -1, 0, -5, -2, -2, 0, -1, -1, 2, -1, 0, -1]

Verification:
  flow_corrected[3] = 0  (should be 0, Cm=-3, d=-3)
  flow_corrected[7] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 33  (minimized by MIQP)
  ||Cm||_1  = 17
  ||flow_B||_2² = 85
  ||flow_corrected||_2² = 94

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    7.5          
    1     (0, 11)         2       0           2    6.4          
    2      (1, 2)         0       3           3    7.2    +21.6s
    3      (1, 3)         3      -3           0    7.3    -21.9s ← BLOCKED
    4      (1, 5)        -5       0          -5    5.1          
    5      (2, 3)         0       0           0    7.3          
    6      (2, 8)         2       1           3    5.1     +5.1s
    7     (2, 11)        -2       2           0    4.6     -9.2s ← BLOCKED
    8      (3, 4)         1      -1           0    6.9     -6.9s
    9      (3, 6)         1       0           1    5.9          
   10      (3, 8)         1      -2          -1    6.2          
   11      (4, 5)         1      -1           0    5.5     -5.5s
   12      (5, 6)        -4      -1          -5    7.8     +7.8s
   13      (6, 7)        -2       0          -2    4.3          
   14      (6, 9)        -2       0          -2    7.7          
   15     (6, 10)         1      -1           0    4.6     -4.6s
   16      (7, 8)        -1       0          -1    5.8          
   17     (7, 10)        -1       0          -1    4.8          
   18      (8, 9)         2       0           2    4.7          
   19     (8, 11)         0      -1          -1    6.1     +6.1s
   20     (9, 10)         0       0           0    7.6          
   21    (10, 11)         0      -1          -1    7.7     +7.7s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=5, out=5  OK
  Node 2: in=3, out=3  OK
  Node 3: in=1, out=1  OK
  Node 5: in=5, out=5  OK
  Node 6: in=5, out=5  OK
  Node 7: in=2, out=2  OK
  Node 8: in=4, out=4  OK
  Node 9: in=2, out=2  OK
  Node 10: in=1, out=1  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 32 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 18

  Summary:
    Original path length:  33 edges
    Spliced path length:   32 edges
    Splices performed:     18
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)           3         3  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)          -5        -5  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           3         3  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)          -5        -5  ✓
   13      (6, 7)          -2        -2  ✓
   14      (6, 9)          -2        -2  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)           2         2  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 35
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=196, T=199, cost=0 → queued

[Iter 1] cost=0, J=196, T=199, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] Found solution with 28 backtracks in 0.00s
  [backtrack] Found solution with 37 backtracks in 0.00s
  [backtrack] Found solution with 38 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (292 backtracks in 0.00s)
  [backtrack] Found solution with 225 backtracks in 0.00s
  [backtrack] Found solution with 193 backtracks in 0.00s
  [backtrack] Found solution with 182 backtracks in 0.00s
  [backtrack] Found solution with 92 backtracks in 0.00s
  [backtrack] Found solution with 39 backtracks in 0.00s
  [backtrack] Found solution with 64 backtracks in 0.00s
  [backtrack] Found solution with 92 backtracks in 0.00s
  [backtrack] Found solution with 27 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=98.7s)
  Boundary nodes: [0, 1, 2, 4, 9] → expanding 5 children
    V_MIN=[3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=184, T=198, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=193, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=189, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 3, 1] → J=193, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 3, 1] → J=196, T=200, cost=1 → queued

[Iter 2] cost=1, J=196, T=200, edges=37, frontier=4, MILP_calls=6
  V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 3, 1]
  [backtrack] Found solution with 128 backtracks in 0.00s
  [backtrack] Found solution with 164 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] Found solution with 67 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (237 backtracks in 0.00s)
  [backtrack] Found solution with 146 backtracks in 0.00s
  [backtrack] Found solution with 147 backtracks in 0.00s
  [backtrack] Found solution with 183 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (162 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (59 backtracks in 0.00s)
  [backtrack] Found solution with 183 backtracks in 0.00s
  [backtrack] Found solution with 127 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=133.7s)
  Boundary nodes: [0, 1, 2, 4, 8, 9] → expanding 6 children
    V_MIN=[3, 2, 2, 2, 3, 2, 2, 2, 2, 3, 3, 1] → J=184, T=198, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 2, 3, 3, 1] → J=191, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 2, 2, 2, 3, 3, 1] → J=189, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 4, 2, 2, 2, 2, 3, 3, 1] → J=190, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 3, 3, 3, 1] → J=194, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 4, 3, 1] → J=192, T=200, cost=2 → queued

[Iter 3] cost=1, J=193, T=200, edges=37, frontier=9, MILP_calls=12
  V_MIN=[2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (38 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (39 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (40 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (102 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (103 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (28 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (82 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (60 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (69 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (66 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 9, 10] → expanding 6 children
    V_MIN=[3, 2, 2, 2, 4, 2, 2, 2, 2, 2, 3, 1] → J=183, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 2, 2, 2, 2, 3, 1] → J=192, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 4, 2, 2, 2, 2, 2, 3, 1] → J=187, T=198, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 3, 1] → J=183, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 4, 1] → J=192, T=199, cost=2 → queued

[Iter 4] cost=1, J=193, T=199, edges=37, frontier=13, MILP_calls=17
  V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (170 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (82 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (132 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (145 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (212 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (46 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (212 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (339 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (192 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 9] → expanding 5 children
    V_MIN=[3, 3, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=184, T=198, cost=2 → queued
    V_MIN=[2, 4, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=192, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=188, T=200, cost=2 → queued

[Iter 5] cost=1, J=189, T=199, edges=37, frontier=15, MILP_calls=20
  V_MIN=[2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (118 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (117 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (56 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (155 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (154 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (153 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (203 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (85 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (162 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (117 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4] → expanding 4 children
    V_MIN=[3, 2, 3, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=184, T=199, cost=2 → queued
    V_MIN=[2, 2, 4, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=183, T=200, cost=2 → queued

[Iter 6] cost=1, J=184, T=198, edges=36, frontier=16, MILP_calls=22
  V_MIN=[3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (120 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (230 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (219 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (99 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (185 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (251 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (258 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (180 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (127 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4] → expanding 3 children
    V_MIN=[4, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=179, T=200, cost=2 → queued

[Iter 7] cost=2, J=194, T=199, edges=37, frontier=16, MILP_calls=23
  V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 3, 3, 3, 1]
  [backtrack] EXHAUSTED search space (351 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (254 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (251 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (436 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (318 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (311 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (233 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (435 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (119 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (337 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (341 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (195 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 8, 9] → expanding 6 children
    V_MIN=[3, 2, 2, 2, 3, 2, 2, 2, 3, 3, 3, 1] → J=184, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 3, 3, 3, 1] → J=190, T=200, cost=3 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 2, 2, 3, 3, 3, 1] → J=189, T=199, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 4, 2, 2, 2, 3, 3, 3, 1] → J=190, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 4, 3, 3, 1] → J=192, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 3, 4, 3, 1] → J=192, T=200, cost=3 → queued

[Iter 8] cost=2, J=192, T=200, edges=36, frontier=21, MILP_calls=29
  V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 4, 3, 1]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 9] → expanding 5 children
    V_MIN=[3, 2, 2, 2, 3, 2, 2, 2, 2, 4, 3, 1] → J=180, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 2, 4, 3, 1] → J=188, T=200, cost=3 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 2, 2, 2, 4, 3, 1] → J=183, T=198, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 4, 2, 2, 2, 2, 4, 3, 1] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 5, 3, 1] → J=186, T=199, cost=3 → queued

[Iter 9] cost=2, J=192, T=199, edges=38, frontier=24, MILP_calls=34
  V_MIN=[2, 3, 2, 2, 4, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] Found solution with 2 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.2s
  *** SOLUTION FOUND! J=192, T_tour=199.2s ***

============================================================
Search done: 9 iters, 34 MILP calls, 34 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 2, 0, -4, 0, 2, 0, 4, -2, -2, 4, 0, -4, 2, 0, 0, -4, 0, 0, 2, -2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 2, 0, -4, 0, 2, 0, 4, -2, -2, 4, 0, -4, 2, 0, 0, -4, 0, 0, 2, -2]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(2)), ((1, 5), np.int64(-4)), ((2, 8), np.int64(2)), ((3, 4), np.int64(4)), ((3, 6), np.int64(-2)), ((3, 8), np.int64(-2)), ((4, 5), np.int64(4)), ((6, 7), np.int64(-4)), ((6, 9), np.int64(2)), ((7, 10), np.int64(-4)), ((9, 10), np.int64(2)), ((10, 11), np.int64(-2))]

Blocked edge 1: idx=2, edge=(1, 2), flow_B=2  →  need Cm[2]=-2
Blocked edge 2: idx=10, edge=(3, 8), flow_B=-2  →  need Cm[10]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=19   ||Cm||_1=13

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-2, 1, 1, -1, 2, 0, 0, -1, 0, 0, 0]

Cm = C_oriented @ beta*:
  [0, 0, -2, 2, 0, 0, -1, -1, 0, 0, 2, 0, 0, 0, 0, 0, -1, 1, -1, 1, -1, 0]

Original flow_B:
  [-2, 2, 2, 0, -4, 0, 2, 0, 4, -2, -2, 4, 0, -4, 2, 0, 0, -4, 0, 0, 2, -2]

flow_B + Cm (corrected flow):
  [-2, 2, 0, 2, -4, 0, 1, -1, 4, -2, 0, 4, 0, -4, 2, 0, -1, -3, -1, 1, 1, -2]

Verification:
  flow_corrected[2] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[10] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 19  (minimized by MIQP)
  ||Cm||_1  = 13
  ||flow_B||_2² = 116
  ||flow_corrected||_2² = 103

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    7.7          
    1     (0, 11)         2       0           2    4.9          
    2      (1, 2)         2      -2           0    5.2    -10.4s ← BLOCKED
    3      (1, 3)         0       2           2    8.0    +16.0s
    4      (1, 5)        -4       0          -4    4.7          
    5      (2, 3)         0       0           0    8.0          
    6      (2, 8)         2      -1           1    7.0     -7.0s
    7     (2, 11)         0      -1          -1    4.9     +4.9s
    8      (3, 4)         4       0           4    4.6          
    9      (3, 6)        -2       0          -2    6.1          
   10      (3, 8)        -2       2           0    5.6    -11.2s ← BLOCKED
   11      (4, 5)         4       0           4    4.3          
   12      (5, 6)         0       0           0    5.4          
   13      (6, 7)        -4       0          -4    4.0          
   14      (6, 9)         2       0           2    7.1          
   15     (6, 10)         0       0           0    7.5          
   16      (7, 8)         0      -1          -1    6.1     +6.1s
   17     (7, 10)        -4       1          -3    4.3     -4.3s
   18      (8, 9)         0      -1          -1    7.3     +7.3s
   19     (8, 11)         0       1           1    6.0     +6.0s
   20     (9, 10)         2      -1           1    7.5     -7.5s
   21    (10, 11)        -2       0          -2    4.7          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=4, out=4  OK
  Node 2: in=1, out=1  OK
  Node 3: in=4, out=4  OK
  Node 4: in=4, out=4  OK
  Node 5: in=4, out=4  OK
  Node 6: in=4, out=4  OK
  Node 7: in=4, out=4  OK
  Node 8: in=2, out=2  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 37 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 14

  Summary:
    Original path length:  38 edges
    Spliced path length:   37 edges
    Splices performed:     14
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)           2         2  ✓
    4      (1, 5)          -4        -4  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           1         1  ✓
    7     (2, 11)          -1        -1  ✓
    8      (3, 4)           4         4  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           4         4  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)          -4        -4  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)          -3        -3  ✓
   18      (8, 9)          -1        -1  ✓
   19     (8, 11)           1         1  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)          -2        -2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 36
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 3, 2, 3, 2, 2, 2, 2, 1, 3, 3] → J=260, T=200, cost=0 → queued

[Iter 1] cost=0, J=260, T=200, edges=38, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 3, 2, 3, 2, 2, 2, 2, 1, 3, 3]
  [backtrack] Found solution with 1746 backtracks in 0.00s
  [backtrack] Found solution with 2381 backtracks in 0.01s
  [backtrack] Found solution with 2990 backtracks in 0.01s
  [backtrack] Found solution with 1310 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (3466 backtracks in 0.01s)
  [backtrack] Found solution with 1990 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1227 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1111 backtracks in 0.00s)
  [backtrack] Found solution with 2378 backtracks in 0.01s
  [backtrack] EXHAUSTED search space (1231 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (862 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2028 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=185.4s)
  Boundary nodes: [0, 4, 6, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[3, 2, 3, 2, 3, 2, 2, 2, 2, 1, 3, 3] → J=258, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 4, 2, 2, 2, 2, 1, 3, 3] → J=247, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 3, 2, 2, 1, 3, 3] → J=257, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 2, 3, 2, 1, 3, 3] → J=258, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 2, 2, 3, 1, 3, 3] → J=257, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 3, 3] → J=253, T=198, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 2, 2, 2, 1, 4, 3] → J=260, T=198, cost=1 → queued

[Iter 2] cost=1, J=260, T=198, edges=38, frontier=6, MILP_calls=8
  V_MIN=[2, 2, 3, 2, 3, 2, 2, 2, 2, 1, 4, 3]
  [backtrack] Found solution with 193 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=197.6s
  *** SOLUTION FOUND! J=260, T_tour=197.6s ***

============================================================
Search done: 2 iters, 8 MILP calls, 8 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -4, -1, 3, -1, 2, -5, -3, 1, 0, -3, 0, 0, -1, 2, -2, 2, 0, 0, -1, 3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -4, -1, 3, -1, 2, -5, -3, 1, 0, -3, 0, 0, -1, 2, -2, 2, 0, 0, -1, 3]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-4)), ((1, 3), np.int64(-1)), ((1, 5), np.int64(3)), ((2, 3), np.int64(-1)), ((2, 8), np.int64(2)), ((2, 11), np.int64(-5)), ((3, 4), np.int64(-3)), ((3, 6), np.int64(1)), ((4, 5), np.int64(-3)), ((6, 9), np.int64(-1)), ((6, 10), np.int64(2)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(2)), ((9, 10), np.int64(-1)), ((10, 11), np.int64(3))]

Blocked edge 1: idx=14, edge=(6, 9), flow_B=-1  →  need Cm[14]=1
Blocked edge 2: idx=0, edge=(0, 1), flow_B=-2  →  need Cm[0]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=20   ||Cm||_1=14

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-2, 0, 1, 0, 1, 0, 2, 0, -1, 0, 1]

Cm = C_oriented @ beta*:
  [2, -2, 0, 2, 0, -1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 1, -1, 0, 0, 1]

Original flow_B:
  [-2, 2, -4, -1, 3, -1, 2, -5, -3, 1, 0, -3, 0, 0, -1, 2, -2, 2, 0, 0, -1, 3]

flow_B + Cm (corrected flow):
  [0, 0, -4, 1, 3, -2, 2, -4, -3, 2, 0, -3, 0, 0, 0, 2, -3, 3, -1, 0, -1, 4]

Verification:
  flow_corrected[14] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[0] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 20  (minimized by MIQP)
  ||Cm||_1  = 14
  ||flow_B||_2² = 106
  ||flow_corrected||_2² = 112

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       2           0    6.2    -12.4s ← BLOCKED
    1     (0, 11)         2      -2           0    4.8     -9.6s
    2      (1, 2)        -4       0          -4    4.9          
    3      (1, 3)        -1       2           1    4.0          
    4      (1, 5)         3       0           3    4.9          
    5      (2, 3)        -1      -1          -2    5.5     +5.5s
    6      (2, 8)         2       0           2    5.8          
    7     (2, 11)        -5       1          -4    5.0     -5.0s
    8      (3, 4)        -3       0          -3    5.8          
    9      (3, 6)         1       1           2    4.8     +4.8s
   10      (3, 8)         0       0           0    6.7          
   11      (4, 5)        -3       0          -3    5.8          
   12      (5, 6)         0       0           0    6.4          
   13      (6, 7)         0       0           0    5.3          
   14      (6, 9)        -1       1           0    4.9     -4.9s ← BLOCKED
   15     (6, 10)         2       0           2    4.9          
   16      (7, 8)        -2      -1          -3    4.7     +4.7s
   17     (7, 10)         2       1           3    4.1     +4.1s
   18      (8, 9)         0      -1          -1    6.5     +6.5s
   19     (8, 11)         0       0           0    6.1          
   20     (9, 10)        -1       0          -1    5.0          
   21    (10, 11)         3       1           4    6.1     +6.1s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=4, out=4  OK
  Node 2: in=6, out=6  OK
  Node 3: in=4, out=4  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=2, out=2  OK
  Node 7: in=3, out=3  OK
  Node 8: in=3, out=3  OK
  Node 9: in=1, out=1  OK
  Node 10: in=5, out=5  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 38 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 9

  Summary:
    Original path length:  38 edges
    Spliced path length:   38 edges
    Splices performed:     9
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)          -4        -4  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)           3         3  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)           2         2  ✓
    7     (2, 11)          -4        -4  ✓
    8      (3, 4)          -3        -3  ✓
    9      (3, 6)           2         2  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -3        -3  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           2         2  ✓
   16      (7, 8)          -3        -3  ✓
   17     (7, 10)           3         3  ✓
   18      (8, 9)          -1        -1  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)          -1        -1  ✓
   21    (10, 11)           4         4  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 37
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2] → J=214, T=200, cost=0 → queued

[Iter 1] cost=0, J=214, T=200, edges=34, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 60 backtracks in 0.00s
  [backtrack] Found solution with 56 backtracks in 0.00s
  [backtrack] Found solution with 135 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (220 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (219 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (90 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (138 backtracks in 0.00s)
  [backtrack] Found solution with 62 backtracks in 0.00s
  DFS: latency violated (3 nodes, worst_gap=137.3s)
  Boundary nodes: [0, 2, 6, 7, 9, 10] → expanding 6 children
    V_MIN=[4, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2] → J=211, T=199, cost=1 → queued
    V_MIN=[3, 2, 3, 2, 2, 2, 1, 2, 2, 2, 2, 2] → J=206, T=200, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2] → J=213, T=200, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 1, 3, 2, 2, 2, 2] → J=213, T=200, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 1, 2, 2, 3, 2, 2] → J=213, T=200, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 1, 2, 2, 2, 3, 2] → J=213, T=200, cost=1 → queued

[Iter 2] cost=1, J=213, T=200, edges=34, frontier=5, MILP_calls=7
  V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 65 backtracks in 0.00s
  [backtrack] Found solution with 64 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 31 backtracks in 0.00s
  [backtrack] Found solution with 47 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (469 backtracks in 0.00s)
  [backtrack] Found solution with 326 backtracks in 0.00s
  [backtrack] Found solution with 179 backtracks in 0.00s
  [backtrack] Found solution with 90 backtracks in 0.00s
  [backtrack] Found solution with 66 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=106.0s)
  Boundary nodes: [0, 2, 6, 7] → expanding 4 children
    V_MIN=[4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2] → J=209, T=199, cost=2 → queued
    V_MIN=[3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2] → J=206, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2] → J=211, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2] → J=211, T=199, cost=2 → queued

[Iter 3] cost=1, J=213, T=200, edges=34, frontier=8, MILP_calls=11
  V_MIN=[3, 2, 2, 2, 2, 2, 1, 2, 2, 3, 2, 2]
  [backtrack] Found solution with 65 backtracks in 0.00s
  [backtrack] Found solution with 64 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 31 backtracks in 0.00s
  [backtrack] Found solution with 47 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (469 backtracks in 0.00s)
  [backtrack] Found solution with 326 backtracks in 0.00s
  [backtrack] Found solution with 179 backtracks in 0.00s
  [backtrack] Found solution with 90 backtracks in 0.00s
  [backtrack] Found solution with 66 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=106.0s)
  Boundary nodes: [0, 2, 7, 9] → expanding 4 children
    V_MIN=[4, 2, 2, 2, 2, 2, 1, 2, 2, 3, 2, 2] → J=206, T=199, cost=2 → queued
    V_MIN=[3, 2, 3, 2, 2, 2, 1, 2, 2, 3, 2, 2] → J=204, T=198, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 1, 3, 2, 3, 2, 2] → J=212, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 1, 2, 2, 4, 2, 2] → J=210, T=200, cost=2 → queued

[Iter 4] cost=1, J=213, T=200, edges=34, frontier=11, MILP_calls=15
  V_MIN=[3, 2, 2, 2, 2, 2, 1, 2, 2, 2, 3, 2]
  [backtrack] Found solution with 65 backtracks in 0.00s
  [backtrack] Found solution with 64 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 31 backtracks in 0.00s
  [backtrack] Found solution with 47 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (469 backtracks in 0.00s)
  [backtrack] Found solution with 326 backtracks in 0.00s
  [backtrack] Found solution with 179 backtracks in 0.00s
  [backtrack] Found solution with 90 backtracks in 0.00s
  [backtrack] Found solution with 66 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=106.0s)
  Boundary nodes: [0, 2, 7, 10] → expanding 4 children
    V_MIN=[4, 2, 2, 2, 2, 2, 1, 2, 2, 2, 3, 2] → J=211, T=199, cost=2 → queued
    V_MIN=[3, 2, 3, 2, 2, 2, 1, 2, 2, 2, 3, 2] → J=205, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 1, 3, 2, 2, 3, 2] → J=213, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 1, 2, 2, 2, 4, 2] → J=213, T=200, cost=2 → queued

[Iter 5] cost=1, J=213, T=200, edges=33, frontier=14, MILP_calls=19
  V_MIN=[3, 2, 2, 2, 2, 2, 1, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 105 backtracks in 0.00s
  [backtrack] Found solution with 19 backtracks in 0.00s
  [backtrack] Found solution with 19 backtracks in 0.00s
  [backtrack] Found solution with 19 backtracks in 0.00s
  [backtrack] Found solution with 19 backtracks in 0.00s
  [backtrack] Found solution with 19 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (82 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (218 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (214 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (88 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] Found solution with 21 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=113.5s)
  Boundary nodes: [0, 2, 6, 7, 9] → expanding 5 children
    V_MIN=[4, 2, 2, 2, 2, 2, 1, 3, 2, 2, 2, 2] → J=201, T=200, cost=2 → queued
    V_MIN=[3, 2, 3, 2, 2, 2, 1, 3, 2, 2, 2, 2] → J=203, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 1, 4, 2, 2, 2, 2] → J=207, T=198, cost=2 → queued

[Iter 6] cost=1, J=211, T=199, edges=33, frontier=16, MILP_calls=22
  V_MIN=[4, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 257 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.7s
  *** SOLUTION FOUND! J=211, T_tour=198.7s ***

============================================================
Search done: 6 iters, 22 MILP calls, 22 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-4, 4, 0, -2, -2, 2, 0, -2, 2, 0, -2, 2, 0, 0, 1, -1, 2, -2, 1, -1, 2, -1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-4, 4, 0, -2, -2, 2, 0, -2, 2, 0, -2, 2, 0, 0, 1, -1, 2, -2, 1, -1, 2, -1]
  Non-zero edges: [((0, 1), np.int64(-4)), ((0, 11), np.int64(4)), ((1, 3), np.int64(-2)), ((1, 5), np.int64(-2)), ((2, 3), np.int64(2)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(2)), ((3, 8), np.int64(-2)), ((4, 5), np.int64(2)), ((6, 9), np.int64(1)), ((6, 10), np.int64(-1)), ((7, 8), np.int64(2)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(1)), ((8, 11), np.int64(-1)), ((9, 10), np.int64(2)), ((10, 11), np.int64(-1))]

Blocked edge 1: idx=18, edge=(8, 9), flow_B=1  →  need Cm[18]=-1
Blocked edge 2: idx=4, edge=(1, 5), flow_B=-2  →  need Cm[4]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=16   ||Cm||_1=12

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, 0, 0, 0, 0, 1, 0, -1, 0, -2, 0]

Cm = C_oriented @ beta*:
  [0, 0, 0, -2, 2, 0, 0, 0, -1, -1, 0, -1, 1, -1, 1, 0, -1, 0, -1, 0, 0, 0]

Original flow_B:
  [-4, 4, 0, -2, -2, 2, 0, -2, 2, 0, -2, 2, 0, 0, 1, -1, 2, -2, 1, -1, 2, -1]

flow_B + Cm (corrected flow):
  [-4, 4, 0, -4, 0, 2, 0, -2, 1, -1, -2, 1, 1, -1, 2, -1, 1, -2, 0, -1, 2, -1]

Verification:
  flow_corrected[18] = 0  (should be 0, Cm=-1, d=-1)
  flow_corrected[4] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 16  (minimized by MIQP)
  ||Cm||_1  = 12
  ||flow_B||_2² = 77
  ||flow_corrected||_2² = 81

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -4       0          -4    5.8          
    1     (0, 11)         4       0           4    7.9          
    2      (1, 2)         0       0           0    7.6          
    3      (1, 3)        -2      -2          -4    4.8     +9.6s
    4      (1, 5)        -2       2           0    6.4    -12.8s ← BLOCKED
    5      (2, 3)         2       0           2    6.3          
    6      (2, 8)         0       0           0    6.8          
    7     (2, 11)        -2       0          -2    7.7          
    8      (3, 4)         2      -1           1    4.2     -4.2s
    9      (3, 6)         0      -1          -1    4.5     +4.5s
   10      (3, 8)        -2       0          -2    4.5          
   11      (4, 5)         2      -1           1    5.5     -5.5s
   12      (5, 6)         0       1           1    7.2     +7.2s
   13      (6, 7)         0      -1          -1    7.9     +7.9s
   14      (6, 9)         1       1           2    5.3     +5.3s
   15     (6, 10)        -1       0          -1    5.9          
   16      (7, 8)         2      -1           1    4.7     -4.7s
   17     (7, 10)        -2       0          -2    7.6          
   18      (8, 9)         1      -1           0    7.1     -7.1s ← BLOCKED
   19     (8, 11)        -1       0          -1    4.8          
   20     (9, 10)         2       0           2    5.5          
   21    (10, 11)        -1       0          -1    6.4          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=4, out=4  OK
  Node 1: in=4, out=4  OK
  Node 2: in=2, out=2  OK
  Node 3: in=5, out=5  OK
  Node 4: in=1, out=1  OK
  Node 5: in=1, out=1  OK
  Node 6: in=3, out=3  OK
  Node 7: in=2, out=2  OK
  Node 8: in=2, out=2  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 33 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 19

  Summary:
    Original path length:  33 edges
    Spliced path length:   33 edges
    Splices performed:     19
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -4        -4  ✓
    1     (0, 11)           4         4  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)          -4        -4  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)           2         2  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)          -2        -2  ✓
    8      (3, 4)           1         1  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)          -2        -2  ✓
   11      (4, 5)           1         1  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 38
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 3, 2, 2, 2, 2, 2, 2, 1, 2, 2] → J=191, T=200, cost=0 → queued

[Iter 1] cost=0, J=191, T=200, edges=31, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 3, 2, 2, 2, 2, 2, 2, 1, 2, 2]
  [backtrack] Found solution with 341 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (755 backtracks in 0.00s)
  [backtrack] Found solution with 666 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (836 backtracks in 0.00s)
  [backtrack] Found solution with 1057 backtracks in 0.00s
  [backtrack] Found solution with 327 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (523 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1085 backtracks in 0.00s)
  [backtrack] Found solution with 368 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (929 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1203 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1537 backtracks in 0.00s)
  DFS: latency violated (4 nodes, worst_gap=179.3s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 2, 2] → J=181, T=199, cost=1 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 2, 2, 2, 1, 2, 2] → J=183, T=200, cost=1 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 2, 2, 2, 1, 2, 2] → J=190, T=200, cost=1 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 2, 2, 1, 2, 2] → J=181, T=195, cost=1 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 2, 3, 2, 1, 2, 2] → J=178, T=198, cost=1 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2] → J=181, T=198, cost=1 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 2, 2, 2, 1, 3, 2] → J=185, T=200, cost=1 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 2, 2, 2, 1, 2, 3] → J=184, T=198, cost=1 → queued

[Iter 2] cost=1, J=190, T=200, edges=31, frontier=7, MILP_calls=9
  V_MIN=[2, 3, 3, 2, 2, 3, 2, 2, 2, 1, 2, 2]
  [backtrack] Found solution with 10 backtracks in 0.00s
  [backtrack] Found solution with 106 backtracks in 0.00s
  [backtrack] Found solution with 38 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (198 backtracks in 0.00s)
  [backtrack] Found solution with 81 backtracks in 0.00s
  [backtrack] Found solution with 118 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (221 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (225 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (285 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (148 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (132 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (240 backtracks in 0.00s)
  DFS: latency violated (4 nodes, worst_gap=179.4s)
  Boundary nodes: [0, 3, 4, 5, 6, 7, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 3, 3, 2, 2, 3, 2, 2, 2, 1, 2, 2] → J=178, T=197, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 2, 3, 2, 2, 2, 1, 2, 2] → J=186, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 2, 3, 3, 2, 2, 2, 1, 2, 2] → J=183, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 2, 2, 4, 2, 2, 2, 1, 2, 2] → J=185, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 2, 2, 1, 2, 2] → J=180, T=195, cost=2 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 2, 3, 2, 1, 2, 2] → J=176, T=197, cost=2 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 2, 2, 2, 2, 2, 2] → J=179, T=197, cost=2 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 2, 2, 2, 1, 3, 2] → J=184, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 2, 2, 2, 1, 2, 3] → J=183, T=198, cost=2 → queued

[Iter 3] cost=1, J=185, T=200, edges=31, frontier=15, MILP_calls=18
  V_MIN=[2, 3, 3, 2, 2, 2, 2, 2, 2, 1, 3, 2]
  [backtrack] Found solution with 426 backtracks in 0.00s
  [backtrack] Found solution with 81 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=199.8s
  *** SOLUTION FOUND! J=185, T_tour=199.8s ***

============================================================
Search done: 3 iters, 18 MILP calls, 18 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 4, -3, 1, 0, 3, 1, -2, 0, -1, -2, -1, 1, 0, -2, -1, 2, 1, 0, 1, 1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 4, -3, 1, 0, 3, 1, -2, 0, -1, -2, -1, 1, 0, -2, -1, 2, 1, 0, 1, 1]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(4)), ((1, 3), np.int64(-3)), ((1, 5), np.int64(1)), ((2, 8), np.int64(3)), ((2, 11), np.int64(1)), ((3, 4), np.int64(-2)), ((3, 8), np.int64(-1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-1)), ((6, 7), np.int64(1)), ((6, 10), np.int64(-2)), ((7, 8), np.int64(-1)), ((7, 10), np.int64(2)), ((8, 9), np.int64(1)), ((9, 10), np.int64(1)), ((10, 11), np.int64(1))]

Blocked edge 1: idx=10, edge=(3, 8), flow_B=-1  →  need Cm[10]=1
Blocked edge 2: idx=11, edge=(4, 5), flow_B=-2  →  need Cm[11]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=20   ||Cm||_1=14

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 0, 0, 1, 0, 1, 0, 0, 0, 1, -1]

Cm = C_oriented @ beta*:
  [0, 0, 1, 0, -1, 1, 0, 0, 2, -2, 1, 2, 1, 0, 0, -1, 0, 0, 1, 0, 1, 0]

Original flow_B:
  [2, -2, 4, -3, 1, 0, 3, 1, -2, 0, -1, -2, -1, 1, 0, -2, -1, 2, 1, 0, 1, 1]

flow_B + Cm (corrected flow):
  [2, -2, 5, -3, 0, 1, 3, 1, 0, -2, 0, 0, 0, 1, 0, -3, -1, 2, 2, 0, 2, 1]

Verification:
  flow_corrected[10] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[11] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 20  (minimized by MIQP)
  ||Cm||_1  = 14
  ||flow_B||_2² = 67
  ||flow_corrected||_2² = 81

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    5.9          
    1     (0, 11)        -2       0          -2    7.5          
    2      (1, 2)         4       1           5    6.1     +6.1s
    3      (1, 3)        -3       0          -3    6.2          
    4      (1, 5)         1      -1           0    5.9     -5.9s
    5      (2, 3)         0       1           1    6.8     +6.8s
    6      (2, 8)         3       0           3    6.0          
    7     (2, 11)         1       0           1    7.3          
    8      (3, 4)        -2       2           0    7.8    -15.6s
    9      (3, 6)         0      -2          -2    7.4    +14.8s
   10      (3, 8)        -1       1           0    5.2     -5.2s ← BLOCKED
   11      (4, 5)        -2       2           0    6.2    -12.4s ← BLOCKED
   12      (5, 6)        -1       1           0    6.6     -6.6s
   13      (6, 7)         1       0           1    7.8          
   14      (6, 9)         0       0           0    7.9          
   15     (6, 10)        -2      -1          -3    5.8     +5.8s
   16      (7, 8)        -1       0          -1    7.2          
   17     (7, 10)         2       0           2    6.9          
   18      (8, 9)         1       1           2    4.4     +4.4s
   19     (8, 11)         0       0           0    7.2          
   20     (9, 10)         1       1           2    7.7     +7.7s
   21    (10, 11)         1       0           1    6.5          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=5, out=5  OK
  Node 2: in=5, out=5  OK
  Node 3: in=3, out=3  OK
  Node 6: in=3, out=3  OK
  Node 7: in=2, out=2  OK
  Node 8: in=3, out=3  OK
  Node 9: in=2, out=2  OK
  Node 10: in=4, out=4  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 31 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 11

  Summary:
    Original path length:  31 edges
    Spliced path length:   31 edges
    Splices performed:     11
    Path is continuous:    True
    Returns to source 1: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           5         5  ✓
    3      (1, 3)          -3        -3  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)           1         1  ✓
    6      (2, 8)           3         3  ✓
    7     (2, 11)           1         1  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)          -3        -3  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)           2         2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 39
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 2, 2, 3, 3, 3] → J=247, T=199, cost=0 → queued

[Iter 1] cost=0, J=247, T=199, edges=35, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 3, 1, 2, 2, 2, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (276 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (213 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (373 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (509 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (412 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (364 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (445 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (493 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (399 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (489 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (117 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (156 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 7, 8, 11] → expanding 8 children
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 2, 2, 3, 3, 3] → J=243, T=200, cost=1 → queued
    V_MIN=[2, 3, 3, 1, 2, 2, 2, 2, 2, 3, 3, 3] → J=243, T=200, cost=1 → queued
    V_MIN=[2, 2, 4, 1, 2, 2, 2, 2, 2, 3, 3, 3] → J=246, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 1, 3, 2, 2, 2, 2, 3, 3, 3] → J=243, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 1, 2, 3, 2, 2, 2, 3, 3, 3] → J=243, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3] → J=244, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 2, 3, 3, 3, 3] → J=246, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 2, 2, 3, 3, 4] → J=246, T=199, cost=1 → queued

[Iter 2] cost=1, J=246, T=199, edges=34, frontier=7, MILP_calls=9
  V_MIN=[2, 2, 4, 1, 2, 2, 2, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (44 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (43 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (67 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (137 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (118 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (101 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (191 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (119 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 6, 7] → expanding 7 children
    V_MIN=[3, 2, 4, 1, 2, 2, 2, 2, 2, 3, 3, 3] → J=243, T=200, cost=2 → queued
    V_MIN=[2, 3, 4, 1, 2, 2, 2, 2, 2, 3, 3, 3] → J=243, T=200, cost=2 → queued
    V_MIN=[2, 2, 5, 1, 2, 2, 2, 2, 2, 3, 3, 3] → J=239, T=199, cost=2 → queued
    V_MIN=[2, 2, 4, 1, 3, 2, 2, 2, 2, 3, 3, 3] → J=236, T=197, cost=2 → queued
    V_MIN=[2, 2, 4, 1, 2, 3, 2, 2, 2, 3, 3, 3] → J=236, T=197, cost=2 → queued
    V_MIN=[2, 2, 4, 1, 2, 2, 3, 2, 2, 3, 3, 3] → J=245, T=199, cost=2 → queued
    V_MIN=[2, 2, 4, 1, 2, 2, 2, 3, 2, 3, 3, 3] → J=240, T=198, cost=2 → queued

[Iter 3] cost=1, J=246, T=199, edges=34, frontier=13, MILP_calls=16
  V_MIN=[2, 2, 3, 1, 2, 2, 2, 2, 3, 3, 3, 3]
  [backtrack] EXHAUSTED search space (44 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (43 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (67 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (137 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (118 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (101 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (191 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (119 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 4, 5, 6, 7] → expanding 6 children
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 2, 3, 3, 3, 3] → J=242, T=198, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 2, 2, 2, 3, 3, 3, 3] → J=243, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 1, 3, 2, 2, 2, 3, 3, 3, 3] → J=241, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 1, 2, 3, 2, 2, 3, 3, 3, 3] → J=242, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 3, 3] → J=245, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 3, 3, 3, 3, 3] → J=244, T=199, cost=2 → queued

[Iter 4] cost=1, J=246, T=199, edges=34, frontier=18, MILP_calls=22
  V_MIN=[2, 2, 3, 1, 2, 2, 2, 2, 2, 3, 3, 4]
  [backtrack] EXHAUSTED search space (45 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (83 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (192 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (116 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (107 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (98 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (158 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (157 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (140 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (156 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 4, 5, 6, 7, 11] → expanding 7 children
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 2, 2, 3, 3, 4] → J=239, T=198, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 2, 2, 2, 2, 3, 3, 4] → J=239, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 1, 3, 2, 2, 2, 2, 3, 3, 4] → J=236, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 1, 2, 3, 2, 2, 2, 3, 3, 4] → J=236, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 3, 2, 2, 3, 3, 4] → J=245, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 3, 2, 3, 3, 4] → J=242, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 2, 2, 3, 3, 5] → J=245, T=200, cost=2 → queued

[Iter 5] cost=1, J=244, T=199, edges=34, frontier=24, MILP_calls=29
  V_MIN=[2, 2, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (129 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (250 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (196 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (130 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (414 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (88 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (216 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (424 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (187 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 6, 7, 11] → expanding 8 children
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 1, 3, 2, 2, 3, 2, 3, 3, 3] → J=241, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 1, 2, 3, 2, 3, 2, 3, 3, 3] → J=241, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 3, 3, 2, 3, 3, 3] → J=243, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 4, 2, 3, 3, 3] → J=240, T=200, cost=2 → queued

[Iter 6] cost=1, J=243, T=200, edges=34, frontier=29, MILP_calls=35
  V_MIN=[2, 3, 3, 1, 2, 2, 2, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (529 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (283 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (765 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (388 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (727 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (558 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (531 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (630 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (470 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (688 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (419 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (296 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 6, 7, 11] → expanding 8 children
    V_MIN=[3, 3, 3, 1, 2, 2, 2, 2, 2, 3, 3, 3] → J=243, T=200, cost=2 → queued
    V_MIN=[2, 4, 3, 1, 2, 2, 2, 2, 2, 3, 3, 3] → J=240, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 3, 2, 2, 2, 2, 3, 3, 3] → J=237, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 2, 3, 3, 3] → J=242, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 2, 3, 2, 2, 3, 3, 3] → J=243, T=200, cost=2 → queued

[Iter 7] cost=1, J=243, T=200, edges=34, frontier=33, MILP_calls=40
  V_MIN=[3, 2, 3, 1, 2, 2, 2, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (86 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (71 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (59 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (98 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (58 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (59 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (81 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (103 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (52 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (156 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (58 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 11] → expanding 6 children
    V_MIN=[4, 2, 3, 1, 2, 2, 2, 2, 2, 3, 3, 3] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 1, 3, 2, 2, 2, 2, 3, 3, 3] → J=234, T=200, cost=2 → queued
    V_MIN=[3, 2, 3, 1, 2, 3, 2, 2, 2, 3, 3, 3] → J=241, T=199, cost=2 → queued

[Iter 8] cost=1, J=243, T=199, edges=35, frontier=34, MILP_calls=43
  V_MIN=[2, 2, 3, 1, 3, 2, 2, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (40 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (26 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (101 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (27 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (176 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (131 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (122 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (81 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (19 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (71 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 7, 8, 11] → expanding 7 children
    V_MIN=[2, 2, 3, 1, 4, 2, 2, 2, 2, 3, 3, 3] → J=231, T=200, cost=2 → queued

[Iter 9] cost=1, J=243, T=199, edges=35, frontier=34, MILP_calls=44
  V_MIN=[2, 2, 3, 1, 2, 3, 2, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (40 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (26 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (101 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (27 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (176 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (131 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (122 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (81 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (19 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (71 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 5, 7, 8, 11] → expanding 7 children
    V_MIN=[2, 2, 3, 1, 2, 4, 2, 2, 2, 3, 3, 3] → J=237, T=200, cost=2 → queued

[Iter 10] cost=2, J=245, T=200, edges=34, frontier=34, MILP_calls=45
  V_MIN=[2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 3, 3]
  [backtrack] Found solution with 157 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (171 backtracks in 0.00s)
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (107 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (192 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (203 backtracks in 0.00s)
  [backtrack] Found solution with 201 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (202 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (127 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (169 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=102.1s)
  Boundary nodes: [0, 1, 2, 4, 5, 6, 7, 8, 9] → expanding 9 children
    V_MIN=[3, 2, 3, 1, 2, 2, 3, 2, 3, 3, 3, 3] → J=241, T=198, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 2, 3, 2, 3, 3, 3, 3] → J=242, T=200, cost=3 → queued
    V_MIN=[2, 2, 4, 1, 2, 2, 3, 2, 3, 3, 3, 3] → J=245, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 3, 2, 3, 2, 3, 3, 3, 3] → J=240, T=200, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 3, 3, 2, 3, 3, 3, 3] → J=240, T=200, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 4, 2, 3, 3, 3, 3] → J=241, T=200, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 3, 3, 3, 3, 3, 3] → J=241, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 3, 2, 4, 3, 3, 3] → J=242, T=198, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 3, 2, 3, 4, 3, 3] → J=245, T=199, cost=3 → queued

[Iter 11] cost=2, J=245, T=200, edges=34, frontier=42, MILP_calls=54
  V_MIN=[2, 2, 3, 1, 2, 2, 3, 2, 2, 3, 3, 4]
  [backtrack] Found solution with 157 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (171 backtracks in 0.00s)
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (107 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (192 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (203 backtracks in 0.00s)
  [backtrack] Found solution with 201 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (202 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (127 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (169 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=102.1s)
  Boundary nodes: [0, 1, 2, 4, 5, 6, 7, 9] → expanding 8 children
    V_MIN=[3, 2, 3, 1, 2, 2, 3, 2, 2, 3, 3, 4] → J=235, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 2, 3, 2, 2, 3, 3, 4] → J=239, T=200, cost=3 → queued
    V_MIN=[2, 2, 4, 1, 2, 2, 3, 2, 2, 3, 3, 4] → J=245, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 3, 2, 3, 2, 2, 3, 3, 4] → J=235, T=198, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 3, 3, 2, 2, 3, 3, 4] → J=236, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 4, 2, 2, 3, 3, 4] → J=243, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 3, 3, 2, 3, 3, 4] → J=241, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 3, 2, 2, 4, 3, 4] → J=245, T=200, cost=3 → queued

[Iter 12] cost=2, J=245, T=200, edges=34, frontier=49, MILP_calls=62
  V_MIN=[2, 2, 3, 1, 2, 2, 2, 2, 2, 3, 3, 5]
  [backtrack] Found solution with 157 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (171 backtracks in 0.00s)
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (107 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (192 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (203 backtracks in 0.00s)
  [backtrack] Found solution with 201 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (202 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (127 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (169 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=102.1s)
  Boundary nodes: [0, 1, 2, 4, 5, 7, 9, 11] → expanding 8 children
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 2, 2, 3, 3, 5] → J=230, T=198, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 2, 2, 2, 2, 3, 3, 5] → J=230, T=198, cost=3 → queued
    V_MIN=[2, 2, 4, 1, 2, 2, 2, 2, 2, 3, 3, 5] → J=237, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 3, 2, 2, 2, 2, 3, 3, 5] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 1, 2, 3, 2, 2, 2, 3, 3, 5] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 3, 2, 3, 3, 5] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 2, 2, 4, 3, 5] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 2, 2, 3, 3, 6] → MILP infeasible, pruned

[Iter 13] cost=2, J=245, T=199, edges=34, frontier=51, MILP_calls=70
  V_MIN=[2, 2, 4, 1, 2, 2, 3, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (329 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (241 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (111 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (289 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (333 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (285 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (341 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (118 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (371 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (285 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (400 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 6, 7] → expanding 7 children
    V_MIN=[3, 2, 4, 1, 2, 2, 3, 2, 2, 3, 3, 3] → J=243, T=200, cost=3 → queued
    V_MIN=[2, 3, 4, 1, 2, 2, 3, 2, 2, 3, 3, 3] → J=243, T=200, cost=3 → queued
    V_MIN=[2, 2, 5, 1, 2, 2, 3, 2, 2, 3, 3, 3] → J=239, T=199, cost=3 → queued
    V_MIN=[2, 2, 4, 1, 3, 2, 3, 2, 2, 3, 3, 3] → J=235, T=200, cost=3 → queued
    V_MIN=[2, 2, 4, 1, 2, 3, 3, 2, 2, 3, 3, 3] → J=235, T=200, cost=3 → queued
    V_MIN=[2, 2, 4, 1, 2, 2, 4, 2, 2, 3, 3, 3] → J=243, T=199, cost=3 → queued
    V_MIN=[2, 2, 4, 1, 2, 2, 3, 3, 2, 3, 3, 3] → J=240, T=198, cost=3 → queued

[Iter 14] cost=2, J=244, T=199, edges=34, frontier=57, MILP_calls=77
  V_MIN=[2, 2, 3, 1, 2, 2, 2, 3, 3, 3, 3, 3]
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (178 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (68 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (67 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (306 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (345 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (471 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (57 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (185 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 6, 7, 8, 11] → expanding 9 children
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 3, 3, 3, 3, 3] → J=241, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 2, 2, 3, 3, 3, 3, 3] → J=241, T=200, cost=3 → queued
    V_MIN=[2, 2, 4, 1, 2, 2, 2, 3, 3, 3, 3, 3] → J=240, T=198, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 3, 2, 2, 3, 3, 3, 3, 3] → J=241, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 3, 2, 3, 3, 3, 3, 3] → J=241, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 4, 3, 3, 3, 3] → J=240, T=200, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 3, 4, 3, 3, 3] → J=242, T=200, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 2, 3, 3, 3, 3, 4] → J=242, T=200, cost=3 → queued

[Iter 15] cost=2, J=243, T=200, edges=34, frontier=64, MILP_calls=85
  V_MIN=[2, 3, 3, 1, 2, 2, 2, 2, 3, 3, 3, 3]
  [backtrack] EXHAUSTED search space (529 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (283 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (765 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (388 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (727 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (558 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (531 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (630 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (470 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (688 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (419 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (296 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 6, 7, 11] → expanding 8 children
    V_MIN=[3, 3, 3, 1, 2, 2, 2, 2, 3, 3, 3, 3] → J=242, T=199, cost=3 → queued
    V_MIN=[2, 4, 3, 1, 2, 2, 2, 2, 3, 3, 3, 3] → J=238, T=199, cost=3 → queued
    V_MIN=[2, 3, 4, 1, 2, 2, 2, 2, 3, 3, 3, 3] → J=240, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 2, 2, 2, 3, 3, 3, 3] → J=235, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 3, 3, 3] → J=242, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 2, 2, 2, 3, 3, 3, 4] → J=239, T=200, cost=3 → queued

[Iter 16] cost=2, J=243, T=199, edges=34, frontier=69, MILP_calls=91
  V_MIN=[2, 2, 3, 1, 2, 2, 3, 3, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (153 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (90 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (172 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (159 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (146 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (111 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (169 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (161 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (148 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (303 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (81 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 6, 7, 8, 11] → expanding 9 children
    V_MIN=[3, 2, 3, 1, 2, 2, 3, 3, 2, 3, 3, 3] → J=234, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 2, 3, 3, 2, 3, 3, 3] → J=234, T=200, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 3, 2, 3, 3, 2, 3, 3, 3] → J=230, T=197, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 3, 3, 3, 2, 3, 3, 3] → J=236, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 4, 3, 2, 3, 3, 3] → J=239, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 1, 2, 2, 3, 4, 2, 3, 3, 3] → J=239, T=200, cost=3 → queued

[Iter 17] cost=2, J=243, T=200, edges=34, frontier=74, MILP_calls=97
  V_MIN=[3, 2, 4, 1, 2, 2, 2, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (86 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (71 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (59 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (98 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (58 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (59 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (81 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (103 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (52 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (156 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (58 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 7, 8, 11] → expanding 7 children
    V_MIN=[4, 2, 4, 1, 2, 2, 2, 2, 2, 3, 3, 3] → MILP infeasible, pruned
    V_MIN=[3, 2, 5, 1, 2, 2, 2, 2, 2, 3, 3, 3] → J=236, T=199, cost=3 → queued
    V_MIN=[3, 2, 4, 1, 3, 2, 2, 2, 2, 3, 3, 3] → J=234, T=200, cost=3 → queued
    V_MIN=[3, 2, 4, 1, 2, 3, 2, 2, 2, 3, 3, 3] → J=234, T=198, cost=3 → queued
    V_MIN=[3, 2, 4, 1, 2, 2, 2, 3, 2, 3, 3, 3] → J=235, T=199, cost=3 → queued
    V_MIN=[3, 2, 4, 1, 2, 2, 2, 2, 3, 3, 3, 3] → J=240, T=200, cost=3 → queued
    V_MIN=[3, 2, 4, 1, 2, 2, 2, 2, 2, 3, 3, 4] → J=238, T=197, cost=3 → queued

[Iter 18] cost=2, J=243, T=200, edges=34, frontier=79, MILP_calls=104
  V_MIN=[2, 3, 4, 1, 2, 2, 2, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (85 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (63 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (51 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (58 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (94 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (103 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (124 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [1, 2, 4, 5, 7, 8, 11] → expanding 7 children
    V_MIN=[2, 4, 4, 1, 2, 2, 2, 2, 2, 3, 3, 3] → J=240, T=199, cost=3 → queued
    V_MIN=[2, 3, 5, 1, 2, 2, 2, 2, 2, 3, 3, 3] → J=239, T=198, cost=3 → queued
    V_MIN=[2, 3, 4, 1, 3, 2, 2, 2, 2, 3, 3, 3] → J=236, T=197, cost=3 → queued
    V_MIN=[2, 3, 4, 1, 2, 3, 2, 2, 2, 3, 3, 3] → J=236, T=197, cost=3 → queued
    V_MIN=[2, 3, 4, 1, 2, 2, 2, 3, 2, 3, 3, 3] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 4, 1, 2, 2, 2, 2, 2, 3, 3, 4] → J=238, T=199, cost=3 → queued

[Iter 19] cost=2, J=243, T=200, edges=34, frontier=84, MILP_calls=110
  V_MIN=[3, 3, 3, 1, 2, 2, 2, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (85 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (63 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (51 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (58 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (94 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (103 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (124 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 4, 5, 7, 8, 11] → expanding 7 children
    V_MIN=[4, 3, 3, 1, 2, 2, 2, 2, 2, 3, 3, 3] → MILP infeasible, pruned
    V_MIN=[3, 4, 3, 1, 2, 2, 2, 2, 2, 3, 3, 3] → J=237, T=200, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 3, 2, 2, 2, 2, 3, 3, 3] → J=234, T=198, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 2, 3, 3, 3] → J=241, T=199, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 2, 2, 2, 3, 2, 3, 3, 3] → J=241, T=200, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 2, 2, 2, 2, 2, 3, 3, 4] → J=239, T=198, cost=3 → queued

[Iter 20] cost=2, J=243, T=200, edges=34, frontier=88, MILP_calls=116
  V_MIN=[2, 3, 3, 1, 2, 2, 3, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (85 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (63 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (51 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (58 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (94 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (103 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (124 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [1, 4, 5, 6, 7, 8, 11] → expanding 7 children
    V_MIN=[2, 4, 3, 1, 2, 2, 3, 2, 2, 3, 3, 3] → J=237, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 2, 3, 2, 2, 3, 3, 3] → J=233, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 3, 2, 2, 3, 3, 3] → J=240, T=198, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 2, 4, 2, 2, 3, 3, 3] → J=242, T=197, cost=3 → queued

[Iter 21] cost=2, J=242, T=198, edges=34, frontier=91, MILP_calls=120
  V_MIN=[3, 2, 3, 1, 2, 2, 2, 2, 3, 3, 3, 3]
  [backtrack] EXHAUSTED search space (333 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (168 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (344 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (302 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (286 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (229 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (212 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (225 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (349 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (188 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (272 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 6, 7, 11] → expanding 7 children
    V_MIN=[4, 2, 3, 1, 2, 2, 2, 2, 3, 3, 3, 3] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 1, 3, 2, 2, 2, 3, 3, 3, 3] → J=232, T=198, cost=3 → queued
    V_MIN=[3, 2, 3, 1, 2, 3, 2, 2, 3, 3, 3, 3] → J=241, T=199, cost=3 → queued
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 2, 3, 3, 3, 4] → J=236, T=200, cost=3 → queued

[Iter 22] cost=2, J=242, T=200, edges=34, frontier=93, MILP_calls=124
  V_MIN=[2, 2, 3, 1, 2, 3, 2, 2, 3, 3, 3, 3]
  [backtrack] Found solution with 541 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.6s
  *** SOLUTION FOUND! J=242, T_tour=199.6s ***

============================================================
Search done: 22 iters, 124 MILP calls, 124 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 1, 0, -3, 2, -2, 1, 2, 0, 0, 2, -1, 0, -2, 1, -2, 2, -2, -2, -4, -1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 1, 0, -3, 2, -2, 1, 2, 0, 0, 2, -1, 0, -2, 1, -2, 2, -2, -2, -4, -1]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(1)), ((1, 5), np.int64(-3)), ((2, 3), np.int64(2)), ((2, 8), np.int64(-2)), ((2, 11), np.int64(1)), ((3, 4), np.int64(2)), ((4, 5), np.int64(2)), ((5, 6), np.int64(-1)), ((6, 9), np.int64(-2)), ((6, 10), np.int64(1)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(2)), ((8, 9), np.int64(-2)), ((8, 11), np.int64(-2)), ((9, 10), np.int64(-4)), ((10, 11), np.int64(-1))]

Blocked edge 1: idx=18, edge=(8, 9), flow_B=-2  →  need Cm[18]=2
Blocked edge 2: idx=1, edge=(0, 11), flow_B=2  →  need Cm[1]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=24   ||Cm||_1=16

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, -1, 1, 0, 1, 0, 2, 2, -1, 0, 0]

Cm = C_oriented @ beta*:
  [2, -2, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, -2, 1, 1, 0, 2, 0, 0, 1]

Original flow_B:
  [-2, 2, 1, 0, -3, 2, -2, 1, 2, 0, 0, 2, -1, 0, -2, 1, -2, 2, -2, -2, -4, -1]

flow_B + Cm (corrected flow):
  [0, 0, 2, 1, -3, 2, -2, 2, 2, 0, 1, 2, -1, 1, -4, 2, -1, 2, 0, -2, -4, 0]

Verification:
  flow_corrected[18] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[1] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 24  (minimized by MIQP)
  ||Cm||_1  = 16
  ||flow_B||_2² = 74
  ||flow_corrected||_2² = 82

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       2           0    7.7    -15.4s
    1     (0, 11)         2      -2           0    5.7    -11.4s ← BLOCKED
    2      (1, 2)         1       1           2    7.3     +7.3s
    3      (1, 3)         0       1           1    7.8     +7.8s
    4      (1, 5)        -3       0          -3    6.5          
    5      (2, 3)         2       0           2    5.0          
    6      (2, 8)        -2       0          -2    6.4          
    7     (2, 11)         1       1           2    7.4     +7.4s
    8      (3, 4)         2       0           2    4.2          
    9      (3, 6)         0       0           0    7.4          
   10      (3, 8)         0       1           1    6.9     +6.9s
   11      (4, 5)         2       0           2    5.2          
   12      (5, 6)        -1       0          -1    5.9          
   13      (6, 7)         0       1           1    7.4     +7.4s
   14      (6, 9)        -2      -2          -4    6.4    +12.8s
   15     (6, 10)         1       1           2    4.6     +4.6s
   16      (7, 8)        -2       1          -1    6.1     -6.1s
   17     (7, 10)         2       0           2    4.8          
   18      (8, 9)        -2       2           0    6.7    -13.4s ← BLOCKED
   19     (8, 11)        -2       0          -2    6.2          
   20     (9, 10)        -4       0          -4    4.6          
   21    (10, 11)        -1       1           0    7.7     -7.7s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=3, out=3  OK
  Node 2: in=4, out=4  OK
  Node 3: in=3, out=3  OK
  Node 4: in=2, out=2  OK
  Node 5: in=3, out=3  OK
  Node 6: in=4, out=4  OK
  Node 7: in=2, out=2  OK
  Node 8: in=3, out=3  OK
  Node 9: in=4, out=4  OK
  Node 10: in=4, out=4  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 26

  Summary:
    Original path length:  34 edges
    Spliced path length:   34 edges
    Splices performed:     26
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           2         2  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)          -3        -3  ✓
    5      (2, 3)           2         2  ✓
    6      (2, 8)          -2        -2  ✓
    7     (2, 11)           2         2  ✓
    8      (3, 4)           2         2  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           1         1  ✓
   11      (4, 5)           2         2  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)          -4        -4  ✓
   15     (6, 10)           2         2  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)          -4        -4  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 40
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2] → J=222, T=200, cost=0 → queued

[Iter 1] cost=0, J=222, T=200, edges=35, frontier=0, MILP_calls=1
  V_MIN=[2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2]
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 51 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=199.9s
  DFS: latency violated (1 nodes, worst_gap=142.2s)
  Boundary nodes: [0, 4, 5, 6, 7] → expanding 5 children
    V_MIN=[3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2] → J=210, T=198, cost=1 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2] → J=209, T=200, cost=1 → queued
    V_MIN=[2, 1, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2] → J=211, T=200, cost=1 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 2, 3, 2] → J=220, T=200, cost=1 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2] → J=221, T=199, cost=1 → queued

[Iter 2] cost=1, J=221, T=199, edges=34, frontier=4, MILP_calls=6
  V_MIN=[2, 1, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (312 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (161 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (374 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (242 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (238 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (224 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (245 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (218 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (190 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (317 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7] → expanding 6 children
    V_MIN=[3, 1, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2] → J=208, T=199, cost=2 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 2, 3, 2, 2, 3, 2] → J=216, T=198, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2] → J=208, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2] → J=209, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 3, 2, 2, 3, 2] → J=219, T=199, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 2, 4, 2, 2, 3, 2] → J=219, T=200, cost=2 → queued

[Iter 3] cost=1, J=220, T=200, edges=34, frontier=9, MILP_calls=12
  V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (358 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (194 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (322 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (295 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (281 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (271 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (296 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (268 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (360 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (508 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (198 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7] → expanding 6 children
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 2, 2, 2, 3, 2] → J=207, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 3, 2, 2, 2, 3, 2] → J=216, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 3, 2, 2, 2, 3, 2] → J=207, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 3, 3, 2, 2, 2, 3, 2] → J=209, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 4, 2, 2, 2, 3, 2] → J=218, T=200, cost=2 → queued

[Iter 4] cost=1, J=211, T=200, edges=34, frontier=13, MILP_calls=17
  V_MIN=[2, 1, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2]
  [backtrack] Found solution with 43 backtracks in 0.00s
  [backtrack] Found solution with 35 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (172 backtracks in 0.00s)
  [backtrack] Found solution with 102 backtracks in 0.00s
  [backtrack] Found solution with 103 backtracks in 0.00s
  [backtrack] Found solution with 104 backtracks in 0.00s
  [backtrack] Found solution with 57 backtracks in 0.00s
  [backtrack] Found solution with 420 backtracks in 0.00s
  [backtrack] Found solution with 311 backtracks in 0.00s
  [backtrack] Found solution with 233 backtracks in 0.00s
  [backtrack] Found solution with 55 backtracks in 0.00s
  [backtrack] Found solution with 44 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=105.2s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7] → expanding 7 children
    V_MIN=[3, 1, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2] → J=199, T=199, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 2, 3, 2] → J=209, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 3, 2, 3, 2, 2, 2, 2, 3, 2] → J=209, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 3, 3, 2, 2, 2, 2, 3, 2] → J=209, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 4, 2, 2, 2, 2, 3, 2] → J=200, T=199, cost=2 → queued

[Iter 5] cost=1, J=210, T=198, edges=34, frontier=17, MILP_calls=22
  V_MIN=[3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (207 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (176 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (155 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (185 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (248 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (167 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (250 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (175 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (186 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (326 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (154 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (206 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7, 8] → expanding 7 children
    V_MIN=[4, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2] → J=199, T=200, cost=2 → queued
    V_MIN=[3, 1, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2] → J=207, T=200, cost=2 → queued
    V_MIN=[3, 1, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2] → J=193, T=200, cost=2 → queued
    V_MIN=[3, 1, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2] → J=210, T=199, cost=2 → queued

[Iter 6] cost=1, J=209, T=200, edges=34, frontier=20, MILP_calls=26
  V_MIN=[2, 1, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (297 backtracks in 0.00s)
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 277 backtracks in 0.00s
  [backtrack] Found solution with 287 backtracks in 0.00s
  [backtrack] Found solution with 344 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (356 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (198 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (178 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (188 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (318 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] Found solution with 277 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=107.7s)
  Boundary nodes: [0, 4, 6, 7, 8] → expanding 5 children
    V_MIN=[2, 1, 2, 2, 4, 2, 2, 2, 2, 2, 3, 2] → J=190, T=198, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 2, 2, 3, 2, 3, 2] → J=207, T=200, cost=2 → queued

[Iter 7] cost=2, J=219, T=200, edges=34, frontier=21, MILP_calls=28
  V_MIN=[2, 1, 2, 2, 2, 2, 2, 4, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (205 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (45 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (44 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (87 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (297 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (251 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (337 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (394 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (412 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (167 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7] → expanding 7 children
    V_MIN=[3, 1, 2, 2, 2, 2, 2, 4, 2, 2, 3, 2] → J=202, T=197, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 2, 2, 4, 2, 2, 3, 2] → J=218, T=199, cost=3 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 2, 4, 2, 2, 3, 2] → J=214, T=198, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 2, 4, 2, 2, 3, 2] → J=201, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 3, 2, 4, 2, 2, 3, 2] → J=205, T=199, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 4, 2, 2, 3, 2] → J=217, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 2, 5, 2, 2, 3, 2] → J=212, T=198, cost=3 → queued

[Iter 8] cost=2, J=219, T=199, edges=34, frontier=27, MILP_calls=35
  V_MIN=[2, 1, 2, 2, 2, 2, 3, 3, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (271 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (217 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (223 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (253 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (422 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (360 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (690 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (429 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (461 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1008 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (648 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (270 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7, 8] → expanding 7 children
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 3, 2, 2, 3, 2] → J=205, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 3, 3, 2, 2, 3, 2] → J=213, T=199, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 3, 3, 2, 2, 3, 2] → J=205, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 3, 3, 3, 2, 2, 3, 2] → J=205, T=196, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 4, 3, 2, 2, 3, 2] → J=215, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 3, 2] → J=218, T=200, cost=3 → queued

[Iter 9] cost=2, J=218, T=200, edges=34, frontier=32, MILP_calls=41
  V_MIN=[2, 1, 2, 2, 2, 2, 4, 2, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (319 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (159 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (238 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (221 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (216 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (160 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (183 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (175 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (53 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (205 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (74 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7, 8] → expanding 7 children
    V_MIN=[3, 1, 2, 2, 2, 2, 4, 2, 2, 2, 3, 2] → J=204, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 4, 2, 2, 2, 3, 2] → J=216, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 4, 2, 2, 2, 3, 2] → J=202, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 3, 4, 2, 2, 2, 3, 2] → J=207, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 5, 2, 2, 2, 3, 2] → J=213, T=199, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 4, 2, 3, 2, 3, 2] → J=215, T=200, cost=3 → queued

[Iter 10] cost=2, J=216, T=200, edges=35, frontier=37, MILP_calls=47
  V_MIN=[2, 1, 2, 3, 2, 2, 3, 2, 2, 2, 3, 2]
  [backtrack] Found solution with 326 backtracks in 0.00s
  [backtrack] Found solution with 256 backtracks in 0.00s
  [backtrack] Found solution with 159 backtracks in 0.00s
  [backtrack] Found solution with 161 backtracks in 0.00s
  [backtrack] Found solution with 174 backtracks in 0.00s
  [backtrack] Found solution with 645 backtracks in 0.00s
  [backtrack] Found solution with 759 backtracks in 0.00s
  [backtrack] Found solution with 957 backtracks in 0.00s
  [backtrack] Found solution with 1083 backtracks in 0.00s
  [backtrack] Found solution with 1431 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (353 backtracks in 0.00s)
  [backtrack] Found solution with 543 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=115.2s)
  Boundary nodes: [0, 3, 4, 5, 7, 8, 10] → expanding 7 children
    V_MIN=[3, 1, 2, 3, 2, 2, 3, 2, 2, 2, 3, 2] → J=205, T=199, cost=3 → queued
    V_MIN=[2, 1, 2, 4, 2, 2, 3, 2, 2, 2, 3, 2] → J=214, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 3, 3, 2, 3, 2, 2, 2, 3, 2] → J=207, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 3, 2, 3, 3, 2, 2, 2, 3, 2] → J=207, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 3, 2, 3, 2, 3, 2] → J=215, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 3, 2, 2, 2, 4, 2] → J=216, T=197, cost=3 → queued

[Iter 11] cost=2, J=216, T=198, edges=34, frontier=42, MILP_calls=53
  V_MIN=[2, 1, 2, 3, 2, 2, 2, 3, 2, 2, 3, 2]
  [backtrack] Found solution with 44 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.4s
  *** SOLUTION FOUND! J=216, T_tour=198.4s ***

============================================================
Search done: 11 iters, 53 MILP calls, 53 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 1, 0, 1, -3, 1, 3, -2, -1, 0, -2, -1, 0, -2, 0, -3, 3, -2, 0, -4, -1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 1, 0, 1, -3, 1, 3, -2, -1, 0, -2, -1, 0, -2, 0, -3, 3, -2, 0, -4, -1]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(1)), ((1, 5), np.int64(1)), ((2, 3), np.int64(-3)), ((2, 8), np.int64(1)), ((2, 11), np.int64(3)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(-1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-1)), ((6, 9), np.int64(-2)), ((7, 8), np.int64(-3)), ((7, 10), np.int64(3)), ((8, 9), np.int64(-2)), ((9, 10), np.int64(-4)), ((10, 11), np.int64(-1))]

Blocked edge 1: idx=8, edge=(3, 4), flow_B=-2  →  need Cm[8]=2
Blocked edge 2: idx=20, edge=(9, 10), flow_B=-4  →  need Cm[20]=4
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=53   ||Cm||_1=29

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -2, 0, 4, -1, 1, 1, 1, -1, 1, 0]

Cm = C_oriented @ beta*:
  [1, -1, 1, 1, -1, -1, 1, 1, 2, -1, -1, 2, 1, -1, 3, -2, 0, -1, 1, -1, 4, 1]

Original flow_B:
  [2, -2, 1, 0, 1, -3, 1, 3, -2, -1, 0, -2, -1, 0, -2, 0, -3, 3, -2, 0, -4, -1]

flow_B + Cm (corrected flow):
  [3, -3, 2, 1, 0, -4, 2, 4, 0, -2, -1, 0, 0, -1, 1, -2, -3, 2, -1, -1, 0, 0]

Verification:
  flow_corrected[8] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[20] = 0  (should be 0, Cm=4, d=4)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 53  (minimized by MIQP)
  ||Cm||_1  = 29
  ||flow_B||_2² = 82
  ||flow_corrected||_2² = 85

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       1           3    7.3     +7.3s
    1     (0, 11)        -2      -1          -3    6.8     +6.8s
    2      (1, 2)         1       1           2    4.1     +4.1s
    3      (1, 3)         0       1           1    7.6     +7.6s
    4      (1, 5)         1      -1           0    5.8     -5.8s
    5      (2, 3)        -3      -1          -4    4.5     +4.5s
    6      (2, 8)         1       1           2    7.3     +7.3s
    7     (2, 11)         3       1           4    4.8     +4.8s
    8      (3, 4)        -2       2           0    4.7     -9.4s ← BLOCKED
    9      (3, 6)        -1      -1          -2    5.8     +5.8s
   10      (3, 8)         0      -1          -1    6.7     +6.7s
   11      (4, 5)        -2       2           0    7.8    -15.6s
   12      (5, 6)        -1       1           0    7.3     -7.3s
   13      (6, 7)         0      -1          -1    6.0     +6.0s
   14      (6, 9)        -2       3           1    6.5     -6.5s
   15     (6, 10)         0      -2          -2    7.3    +14.6s
   16      (7, 8)        -3       0          -3    5.8          
   17     (7, 10)         3      -1           2    7.0     -7.0s
   18      (8, 9)        -2       1          -1    6.5     -6.5s
   19     (8, 11)         0      -1          -1    5.4     +5.4s
   20     (9, 10)        -4       4           0    4.1    -16.4s ← BLOCKED
   21    (10, 11)        -1       1           0    6.2     -6.2s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=3, out=3  OK
  Node 2: in=6, out=6  OK
  Node 3: in=4, out=4  OK
  Node 6: in=3, out=3  OK
  Node 7: in=3, out=3  OK
  Node 8: in=4, out=4  OK
  Node 9: in=1, out=1  OK
  Node 10: in=2, out=2  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 33 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 21

  Summary:
    Original path length:  34 edges
    Spliced path length:   33 edges
    Splices performed:     21
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           3         3  ✓
    1     (0, 11)          -3        -3  ✓
    2      (1, 2)           2         2  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)          -4        -4  ✓
    6      (2, 8)           2         2  ✓
    7     (2, 11)           4         4  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)           1         1  ✓
   15     (6, 10)          -2        -2  ✓
   16      (7, 8)          -3        -3  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)          -1        -1  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 41
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 2] → J=201, T=200, cost=0 → queued

[Iter 1] cost=0, J=201, T=200, edges=38, frontier=0, MILP_calls=1
  V_MIN=[2, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 65 backtracks in 0.00s
  [backtrack] Found solution with 67 backtracks in 0.00s
  [backtrack] Found solution with 145 backtracks in 0.00s
  [backtrack] Found solution with 116 backtracks in 0.00s
  [backtrack] Found solution with 586 backtracks in 0.00s
  [backtrack] Found solution with 666 backtracks in 0.00s
  [backtrack] Found solution with 722 backtracks in 0.00s
  [backtrack] Found solution with 55 backtracks in 0.00s
  [backtrack] Found solution with 55 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 72 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=126.0s)
  Boundary nodes: [0, 2, 4, 5, 6] → expanding 5 children
    V_MIN=[3, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 2] → J=194, T=199, cost=1 → queued
    V_MIN=[2, 1, 3, 1, 2, 2, 2, 2, 3, 2, 2, 2] → J=201, T=200, cost=1 → queued
    V_MIN=[2, 1, 2, 1, 3, 2, 2, 2, 3, 2, 2, 2] → J=189, T=198, cost=1 → queued
    V_MIN=[2, 1, 2, 1, 2, 3, 2, 2, 3, 2, 2, 2] → J=196, T=198, cost=1 → queued
    V_MIN=[2, 1, 2, 1, 2, 2, 3, 2, 3, 2, 2, 2] → J=201, T=200, cost=1 → queued

[Iter 2] cost=1, J=201, T=200, edges=37, frontier=4, MILP_calls=6
  V_MIN=[2, 1, 3, 1, 2, 2, 2, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 2011 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.5s
  *** SOLUTION FOUND! J=201, T_tour=199.5s ***

============================================================
Search done: 2 iters, 6 MILP calls, 6 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -2, 0, 0, 0, -3, 1, 2, 0, -2, 2, 2, 3, -1, 0, 5, -2, 3, -3, 2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -2, 0, 0, 0, -3, 1, 2, 0, -2, 2, 2, 3, -1, 0, 5, -2, 3, -3, 2, 0]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-2)), ((2, 8), np.int64(-3)), ((2, 11), np.int64(1)), ((3, 4), np.int64(2)), ((3, 8), np.int64(-2)), ((4, 5), np.int64(2)), ((5, 6), np.int64(2)), ((6, 7), np.int64(3)), ((6, 9), np.int64(-1)), ((7, 8), np.int64(5)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(3)), ((8, 11), np.int64(-3)), ((9, 10), np.int64(2))]

Blocked edge 1: idx=13, edge=(6, 7), flow_B=3  →  need Cm[13]=-3
Blocked edge 2: idx=19, edge=(8, 11), flow_B=-3  →  need Cm[19]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=42   ||Cm||_1=20

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, -1, 1, 0, 1, 0, 0, -2, 2, 0, -1]

Cm = C_oriented @ beta*:
  [0, 0, -1, 1, 0, 0, 0, -1, 0, -1, 2, 0, 0, -3, 1, 1, 0, -3, -1, 3, 0, -2]

Original flow_B:
  [-2, 2, -2, 0, 0, 0, -3, 1, 2, 0, -2, 2, 2, 3, -1, 0, 5, -2, 3, -3, 2, 0]

flow_B + Cm (corrected flow):
  [-2, 2, -3, 1, 0, 0, -3, 0, 2, -1, 0, 2, 2, 0, 0, 1, 5, -5, 2, 0, 2, -2]

Verification:
  flow_corrected[13] = 0  (should be 0, Cm=-3, d=-3)
  flow_corrected[19] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 42  (minimized by MIQP)
  ||Cm||_1  = 20
  ||flow_B||_2² = 99
  ||flow_corrected||_2² = 103

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    4.7          
    1     (0, 11)         2       0           2    5.3          
    2      (1, 2)        -2      -1          -3    5.9     +5.9s
    3      (1, 3)         0       1           1    4.3     +4.3s
    4      (1, 5)         0       0           0    6.8          
    5      (2, 3)         0       0           0    5.3          
    6      (2, 8)        -3       0          -3    7.0          
    7     (2, 11)         1      -1           0    5.6     -5.6s
    8      (3, 4)         2       0           2    6.4          
    9      (3, 6)         0      -1          -1    6.9     +6.9s
   10      (3, 8)        -2       2           0    5.7    -11.4s
   11      (4, 5)         2       0           2    5.6          
   12      (5, 6)         2       0           2    4.9          
   13      (6, 7)         3      -3           0    5.8    -17.4s ← BLOCKED
   14      (6, 9)        -1       1           0    5.5     -5.5s
   15     (6, 10)         0       1           1    6.3     +6.3s
   16      (7, 8)         5       0           5    4.4          
   17     (7, 10)        -2      -3          -5    7.0    +21.0s
   18      (8, 9)         3      -1           2    4.3     -4.3s
   19     (8, 11)        -3       3           0    4.5    -13.5s ← BLOCKED
   20     (9, 10)         2       0           2    5.3          
   21    (10, 11)         0      -2          -2    6.6    +13.2s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=3, out=3  OK
  Node 2: in=3, out=3  OK
  Node 3: in=2, out=2  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=2, out=2  OK
  Node 7: in=5, out=5  OK
  Node 8: in=5, out=5  OK
  Node 9: in=2, out=2  OK
  Node 10: in=5, out=5  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 21

  Summary:
    Original path length:  37 edges
    Spliced path length:   35 edges
    Splices performed:     21
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)          -3        -3  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)          -3        -3  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           2         2  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           2         2  ✓
   12      (5, 6)           2         2  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)           5         5  ✓
   17     (7, 10)          -5        -5  ✓
   18      (8, 9)           2         2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)          -2        -2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 42
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 1, 3] → J=248, T=200, cost=0 → queued

[Iter 1] cost=0, J=248, T=200, edges=39, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 1, 3]
  [backtrack] Found solution with 2 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.6s
  *** SOLUTION FOUND! J=248, T_tour=199.6s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 5, -1, -2, 0, 0, 5, 2, -3, 0, 2, 0, 0, -3, 0, -3, 3, 0, -3, -3, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 5, -1, -2, 0, 0, 5, 2, -3, 0, 2, 0, 0, -3, 0, -3, 3, 0, -3, -3, 0]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(5)), ((1, 3), np.int64(-1)), ((1, 5), np.int64(-2)), ((2, 11), np.int64(5)), ((3, 4), np.int64(2)), ((3, 6), np.int64(-3)), ((4, 5), np.int64(2)), ((6, 9), np.int64(-3)), ((7, 8), np.int64(-3)), ((7, 10), np.int64(3)), ((8, 11), np.int64(-3)), ((9, 10), np.int64(-3))]

Blocked edge 1: idx=8, edge=(3, 4), flow_B=2  →  need Cm[8]=-2
Blocked edge 2: idx=14, edge=(6, 9), flow_B=-3  →  need Cm[14]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=34   ||Cm||_1=20

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, 1, 0, 1, 0, -1, 0, -2, 1, -1, 0]

Cm = C_oriented @ beta*:
  [0, 0, 0, -1, 1, 0, 0, 0, -2, 1, 0, -2, -1, -1, 3, -2, -1, 0, -2, 1, 1, -1]

Original flow_B:
  [2, -2, 5, -1, -2, 0, 0, 5, 2, -3, 0, 2, 0, 0, -3, 0, -3, 3, 0, -3, -3, 0]

flow_B + Cm (corrected flow):
  [2, -2, 5, -2, -1, 0, 0, 5, 0, -2, 0, 0, -1, -1, 0, -2, -4, 3, -2, -2, -2, -1]

Verification:
  flow_corrected[8] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[14] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 34  (minimized by MIQP)
  ||Cm||_1  = 20
  ||flow_B||_2² = 125
  ||flow_corrected||_2² = 111

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    7.3          
    1     (0, 11)        -2       0          -2    4.8          
    2      (1, 2)         5       0           5    4.7          
    3      (1, 3)        -1      -1          -2    4.7     +4.7s
    4      (1, 5)        -2       1          -1    5.2     -5.2s
    5      (2, 3)         0       0           0    6.1          
    6      (2, 8)         0       0           0    5.7          
    7     (2, 11)         5       0           5    5.2          
    8      (3, 4)         2      -2           0    6.4    -12.8s ← BLOCKED
    9      (3, 6)        -3       1          -2    4.6     -4.6s
   10      (3, 8)         0       0           0    5.2          
   11      (4, 5)         2      -2           0    5.5    -11.0s
   12      (5, 6)         0      -1          -1    5.8     +5.8s
   13      (6, 7)         0      -1          -1    7.1     +7.1s
   14      (6, 9)        -3       3           0    4.8    -14.4s ← BLOCKED
   15     (6, 10)         0      -2          -2    6.1    +12.2s
   16      (7, 8)        -3      -1          -4    6.4     +6.4s
   17     (7, 10)         3       0           3    4.2          
   18      (8, 9)         0      -2          -2    6.4    +12.8s
   19     (8, 11)        -3       1          -2    4.7     -4.7s
   20     (9, 10)        -3       1          -2    4.3     -4.3s
   21    (10, 11)         0      -1          -1    7.8     +7.8s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=5, out=5  OK
  Node 2: in=5, out=5  OK
  Node 3: in=2, out=2  OK
  Node 5: in=1, out=1  OK
  Node 6: in=3, out=3  OK
  Node 7: in=4, out=4  OK
  Node 8: in=4, out=4  OK
  Node 9: in=2, out=2  OK
  Node 10: in=4, out=4  OK
  Node 11: in=5, out=5  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 37 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 21

  Summary:
    Original path length:  39 edges
    Spliced path length:   37 edges
    Splices performed:     21
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           5         5  ✓
    3      (1, 3)          -2        -2  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           5         5  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)          -2        -2  ✓
   16      (7, 8)          -4        -4  ✓
   17     (7, 10)           3         3  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)          -2        -2  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 43
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 3, 2, 2, 1, 3, 2, 3] → J=207, T=200, cost=0 → queued

[Iter 1] cost=0, J=207, T=200, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 3, 2, 2, 1, 3, 2, 3]
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.5s
  *** SOLUTION FOUND! J=207, T_tour=199.5s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, 0, 0, -3, -2, 2, 0, -2, 0, 0, -2, -5, -1, -4, 0, 1, -2, 3, 0, -1, -3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, 0, 0, -3, -2, 2, 0, -2, 0, 0, -2, -5, -1, -4, 0, 1, -2, 3, 0, -1, -3]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 5), np.int64(-3)), ((2, 3), np.int64(-2)), ((2, 8), np.int64(2)), ((3, 4), np.int64(-2)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-5)), ((6, 7), np.int64(-1)), ((6, 9), np.int64(-4)), ((7, 8), np.int64(1)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(3)), ((9, 10), np.int64(-1)), ((10, 11), np.int64(-3))]

Blocked edge 1: idx=4, edge=(1, 5), flow_B=-3  →  need Cm[4]=3
Blocked edge 2: idx=13, edge=(6, 7), flow_B=-1  →  need Cm[13]=1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=25   ||Cm||_1=15

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, 0, 1, 0, 1, 2, 1, 1, 0, -3, 1]

Cm = C_oriented @ beta*:
  [1, -1, 0, -2, 3, 0, 0, 0, -1, -1, 0, -1, 2, 1, 0, 0, 1, 0, 0, 1, 0, 0]

Original flow_B:
  [-3, 3, 0, 0, -3, -2, 2, 0, -2, 0, 0, -2, -5, -1, -4, 0, 1, -2, 3, 0, -1, -3]

flow_B + Cm (corrected flow):
  [-2, 2, 0, -2, 0, -2, 2, 0, -3, -1, 0, -3, -3, 0, -4, 0, 2, -2, 3, 1, -1, -3]

Verification:
  flow_corrected[4] = 0  (should be 0, Cm=3, d=3)
  flow_corrected[13] = 0  (should be 0, Cm=1, d=1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 25  (minimized by MIQP)
  ||Cm||_1  = 15
  ||flow_B||_2² = 109
  ||flow_corrected||_2² = 92

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       1          -2    5.0     -5.0s
    1     (0, 11)         3      -1           2    4.2     -4.2s
    2      (1, 2)         0       0           0    7.5          
    3      (1, 3)         0      -2          -2    4.9     +9.8s
    4      (1, 5)        -3       3           0    5.6    -16.8s ← BLOCKED
    5      (2, 3)        -2       0          -2    5.3          
    6      (2, 8)         2       0           2    4.3          
    7     (2, 11)         0       0           0    7.4          
    8      (3, 4)        -2      -1          -3    7.4     +7.4s
    9      (3, 6)         0      -1          -1    7.9     +7.9s
   10      (3, 8)         0       0           0    5.5          
   11      (4, 5)        -2      -1          -3    7.8     +7.8s
   12      (5, 6)        -5       2          -3    5.8    -11.6s
   13      (6, 7)        -1       1           0    6.7     -6.7s ← BLOCKED
   14      (6, 9)        -4       0          -4    4.3          
   15     (6, 10)         0       0           0    7.6          
   16      (7, 8)         1       1           2    5.2     +5.2s
   17     (7, 10)        -2       0          -2    5.0          
   18      (8, 9)         3       0           3    4.0          
   19     (8, 11)         0       1           1    6.2     +6.2s
   20     (9, 10)        -1       0          -1    5.9          
   21    (10, 11)        -3       0          -3    6.5          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=2, out=2  OK
  Node 2: in=2, out=2  OK
  Node 3: in=4, out=4  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=4, out=4  OK
  Node 7: in=2, out=2  OK
  Node 8: in=4, out=4  OK
  Node 9: in=4, out=4  OK
  Node 10: in=3, out=3  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 16

  Summary:
    Original path length:  37 edges
    Spliced path length:   36 edges
    Splices performed:     16
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)          -2        -2  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)           2         2  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -3        -3  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -3        -3  ✓
   12      (5, 6)          -3        -3  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)          -4        -4  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           2         2  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           3         3  ✓
   19     (8, 11)           1         1  ✓
   20     (9, 10)          -1        -1  ✓
   21    (10, 11)          -3        -3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 44
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2] → J=236, T=198, cost=0 → queued

[Iter 1] cost=0, J=236, T=198, edges=38, frontier=0, MILP_calls=1
  V_MIN=[3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (184 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (171 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (418 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (246 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (246 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (228 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (350 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (440 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (439 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (156 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7] → expanding 6 children
    V_MIN=[4, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2] → J=231, T=199, cost=1 → queued
    V_MIN=[3, 1, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2] → J=232, T=200, cost=1 → queued
    V_MIN=[3, 1, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2] → J=220, T=200, cost=1 → queued
    V_MIN=[3, 1, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2] → J=227, T=200, cost=1 → queued
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 2, 2, 2, 3, 2] → J=235, T=200, cost=1 → queued
    V_MIN=[3, 1, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2] → J=236, T=199, cost=1 → queued

[Iter 2] cost=1, J=236, T=199, edges=38, frontier=5, MILP_calls=7
  V_MIN=[3, 1, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7] → expanding 6 children
    V_MIN=[4, 1, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2] → J=228, T=200, cost=2 → queued
    V_MIN=[3, 1, 2, 3, 2, 2, 2, 3, 2, 2, 3, 2] → J=227, T=199, cost=2 → queued
    V_MIN=[3, 1, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2] → J=215, T=200, cost=2 → queued
    V_MIN=[3, 1, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2] → J=226, T=197, cost=2 → queued
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 3, 2, 2, 3, 2] → J=230, T=200, cost=2 → queued
    V_MIN=[3, 1, 2, 2, 2, 2, 2, 4, 2, 2, 3, 2] → J=228, T=200, cost=2 → queued

[Iter 3] cost=1, J=235, T=200, edges=38, frontier=10, MILP_calls=13
  V_MIN=[3, 1, 2, 2, 2, 2, 3, 2, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (454 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (445 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (414 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (756 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (803 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (883 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (973 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1059 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (655 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (365 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1398 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (292 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7] → expanding 6 children
    V_MIN=[4, 1, 2, 2, 2, 2, 3, 2, 2, 2, 3, 2] → J=226, T=199, cost=2 → queued
    V_MIN=[3, 1, 2, 3, 2, 2, 3, 2, 2, 2, 3, 2] → J=232, T=200, cost=2 → queued
    V_MIN=[3, 1, 2, 2, 3, 2, 3, 2, 2, 2, 3, 2] → J=220, T=200, cost=2 → queued
    V_MIN=[3, 1, 2, 2, 2, 3, 3, 2, 2, 2, 3, 2] → J=227, T=200, cost=2 → queued
    V_MIN=[3, 1, 2, 2, 2, 2, 4, 2, 2, 2, 3, 2] → J=230, T=200, cost=2 → queued

[Iter 4] cost=1, J=232, T=200, edges=38, frontier=14, MILP_calls=18
  V_MIN=[3, 1, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (348 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (327 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (232 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (446 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (485 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (403 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (353 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (343 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (632 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (648 backtracks in 0.04s)
  [backtrack] EXHAUSTED search space (300 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (216 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7] → expanding 6 children
    V_MIN=[4, 1, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2] → J=224, T=200, cost=2 → queued
    V_MIN=[3, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2] → J=230, T=199, cost=2 → queued
    V_MIN=[3, 1, 2, 4, 2, 2, 2, 2, 2, 2, 3, 2] → J=226, T=197, cost=2 → queued
    V_MIN=[3, 1, 2, 3, 3, 2, 2, 2, 2, 2, 3, 2] → J=220, T=199, cost=2 → queued
    V_MIN=[3, 1, 2, 3, 2, 3, 2, 2, 2, 2, 3, 2] → J=223, T=199, cost=2 → queued

[Iter 5] cost=1, J=231, T=199, edges=38, frontier=18, MILP_calls=23
  V_MIN=[4, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7] → expanding 6 children
    V_MIN=[5, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2] → J=224, T=200, cost=2 → queued
    V_MIN=[4, 1, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2] → J=215, T=200, cost=2 → queued
    V_MIN=[4, 1, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2] → J=222, T=198, cost=2 → queued

[Iter 6] cost=1, J=227, T=200, edges=38, frontier=20, MILP_calls=26
  V_MIN=[3, 1, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2]
  [backtrack] Found solution with 108 backtracks in 0.00s
  [backtrack] Found solution with 96 backtracks in 0.00s
  [backtrack] Found solution with 482 backtracks in 0.00s
  [backtrack] Found solution with 1249 backtracks in 0.00s
  [backtrack] Found solution with 940 backtracks in 0.00s
  [backtrack] Found solution with 52 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 49 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 91 backtracks in 0.00s
  [backtrack] Found solution with 112 backtracks in 0.00s
  [backtrack] Found solution with 392 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=120.7s)
  Boundary nodes: [0, 2, 3, 4, 5, 7] → expanding 6 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 2, 2, 3, 2] → J=225, T=198, cost=2 → queued
    V_MIN=[3, 1, 2, 2, 3, 3, 2, 2, 2, 2, 3, 2] → J=220, T=200, cost=2 → queued
    V_MIN=[3, 1, 2, 2, 2, 4, 2, 2, 2, 2, 3, 2] → J=222, T=198, cost=2 → queued

[Iter 7] cost=1, J=220, T=200, edges=37, frontier=22, MILP_calls=29
  V_MIN=[3, 1, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (369 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (320 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (259 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (158 backtracks in 0.00s)
  [backtrack] Found solution with 333 backtracks in 0.00s
  [backtrack] Found solution with 158 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (238 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (364 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (374 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (211 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (130 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=104.1s)
  Boundary nodes: [0, 2, 4, 7] → expanding 4 children
    V_MIN=[3, 1, 3, 2, 3, 2, 2, 2, 2, 2, 3, 2] → J=220, T=200, cost=2 → queued
    V_MIN=[3, 1, 2, 2, 4, 2, 2, 2, 2, 2, 3, 2] → J=204, T=199, cost=2 → queued

[Iter 8] cost=2, J=232, T=200, edges=38, frontier=23, MILP_calls=31
  V_MIN=[3, 1, 2, 3, 2, 2, 3, 2, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (348 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (327 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (232 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (446 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (485 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (403 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (353 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (343 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (632 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (648 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (300 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (216 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7] → expanding 7 children
    V_MIN=[4, 1, 2, 3, 2, 2, 3, 2, 2, 2, 3, 2] → J=224, T=200, cost=3 → queued
    V_MIN=[3, 1, 3, 3, 2, 2, 3, 2, 2, 2, 3, 2] → J=230, T=199, cost=3 → queued
    V_MIN=[3, 1, 2, 4, 2, 2, 3, 2, 2, 2, 3, 2] → J=226, T=197, cost=3 → queued
    V_MIN=[3, 1, 2, 3, 3, 2, 3, 2, 2, 2, 3, 2] → J=220, T=200, cost=3 → queued
    V_MIN=[3, 1, 2, 3, 2, 3, 3, 2, 2, 2, 3, 2] → J=223, T=199, cost=3 → queued
    V_MIN=[3, 1, 2, 3, 2, 2, 4, 2, 2, 2, 3, 2] → J=229, T=199, cost=3 → queued
    V_MIN=[3, 1, 2, 3, 2, 2, 3, 3, 2, 2, 3, 2] → J=227, T=199, cost=3 → queued

[Iter 9] cost=2, J=230, T=200, edges=38, frontier=29, MILP_calls=38
  V_MIN=[3, 1, 2, 2, 2, 2, 3, 3, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (2433 backtracks in 0.01s)
  [backtrack] Found solution with 1059 backtracks in 0.00s
  [backtrack] Found solution with 1420 backtracks in 0.00s
  [backtrack] Found solution with 17 backtracks in 0.00s
  [backtrack] Found solution with 1360 backtracks in 0.00s
  [backtrack] Found solution with 1467 backtracks in 0.00s
  [backtrack] Found solution with 1768 backtracks in 0.00s
  [backtrack] Found solution with 14 backtracks in 0.00s
  [backtrack] Found solution with 15 backtracks in 0.00s
  [backtrack] Found solution with 2770 backtracks in 0.01s
  [backtrack] EXHAUSTED search space (2875 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2256 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=100.4s)
  Boundary nodes: [0, 3, 4, 5, 6, 7] → expanding 6 children
    V_MIN=[4, 1, 2, 2, 2, 2, 3, 3, 2, 2, 3, 2] → J=225, T=200, cost=3 → queued
    V_MIN=[3, 1, 2, 2, 3, 2, 3, 3, 2, 2, 3, 2] → J=215, T=198, cost=3 → queued
    V_MIN=[3, 1, 2, 2, 2, 3, 3, 3, 2, 2, 3, 2] → J=226, T=198, cost=3 → queued
    V_MIN=[3, 1, 2, 2, 2, 2, 4, 3, 2, 2, 3, 2] → J=229, T=199, cost=3 → queued
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 4, 2, 2, 3, 2] → J=228, T=200, cost=3 → queued

[Iter 10] cost=2, J=230, T=199, edges=38, frontier=33, MILP_calls=43
  V_MIN=[3, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (234 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (263 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (328 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (303 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (260 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (201 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (172 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (296 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (179 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (535 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (427 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (137 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7] → expanding 5 children
    V_MIN=[4, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2] → J=224, T=200, cost=3 → queued
    V_MIN=[3, 1, 3, 4, 2, 2, 2, 2, 2, 2, 3, 2] → J=226, T=198, cost=3 → queued
    V_MIN=[3, 1, 3, 3, 3, 2, 2, 2, 2, 2, 3, 2] → J=220, T=200, cost=3 → queued
    V_MIN=[3, 1, 3, 3, 2, 3, 2, 2, 2, 2, 3, 2] → J=223, T=199, cost=3 → queued
    V_MIN=[3, 1, 3, 3, 2, 2, 2, 3, 2, 2, 3, 2] → J=227, T=199, cost=3 → queued

[Iter 11] cost=2, J=230, T=200, edges=38, frontier=37, MILP_calls=48
  V_MIN=[3, 1, 2, 2, 2, 2, 4, 2, 2, 2, 3, 2]
  [backtrack] Found solution with 161 backtracks in 0.00s
  [backtrack] Found solution with 136 backtracks in 0.00s
  [backtrack] Found solution with 130 backtracks in 0.00s
  [backtrack] Found solution with 137 backtracks in 0.00s
    ✓ Latency-feasible! source=3, T_tour=199.8s
  *** SOLUTION FOUND! J=230, T_tour=199.8s ***

============================================================
Search done: 11 iters, 48 MILP calls, 48 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, -3, 0, 0, 0, -1, -2, -2, 1, 1, -2, -2, 2, 0, -3, 0, 2, 3, -3, 3, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, -3, 0, 0, 0, -1, -2, -2, 1, 1, -2, -2, 2, 0, -3, 0, 2, 3, -3, 3, 2]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 2), np.int64(-3)), ((2, 8), np.int64(-1)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(1)), ((3, 8), np.int64(1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(2)), ((6, 10), np.int64(-3)), ((7, 10), np.int64(2)), ((8, 9), np.int64(3)), ((8, 11), np.int64(-3)), ((9, 10), np.int64(3)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=7, edge=(2, 11), flow_B=-2  →  need Cm[7]=2
Blocked edge 2: idx=15, edge=(6, 10), flow_B=-3  →  need Cm[15]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=32   ||Cm||_1=20

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, -2, -1, -1, 1, 1, 1, 2, -1, -1, 2]

Cm = C_oriented @ beta*:
  [1, -1, 0, 0, 1, 0, -2, 2, 0, 1, -1, 0, 1, 0, -1, 3, 1, -1, 0, -2, -1, 1]

Original flow_B:
  [-3, 3, -3, 0, 0, 0, -1, -2, -2, 1, 1, -2, -2, 2, 0, -3, 0, 2, 3, -3, 3, 2]

flow_B + Cm (corrected flow):
  [-2, 2, -3, 0, 1, 0, -3, 0, -2, 2, 0, -2, -1, 2, -1, 0, 1, 1, 3, -5, 2, 3]

Verification:
  flow_corrected[7] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[15] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 32  (minimized by MIQP)
  ||Cm||_1  = 20
  ||flow_B||_2² = 94
  ||flow_corrected||_2² = 94

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       1          -2    5.7     -5.7s
    1     (0, 11)         3      -1           2    4.5     -4.5s
    2      (1, 2)        -3       0          -3    4.9          
    3      (1, 3)         0       0           0    7.8          
    4      (1, 5)         0       1           1    7.8     +7.8s
    5      (2, 3)         0       0           0    7.5          
    6      (2, 8)        -1      -2          -3    6.6    +13.2s
    7     (2, 11)        -2       2           0    4.9     -9.8s ← BLOCKED
    8      (3, 4)        -2       0          -2    6.5          
    9      (3, 6)         1       1           2    4.6     +4.6s
   10      (3, 8)         1      -1           0    5.8     -5.8s
   11      (4, 5)        -2       0          -2    7.5          
   12      (5, 6)        -2       1          -1    5.0     -5.0s
   13      (6, 7)         2       0           2    6.7          
   14      (6, 9)         0      -1          -1    7.5     +7.5s
   15     (6, 10)        -3       3           0    4.6    -13.8s ← BLOCKED
   16      (7, 8)         0       1           1    6.3     +6.3s
   17     (7, 10)         2      -1           1    4.6     -4.6s
   18      (8, 9)         3       0           3    4.7          
   19     (8, 11)        -3      -2          -5    4.4     +8.8s
   20     (9, 10)         3      -1           2    4.8     -4.8s
   21    (10, 11)         2       1           3    5.8     +5.8s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=3, out=3  OK
  Node 2: in=3, out=3  OK
  Node 3: in=2, out=2  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=3, out=3  OK
  Node 7: in=2, out=2  OK
  Node 8: in=6, out=6  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=5, out=5  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 27

  Summary:
    Original path length:  38 edges
    Spliced path length:   36 edges
    Splices performed:     27
    Path is continuous:    True
    Returns to source 3: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)          -3        -3  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)          -3        -3  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           2         2  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)           2         2  ✓
   14      (6, 9)          -1        -1  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)           1         1  ✓
   18      (8, 9)           3         3  ✓
   19     (8, 11)          -5        -5  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           3         3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 45
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 2, 2, 2, 2, 1, 2, 2, 2, 3, 2] → J=189, T=198, cost=0 → queued

[Iter 1] cost=0, J=189, T=198, edges=34, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 2, 2, 2, 2, 1, 2, 2, 2, 3, 2]
  [backtrack] Found solution with 416 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=197.9s
  *** SOLUTION FOUND! J=189, T_tour=197.9s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, -2, -2, 1, 0, 0, -2, -2, 0, 0, -2, -1, 2, 0, -3, 0, 2, -2, 2, -2, -3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, -2, -2, 1, 0, 0, -2, -2, 0, 0, -2, -1, 2, 0, -3, 0, 2, -2, 2, -2, -3]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 2), np.int64(-2)), ((1, 3), np.int64(-2)), ((1, 5), np.int64(1)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(-2)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-1)), ((6, 7), np.int64(2)), ((6, 10), np.int64(-3)), ((7, 10), np.int64(2)), ((8, 9), np.int64(-2)), ((8, 11), np.int64(2)), ((9, 10), np.int64(-2)), ((10, 11), np.int64(-3))]

Blocked edge 1: idx=15, edge=(6, 10), flow_B=-3  →  need Cm[15]=3
Blocked edge 2: idx=19, edge=(8, 11), flow_B=2  →  need Cm[19]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=24   ||Cm||_1=14

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -2, 0, -1, 1, 0, 0, 1, -2, 0, 1]

Cm = C_oriented @ beta*:
  [0, 0, 0, 0, 0, 1, -1, 0, 0, 1, 0, 0, 0, -1, -1, 3, -1, 0, 0, -2, -1, 2]

Original flow_B:
  [-3, 3, -2, -2, 1, 0, 0, -2, -2, 0, 0, -2, -1, 2, 0, -3, 0, 2, -2, 2, -2, -3]

flow_B + Cm (corrected flow):
  [-3, 3, -2, -2, 1, 1, -1, -2, -2, 1, 0, -2, -1, 1, -1, 0, -1, 2, -2, 0, -3, -1]

Verification:
  flow_corrected[15] = 0  (should be 0, Cm=3, d=3)
  flow_corrected[19] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 24  (minimized by MIQP)
  ||Cm||_1  = 14
  ||flow_B||_2² = 78
  ||flow_corrected||_2² = 64

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       0          -3    8.0          
    1     (0, 11)         3       0           3    5.9          
    2      (1, 2)        -2       0          -2    6.5          
    3      (1, 3)        -2       0          -2    5.1          
    4      (1, 5)         1       0           1    7.9          
    5      (2, 3)         0       1           1    6.7     +6.7s
    6      (2, 8)         0      -1          -1    5.8     +5.8s
    7     (2, 11)        -2       0          -2    5.2          
    8      (3, 4)        -2       0          -2    6.0          
    9      (3, 6)         0       1           1    4.4     +4.4s
   10      (3, 8)         0       0           0    4.9          
   11      (4, 5)        -2       0          -2    5.9          
   12      (5, 6)        -1       0          -1    5.0          
   13      (6, 7)         2      -1           1    5.6     -5.6s
   14      (6, 9)         0      -1          -1    7.3     +7.3s
   15     (6, 10)        -3       3           0    4.3    -12.9s ← BLOCKED
   16      (7, 8)         0      -1          -1    7.7     +7.7s
   17     (7, 10)         2       0           2    4.9          
   18      (8, 9)        -2       0          -2    6.8          
   19     (8, 11)         2      -2           0    4.4     -8.8s ← BLOCKED
   20     (9, 10)        -2      -1          -3    6.4     +6.4s
   21    (10, 11)        -3       2          -1    5.6    -11.2s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=4, out=4  OK
  Node 2: in=3, out=3  OK
  Node 3: in=3, out=3  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=2, out=2  OK
  Node 7: in=2, out=2  OK
  Node 8: in=2, out=2  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 32 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 18

  Summary:
    Original path length:  34 edges
    Spliced path length:   32 edges
    Splices performed:     18
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -3        -3  ✓
    1     (0, 11)           3         3  ✓
    2      (1, 2)          -2        -2  ✓
    3      (1, 3)          -2        -2  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)           1         1  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)          -2        -2  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)          -1        -1  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)          -3        -3  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 46
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 2, 2, 2, 3, 1, 2, 3, 2, 2, 2] → J=248, T=200, cost=0 → queued

[Iter 1] cost=0, J=248, T=200, edges=38, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 2, 2, 2, 3, 1, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 5 backtracks in 0.00s
  [backtrack] Found solution with 4 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
    ✓ Latency-feasible! source=3, T_tour=199.9s
  DFS: latency violated (1 nodes, worst_gap=143.8s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 2, 2, 3, 1, 2, 3, 2, 2, 2] → J=241, T=199, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 3, 3, 1, 2, 3, 2, 2, 2] → J=248, T=197, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 4, 1, 2, 3, 2, 2, 2] → J=248, T=197, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2] → J=246, T=198, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 3, 1, 3, 3, 2, 2, 2] → J=243, T=198, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 3, 1, 2, 3, 3, 2, 2] → J=245, T=198, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 3, 1, 2, 3, 2, 3, 2] → J=244, T=199, cost=1 → queued

[Iter 2] cost=1, J=248, T=197, edges=38, frontier=6, MILP_calls=8
  V_MIN=[3, 2, 2, 2, 3, 3, 1, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=197.2s
  *** SOLUTION FOUND! J=248, T_tour=197.2s ***

============================================================
Search done: 2 iters, 8 MILP calls, 8 states visited

Original flow_B is latency-feasible ✓
  flow_B = [3, -3, -1, 0, 4, 1, -2, 0, -3, -1, 5, -3, 1, 0, 0, 0, -2, 2, -2, 3, -2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [3, -3, -1, 0, 4, 1, -2, 0, -3, -1, 5, -3, 1, 0, 0, 0, -2, 2, -2, 3, -2, 0]
  Non-zero edges: [((0, 1), np.int64(3)), ((0, 11), np.int64(-3)), ((1, 2), np.int64(-1)), ((1, 5), np.int64(4)), ((2, 3), np.int64(1)), ((2, 8), np.int64(-2)), ((3, 4), np.int64(-3)), ((3, 6), np.int64(-1)), ((3, 8), np.int64(5)), ((4, 5), np.int64(-3)), ((5, 6), np.int64(1)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(2)), ((8, 9), np.int64(-2)), ((8, 11), np.int64(3)), ((9, 10), np.int64(-2))]

Blocked edge 1: idx=1, edge=(0, 11), flow_B=-3  →  need Cm[1]=3
Blocked edge 2: idx=8, edge=(3, 4), flow_B=-3  →  need Cm[8]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=58   ||Cm||_1=28

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 2, -1, -1, -1, 1, -3, -1, 1, 2, 0]

Cm = C_oriented @ beta*:
  [-3, 3, -2, 1, -2, 0, 0, -2, 3, -1, -1, 3, 1, 1, 0, -1, 0, 1, -1, 0, -1, -1]

Original flow_B:
  [3, -3, -1, 0, 4, 1, -2, 0, -3, -1, 5, -3, 1, 0, 0, 0, -2, 2, -2, 3, -2, 0]

flow_B + Cm (corrected flow):
  [0, 0, -3, 1, 2, 1, -2, -2, 0, -2, 4, 0, 2, 1, 0, -1, -2, 3, -3, 3, -3, -1]

Verification:
  flow_corrected[1] = 0  (should be 0, Cm=3, d=3)
  flow_corrected[8] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 58  (minimized by MIQP)
  ||Cm||_1  = 28
  ||flow_B||_2² = 110
  ||flow_corrected||_2² = 90

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         3      -3           0    5.7    -17.1s
    1     (0, 11)        -3       3           0    7.0    -21.0s ← BLOCKED
    2      (1, 2)        -1      -2          -3    7.5    +15.0s
    3      (1, 3)         0       1           1    5.3     +5.3s
    4      (1, 5)         4      -2           2    4.4     -8.8s
    5      (2, 3)         1       0           1    7.2          
    6      (2, 8)        -2       0          -2    5.6          
    7     (2, 11)         0      -2          -2    6.5    +13.0s
    8      (3, 4)        -3       3           0    4.1    -12.3s ← BLOCKED
    9      (3, 6)        -1      -1          -2    5.2     +5.2s
   10      (3, 8)         5      -1           4    4.2     -4.2s
   11      (4, 5)        -3       3           0    5.5    -16.5s
   12      (5, 6)         1       1           2    5.0     +5.0s
   13      (6, 7)         0       1           1    8.0     +8.0s
   14      (6, 9)         0       0           0    5.6          
   15     (6, 10)         0      -1          -1    5.2     +5.2s
   16      (7, 8)        -2       0          -2    4.9          
   17     (7, 10)         2       1           3    6.0     +6.0s
   18      (8, 9)        -2      -1          -3    4.2     +4.2s
   19     (8, 11)         3       0           3    5.2          
   20     (9, 10)        -2      -1          -3    4.9     +4.9s
   21    (10, 11)         0      -1          -1    7.9     +7.9s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=3, out=3  OK
  Node 2: in=4, out=4  OK
  Node 3: in=4, out=4  OK
  Node 5: in=2, out=2  OK
  Node 6: in=3, out=3  OK
  Node 7: in=3, out=3  OK
  Node 8: in=7, out=7  OK
  Node 9: in=3, out=3  OK
  Node 10: in=4, out=4  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 25

  Summary:
    Original path length:  38 edges
    Spliced path length:   36 edges
    Splices performed:     25
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)          -3        -3  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           1         1  ✓
    6      (2, 8)          -2        -2  ✓
    7     (2, 11)          -2        -2  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)           4         4  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)           2         2  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)          -2        -2  ✓
   17     (7, 10)           3         3  ✓
   18      (8, 9)          -3        -3  ✓
   19     (8, 11)           3         3  ✓
   20     (9, 10)          -3        -3  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 47
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1] → J=233, T=200, cost=0 → queued

[Iter 1] cost=0, J=233, T=200, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1]
  [backtrack] Found solution with 49 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=200.0s
  *** SOLUTION FOUND! J=233, T_tour=200.0s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -4, -2, 4, 0, -3, -1, -4, 2, 0, -4, 0, 2, 0, 0, 0, 2, -2, -1, -2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -4, -2, 4, 0, -3, -1, -4, 2, 0, -4, 0, 2, 0, 0, 0, 2, -2, -1, -2, 0]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-4)), ((1, 3), np.int64(-2)), ((1, 5), np.int64(4)), ((2, 8), np.int64(-3)), ((2, 11), np.int64(-1)), ((3, 4), np.int64(-4)), ((3, 6), np.int64(2)), ((4, 5), np.int64(-4)), ((6, 7), np.int64(2)), ((7, 10), np.int64(2)), ((8, 9), np.int64(-2)), ((8, 11), np.int64(-1)), ((9, 10), np.int64(-2))]

Blocked edge 1: idx=8, edge=(3, 4), flow_B=-4  →  need Cm[8]=4
Blocked edge 2: idx=20, edge=(9, 10), flow_B=-2  →  need Cm[20]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=59   ||Cm||_1=25

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -1, 1, 2, 1, 2, 0, 2, -1, 2, 2]

Cm = C_oriented @ beta*:
  [0, 0, 0, 2, -2, 1, 0, -1, 4, 0, -1, 4, 2, 1, 2, -1, 1, 0, 0, 0, 2, 1]

Original flow_B:
  [-2, 2, -4, -2, 4, 0, -3, -1, -4, 2, 0, -4, 0, 2, 0, 0, 0, 2, -2, -1, -2, 0]

flow_B + Cm (corrected flow):
  [-2, 2, -4, 0, 2, 1, -3, -2, 0, 2, -1, 0, 2, 3, 2, -1, 1, 2, -2, -1, 0, 1]

Verification:
  flow_corrected[8] = 0  (should be 0, Cm=4, d=4)
  flow_corrected[20] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 59  (minimized by MIQP)
  ||Cm||_1  = 25
  ||flow_B||_2² = 107
  ||flow_corrected||_2² = 76

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    4.4          
    1     (0, 11)         2       0           2    5.2          
    2      (1, 2)        -4       0          -4    6.6          
    3      (1, 3)        -2       2           0    5.3    -10.6s
    4      (1, 5)         4      -2           2    4.7     -9.4s
    5      (2, 3)         0       1           1    7.7     +7.7s
    6      (2, 8)        -3       0          -3    5.1          
    7     (2, 11)        -1      -1          -2    5.1     +5.1s
    8      (3, 4)        -4       4           0    7.8    -31.2s ← BLOCKED
    9      (3, 6)         2       0           2    4.5          
   10      (3, 8)         0      -1          -1    7.0     +7.0s
   11      (4, 5)        -4       4           0    4.0    -16.0s
   12      (5, 6)         0       2           2    7.4    +14.8s
   13      (6, 7)         2       1           3    6.8     +6.8s
   14      (6, 9)         0       2           2    6.2    +12.4s
   15     (6, 10)         0      -1          -1    7.7     +7.7s
   16      (7, 8)         0       1           1    6.1     +6.1s
   17     (7, 10)         2       0           2    4.7          
   18      (8, 9)        -2       0          -2    6.1          
   19     (8, 11)        -1       0          -1    5.2          
   20     (9, 10)        -2       2           0    4.0     -8.0s ← BLOCKED
   21    (10, 11)         0       1           1    7.5     +7.5s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=4, out=4  OK
  Node 2: in=5, out=5  OK
  Node 3: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=5, out=5  OK
  Node 7: in=3, out=3  OK
  Node 8: in=4, out=4  OK
  Node 9: in=2, out=2  OK
  Node 10: in=2, out=2  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 23

  Summary:
    Original path length:  37 edges
    Spliced path length:   34 edges
    Splices performed:     23
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)          -4        -4  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           1         1  ✓
    6      (2, 8)          -3        -3  ✓
    7     (2, 11)          -2        -2  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)           2         2  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)           2         2  ✓
   13      (6, 7)           3         3  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 48
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[1, 3, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2] → J=209, T=199, cost=0 → queued

[Iter 1] cost=0, J=209, T=199, edges=38, frontier=0, MILP_calls=1
  V_MIN=[1, 3, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 142 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.0s
  *** SOLUTION FOUND! J=209, T_tour=199.0s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [1, -1, -2, 0, 3, 0, -1, -1, -5, 6, -1, -5, -2, 2, 2, 0, 2, 0, 0, 0, 2, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [1, -1, -2, 0, 3, 0, -1, -1, -5, 6, -1, -5, -2, 2, 2, 0, 2, 0, 0, 0, 2, 2]
  Non-zero edges: [((0, 1), np.int64(1)), ((0, 11), np.int64(-1)), ((1, 2), np.int64(-2)), ((1, 5), np.int64(3)), ((2, 8), np.int64(-1)), ((2, 11), np.int64(-1)), ((3, 4), np.int64(-5)), ((3, 6), np.int64(6)), ((3, 8), np.int64(-1)), ((4, 5), np.int64(-5)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(2)), ((6, 9), np.int64(2)), ((7, 8), np.int64(2)), ((9, 10), np.int64(2)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=16, edge=(7, 8), flow_B=2  →  need Cm[16]=-2
Blocked edge 2: idx=4, edge=(1, 5), flow_B=3  →  need Cm[4]=-3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=31   ||Cm||_1=19

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 1, 0, 0, -1, -2, 0, -2, 0, 3, -1]

Cm = C_oriented @ beta*:
  [0, 0, 1, 2, -3, 0, 1, 0, 1, 1, 0, 1, -2, -1, 1, -1, -2, 1, -1, 0, 0, 0]

Original flow_B:
  [1, -1, -2, 0, 3, 0, -1, -1, -5, 6, -1, -5, -2, 2, 2, 0, 2, 0, 0, 0, 2, 2]

flow_B + Cm (corrected flow):
  [1, -1, -1, 2, 0, 0, 0, -1, -4, 7, -1, -4, -4, 1, 3, -1, 0, 1, -1, 0, 2, 2]

Verification:
  flow_corrected[16] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[4] = 0  (should be 0, Cm=-3, d=-3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 31  (minimized by MIQP)
  ||Cm||_1  = 19
  ||flow_B||_2² = 128
  ||flow_corrected||_2² = 127

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         1       0           1    5.8          
    1     (0, 11)        -1       0          -1    6.9          
    2      (1, 2)        -2       1          -1    5.8     -5.8s
    3      (1, 3)         0       2           2    6.4    +12.8s
    4      (1, 5)         3      -3           0    5.3    -15.9s ← BLOCKED
    5      (2, 3)         0       0           0    5.8          
    6      (2, 8)        -1       1           0    4.7     -4.7s
    7     (2, 11)        -1       0          -1    5.6          
    8      (3, 4)        -5       1          -4    4.5     -4.5s
    9      (3, 6)         6       1           7    4.1     +4.1s
   10      (3, 8)        -1       0          -1    4.3          
   11      (4, 5)        -5       1          -4    4.9     -4.9s
   12      (5, 6)        -2      -2          -4    6.2    +12.4s
   13      (6, 7)         2      -1           1    6.6     -6.6s
   14      (6, 9)         2       1           3    6.4     +6.4s
   15     (6, 10)         0      -1          -1    6.3     +6.3s
   16      (7, 8)         2      -2           0    5.3    -10.6s ← BLOCKED
   17     (7, 10)         0       1           1    5.5     +5.5s
   18      (8, 9)         0      -1          -1    5.6     +5.6s
   19     (8, 11)         0       0           0    6.7          
   20     (9, 10)         2       0           2    4.6          
   21    (10, 11)         2       0           2    7.2          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=1, out=1  OK
  Node 1: in=2, out=2  OK
  Node 2: in=1, out=1  OK
  Node 3: in=7, out=7  OK
  Node 4: in=4, out=4  OK
  Node 5: in=4, out=4  OK
  Node 6: in=8, out=8  OK
  Node 7: in=1, out=1  OK
  Node 8: in=1, out=1  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 37 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 18

  Summary:
    Original path length:  38 edges
    Spliced path length:   37 edges
    Splices performed:     18
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           1         1  ✓
    1     (0, 11)          -1        -1  ✓
    2      (1, 2)          -1        -1  ✓
    3      (1, 3)           2         2  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)          -1        -1  ✓
    8      (3, 4)          -4        -4  ✓
    9      (3, 6)           7         7  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)          -4        -4  ✓
   12      (5, 6)          -4        -4  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)           3         3  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)           1         1  ✓
   18      (8, 9)          -1        -1  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           2         2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 49
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 1, 2, 3, 2, 2] → J=258, T=199, cost=0 → queued

[Iter 1] cost=0, J=258, T=199, edges=35, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 3, 3, 2, 2, 2, 1, 2, 3, 2, 2]
  [backtrack] Found solution with 595 backtracks in 0.00s
  [backtrack] Found solution with 586 backtracks in 0.00s
  [backtrack] Found solution with 25 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 412 backtracks in 0.00s
  [backtrack] Found solution with 391 backtracks in 0.00s
  [backtrack] Found solution with 351 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (377 backtracks in 0.00s)
  [backtrack] Found solution with 27 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (533 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (370 backtracks in 0.00s)
  [backtrack] Found solution with 194 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=131.3s)
  Boundary nodes: [0, 1, 4, 5, 6, 7, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 1, 2, 3, 2, 2] → J=246, T=200, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 1, 2, 3, 2, 2] → J=253, T=196, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 1, 2, 3, 2, 2] → J=250, T=198, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 2, 3, 2, 1, 2, 3, 2, 2] → J=250, T=198, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 3, 1, 2, 3, 2, 2] → J=256, T=196, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 2, 2, 3, 2, 2] → J=253, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 1, 2, 4, 2, 2] → J=256, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 1, 2, 3, 3, 2] → J=256, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 1, 2, 3, 2, 3] → J=253, T=200, cost=1 → queued

[Iter 2] cost=1, J=256, T=200, edges=35, frontier=8, MILP_calls=10
  V_MIN=[2, 2, 3, 3, 2, 2, 2, 1, 2, 3, 3, 2]
  [backtrack] Found solution with 120 backtracks in 0.00s
  [backtrack] Found solution with 158 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 419 backtracks in 0.00s
  [backtrack] Found solution with 387 backtracks in 0.00s
  [backtrack] Found solution with 355 backtracks in 0.00s
  [backtrack] Found solution with 267 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1547 backtracks in 0.00s)
  [backtrack] Found solution with 317 backtracks in 0.00s
  [backtrack] Found solution with 114 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=88.2s)
  Boundary nodes: [0, 1, 4, 5, 6, 7, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 2, 3, 3, 2, 2, 2, 1, 2, 3, 3, 2] → J=246, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 1, 2, 3, 3, 2] → J=251, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 1, 2, 3, 3, 2] → J=250, T=196, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 3, 2, 1, 2, 3, 3, 2] → J=250, T=196, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 3, 1, 2, 3, 3, 2] → J=254, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 2, 2, 3, 3, 2] → J=253, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 1, 2, 4, 3, 2] → J=256, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 1, 2, 3, 4, 2] → J=254, T=198, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 1, 2, 3, 3, 3] → J=253, T=200, cost=2 → queued

[Iter 3] cost=1, J=256, T=199, edges=35, frontier=16, MILP_calls=19
  V_MIN=[2, 2, 3, 3, 2, 2, 2, 1, 2, 4, 2, 2]
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.6s
  *** SOLUTION FOUND! J=256, T_tour=198.6s ***

============================================================
Search done: 3 iters, 19 MILP calls, 19 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 0, 2, 0, -5, 4, 1, -2, 0, -1, -2, -2, 0, -1, -1, 1, -1, 4, 0, 3, 1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 0, 2, 0, -5, 4, 1, -2, 0, -1, -2, -2, 0, -1, -1, 1, -1, 4, 0, 3, 1]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 3), np.int64(2)), ((2, 3), np.int64(-5)), ((2, 8), np.int64(4)), ((2, 11), np.int64(1)), ((3, 4), np.int64(-2)), ((3, 8), np.int64(-1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-2)), ((6, 9), np.int64(-1)), ((6, 10), np.int64(-1)), ((7, 8), np.int64(1)), ((7, 10), np.int64(-1)), ((8, 9), np.int64(4)), ((9, 10), np.int64(3)), ((10, 11), np.int64(1))]

Blocked edge 1: idx=14, edge=(6, 9), flow_B=-1  →  need Cm[14]=1
Blocked edge 2: idx=1, edge=(0, 11), flow_B=-2  →  need Cm[1]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=19   ||Cm||_1=15

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [2, 0, -1, 1, -1, -1, -2, 0, 0, 1, 0]

Cm = C_oriented @ beta*:
  [-2, 2, 0, -1, -1, 1, 0, -1, 0, 1, -1, 0, -1, 0, 1, -1, 0, 0, 0, -1, 1, 0]

Original flow_B:
  [2, -2, 0, 2, 0, -5, 4, 1, -2, 0, -1, -2, -2, 0, -1, -1, 1, -1, 4, 0, 3, 1]

flow_B + Cm (corrected flow):
  [0, 0, 0, 1, -1, -4, 4, 0, -2, 1, -2, -2, -3, 0, 0, -2, 1, -1, 4, -1, 4, 1]

Verification:
  flow_corrected[14] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[1] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 19  (minimized by MIQP)
  ||Cm||_1  = 15
  ||flow_B||_2² = 97
  ||flow_corrected||_2² = 96

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2      -2           0    5.8    -11.6s
    1     (0, 11)        -2       2           0    7.2    -14.4s ← BLOCKED
    2      (1, 2)         0       0           0    7.4          
    3      (1, 3)         2      -1           1    4.9     -4.9s
    4      (1, 5)         0      -1          -1    7.8     +7.8s
    5      (2, 3)        -5       1          -4    4.2     -4.2s
    6      (2, 8)         4       0           4    5.2          
    7     (2, 11)         1      -1           0    5.2     -5.2s
    8      (3, 4)        -2       0          -2    6.8          
    9      (3, 6)         0       1           1    6.8     +6.8s
   10      (3, 8)        -1      -1          -2    7.8     +7.8s
   11      (4, 5)        -2       0          -2    6.4          
   12      (5, 6)        -2      -1          -3    5.4     +5.4s
   13      (6, 7)         0       0           0    5.7          
   14      (6, 9)        -1       1           0    7.6     -7.6s ← BLOCKED
   15     (6, 10)        -1      -1          -2    5.0     +5.0s
   16      (7, 8)         1       0           1    5.2          
   17     (7, 10)        -1       0          -1    4.3          
   18      (8, 9)         4       0           4    5.0          
   19     (8, 11)         0      -1          -1    7.6     +7.6s
   20     (9, 10)         3       1           4    7.4     +7.4s
   21    (10, 11)         1       0           1    6.5          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=1, out=1  OK
  Node 2: in=4, out=4  OK
  Node 3: in=5, out=5  OK
  Node 4: in=2, out=2  OK
  Node 5: in=3, out=3  OK
  Node 6: in=3, out=3  OK
  Node 7: in=1, out=1  OK
  Node 8: in=6, out=6  OK
  Node 9: in=4, out=4  OK
  Node 10: in=4, out=4  OK
  Node 11: in=1, out=1  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 13

  Summary:
    Original path length:  35 edges
    Spliced path length:   34 edges
    Splices performed:     13
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)          -4        -4  ✓
    6      (2, 8)           4         4  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)          -2        -2  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)          -3        -3  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)          -2        -2  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)           4         4  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           4         4  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 50
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 1, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2] → J=198, T=200, cost=0 → queued

[Iter 1] cost=0, J=198, T=200, edges=34, frontier=0, MILP_calls=1
  V_MIN=[2, 1, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 45 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.6s
  *** SOLUTION FOUND! J=198, T_tour=199.6s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 0, -1, -1, 0, 2, -2, -2, 0, 1, -2, -3, -3, 2, -2, -5, 2, -2, 0, 0, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 0, -1, -1, 0, 2, -2, -2, 0, 1, -2, -3, -3, 2, -2, -5, 2, -2, 0, 0, 0]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 3), np.int64(-1)), ((1, 5), np.int64(-1)), ((2, 8), np.int64(2)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(-2)), ((3, 8), np.int64(1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-3)), ((6, 7), np.int64(-3)), ((6, 9), np.int64(2)), ((6, 10), np.int64(-2)), ((7, 8), np.int64(-5)), ((7, 10), np.int64(2)), ((8, 9), np.int64(-2))]

Blocked edge 1: idx=11, edge=(4, 5), flow_B=-2  →  need Cm[11]=2
Blocked edge 2: idx=17, edge=(7, 10), flow_B=2  →  need Cm[17]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=27   ||Cm||_1=19

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [2, -1, -1, 1, -2, 0, -1, 0, 1, 2, -1]

Cm = C_oriented @ beta*:
  [-1, 1, 1, 0, -2, 0, 1, 0, 2, -1, -1, 2, 0, -1, 0, 0, 1, -2, 1, 0, 1, -1]

Original flow_B:
  [-2, 2, 0, -1, -1, 0, 2, -2, -2, 0, 1, -2, -3, -3, 2, -2, -5, 2, -2, 0, 0, 0]

flow_B + Cm (corrected flow):
  [-3, 3, 1, -1, -3, 0, 3, -2, 0, -1, 0, 0, -3, -4, 2, -2, -4, 0, -1, 0, 1, -1]

Verification:
  flow_corrected[11] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[17] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 27  (minimized by MIQP)
  ||Cm||_1  = 19
  ||flow_B||_2² = 86
  ||flow_corrected||_2² = 95

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2      -1          -3    4.6     +4.6s
    1     (0, 11)         2       1           3    7.9     +7.9s
    2      (1, 2)         0       1           1    7.6     +7.6s
    3      (1, 3)        -1       0          -1    6.2          
    4      (1, 5)        -1      -2          -3    5.3    +10.6s
    5      (2, 3)         0       0           0    7.6          
    6      (2, 8)         2       1           3    6.7     +6.7s
    7     (2, 11)        -2       0          -2    5.6          
    8      (3, 4)        -2       2           0    6.0    -12.0s
    9      (3, 6)         0      -1          -1    6.1     +6.1s
   10      (3, 8)         1      -1           0    7.7     -7.7s
   11      (4, 5)        -2       2           0    6.3    -12.6s ← BLOCKED
   12      (5, 6)        -3       0          -3    6.7          
   13      (6, 7)        -3      -1          -4    4.2     +4.2s
   14      (6, 9)         2       0           2    5.3          
   15     (6, 10)        -2       0          -2    4.2          
   16      (7, 8)        -5       1          -4    4.7     -4.7s
   17     (7, 10)         2      -2           0    7.7    -15.4s ← BLOCKED
   18      (8, 9)        -2       1          -1    7.8     -7.8s
   19     (8, 11)         0       0           0    6.9          
   20     (9, 10)         0       1           1    6.9     +6.9s
   21    (10, 11)         0      -1          -1    5.8     +5.8s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=4, out=4  OK
  Node 2: in=3, out=3  OK
  Node 3: in=1, out=1  OK
  Node 5: in=3, out=3  OK
  Node 6: in=6, out=6  OK
  Node 7: in=4, out=4  OK
  Node 8: in=4, out=4  OK
  Node 9: in=2, out=2  OK
  Node 10: in=2, out=2  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 16

  Summary:
    Original path length:  34 edges
    Spliced path length:   35 edges
    Splices performed:     16
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -3        -3  ✓
    1     (0, 11)           3         3  ✓
    2      (1, 2)           1         1  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)          -3        -3  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           3         3  ✓
    7     (2, 11)          -2        -2  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)          -3        -3  ✓
   13      (6, 7)          -4        -4  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)          -2        -2  ✓
   16      (7, 8)          -4        -4  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)          -1        -1  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 51
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 1, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2] → J=172, T=199, cost=0 → queued

[Iter 1] cost=0, J=172, T=199, edges=34, frontier=0, MILP_calls=1
  V_MIN=[2, 1, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 134 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.2s
  *** SOLUTION FOUND! J=172, T_tour=199.2s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 0, 2, -4, 3, -2, -1, 2, 2, 1, 2, -2, 0, 0, 0, 2, -2, 2, -1, 2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 0, 2, -4, 3, -2, -1, 2, 2, 1, 2, -2, 0, 0, 0, 2, -2, 2, -1, 2, 0]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 3), np.int64(2)), ((1, 5), np.int64(-4)), ((2, 3), np.int64(3)), ((2, 8), np.int64(-2)), ((2, 11), np.int64(-1)), ((3, 4), np.int64(2)), ((3, 6), np.int64(2)), ((3, 8), np.int64(1)), ((4, 5), np.int64(2)), ((5, 6), np.int64(-2)), ((7, 8), np.int64(2)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(2)), ((8, 11), np.int64(-1)), ((9, 10), np.int64(2))]

Blocked edge 1: idx=1, edge=(0, 11), flow_B=2  →  need Cm[1]=-2
Blocked edge 2: idx=9, edge=(3, 6), flow_B=2  →  need Cm[9]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=27   ||Cm||_1=19

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -1, 1, 1, 0, 1, 2, 0, -1, 0, -1]

Cm = C_oriented @ beta*:
  [2, -2, 2, 0, 0, 0, 1, 1, 1, -2, 1, 1, 1, -1, 0, 0, -1, 0, 1, 0, 1, 1]

Original flow_B:
  [-2, 2, 0, 2, -4, 3, -2, -1, 2, 2, 1, 2, -2, 0, 0, 0, 2, -2, 2, -1, 2, 0]

flow_B + Cm (corrected flow):
  [0, 0, 2, 2, -4, 3, -1, 0, 3, 0, 2, 3, -1, -1, 0, 0, 1, -2, 3, -1, 3, 1]

Verification:
  flow_corrected[1] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[9] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 27  (minimized by MIQP)
  ||Cm||_1  = 19
  ||flow_B||_2² = 76
  ||flow_corrected||_2² = 83

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       2           0    6.6    -13.2s
    1     (0, 11)         2      -2           0    5.0    -10.0s ← BLOCKED
    2      (1, 2)         0       2           2    5.6    +11.2s
    3      (1, 3)         2       0           2    4.2          
    4      (1, 5)        -4       0          -4    5.3          
    5      (2, 3)         3       0           3    5.2          
    6      (2, 8)        -2       1          -1    5.8     -5.8s
    7     (2, 11)        -1       1           0    4.2     -4.2s
    8      (3, 4)         2       1           3    7.0     +7.0s
    9      (3, 6)         2      -2           0    6.9    -13.8s ← BLOCKED
   10      (3, 8)         1       1           2    6.3     +6.3s
   11      (4, 5)         2       1           3    6.9     +6.9s
   12      (5, 6)        -2       1          -1    6.3     -6.3s
   13      (6, 7)         0      -1          -1    6.6     +6.6s
   14      (6, 9)         0       0           0    7.2          
   15     (6, 10)         0       0           0    7.5          
   16      (7, 8)         2      -1           1    5.4     -5.4s
   17     (7, 10)        -2       0          -2    5.2          
   18      (8, 9)         2       1           3    6.4     +6.4s
   19     (8, 11)        -1       0          -1    5.5          
   20     (9, 10)         2       1           3    7.5     +7.5s
   21    (10, 11)         0       1           1    6.8     +6.8s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=4, out=4  OK
  Node 2: in=3, out=3  OK
  Node 3: in=5, out=5  OK
  Node 4: in=3, out=3  OK
  Node 5: in=4, out=4  OK
  Node 6: in=1, out=1  OK
  Node 7: in=2, out=2  OK
  Node 8: in=4, out=4  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=1, out=1  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 33 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 12

  Summary:
    Original path length:  34 edges
    Spliced path length:   33 edges
    Splices performed:     12
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           2         2  ✓
    3      (1, 3)           2         2  ✓
    4      (1, 5)          -4        -4  ✓
    5      (2, 3)           3         3  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           3         3  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           2         2  ✓
   11      (4, 5)           3         3  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           3         3  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           3         3  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 52
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 1, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2] → J=204, T=200, cost=0 → queued

[Iter 1] cost=0, J=204, T=200, edges=33, frontier=0, MILP_calls=1
  V_MIN=[3, 1, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (382 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (131 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (218 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (319 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (291 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (249 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (105 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (220 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (187 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (217 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (381 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 6, 7, 9] → expanding 7 children
    V_MIN=[4, 1, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 1, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2] → J=194, T=199, cost=1 → queued
    V_MIN=[3, 1, 2, 2, 3, 2, 2, 3, 3, 2, 2, 2] → J=190, T=200, cost=1 → queued
    V_MIN=[3, 1, 2, 2, 2, 3, 2, 3, 3, 2, 2, 2] → J=194, T=200, cost=1 → queued
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 3, 3, 2, 2, 2] → J=199, T=200, cost=1 → queued
    V_MIN=[3, 1, 2, 2, 2, 2, 2, 4, 3, 2, 2, 2] → J=201, T=200, cost=1 → queued
    V_MIN=[3, 1, 2, 2, 2, 2, 2, 3, 3, 3, 2, 2] → J=200, T=199, cost=1 → queued

[Iter 2] cost=1, J=201, T=200, edges=32, frontier=5, MILP_calls=8
  V_MIN=[3, 1, 2, 2, 2, 2, 2, 4, 3, 2, 2, 2]
  [backtrack] Found solution with 41 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.8s
  *** SOLUTION FOUND! J=201, T_tour=199.8s ***

============================================================
Search done: 2 iters, 8 MILP calls, 8 states visited

Original flow_B is latency-feasible ✓
  flow_B = [3, -3, 1, 0, 2, -1, 2, 0, -2, 1, 0, -2, 0, -1, 2, 0, -4, 3, -2, 0, 0, 3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [3, -3, 1, 0, 2, -1, 2, 0, -2, 1, 0, -2, 0, -1, 2, 0, -4, 3, -2, 0, 0, 3]
  Non-zero edges: [((0, 1), np.int64(3)), ((0, 11), np.int64(-3)), ((1, 2), np.int64(1)), ((1, 5), np.int64(2)), ((2, 3), np.int64(-1)), ((2, 8), np.int64(2)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(1)), ((4, 5), np.int64(-2)), ((6, 7), np.int64(-1)), ((6, 9), np.int64(2)), ((7, 8), np.int64(-4)), ((7, 10), np.int64(3)), ((8, 9), np.int64(-2)), ((10, 11), np.int64(3))]

Blocked edge 1: idx=16, edge=(7, 8), flow_B=-4  →  need Cm[16]=4
Blocked edge 2: idx=0, edge=(0, 1), flow_B=3  →  need Cm[0]=-3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=76   ||Cm||_1=32

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -1, -1, 2, 0, 1, -3, 4, 0, -1, 2]

Cm = C_oriented @ beta*:
  [-3, 3, -3, -1, 1, 0, -1, -2, 0, 1, -2, 0, 1, 3, 0, -1, 4, -1, 2, -1, 2, 0]

Original flow_B:
  [3, -3, 1, 0, 2, -1, 2, 0, -2, 1, 0, -2, 0, -1, 2, 0, -4, 3, -2, 0, 0, 3]

flow_B + Cm (corrected flow):
  [0, 0, -2, -1, 3, -1, 1, -2, -2, 2, -2, -2, 1, 2, 2, -1, 0, 2, 0, -1, 2, 3]

Verification:
  flow_corrected[16] = 0  (should be 0, Cm=4, d=4)
  flow_corrected[0] = 0  (should be 0, Cm=-3, d=-3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 76  (minimized by MIQP)
  ||Cm||_1  = 32
  ||flow_B||_2² = 80
  ||flow_corrected||_2² = 64

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         3      -3           0    7.1    -21.3s ← BLOCKED
    1     (0, 11)        -3       3           0    5.7    -17.1s
    2      (1, 2)         1      -3          -2    7.1     +7.1s
    3      (1, 3)         0      -1          -1    5.7     +5.7s
    4      (1, 5)         2       1           3    7.7     +7.7s
    5      (2, 3)        -1       0          -1    6.7          
    6      (2, 8)         2      -1           1    5.5     -5.5s
    7     (2, 11)         0      -2          -2    7.4    +14.8s
    8      (3, 4)        -2       0          -2    5.5          
    9      (3, 6)         1       1           2    4.4     +4.4s
   10      (3, 8)         0      -2          -2    5.3    +10.6s
   11      (4, 5)        -2       0          -2    5.7          
   12      (5, 6)         0       1           1    7.0     +7.0s
   13      (6, 7)        -1       3           2    6.6     +6.6s
   14      (6, 9)         2       0           2    4.8          
   15     (6, 10)         0      -1          -1    7.2     +7.2s
   16      (7, 8)        -4       4           0    7.1    -28.4s ← BLOCKED
   17     (7, 10)         3      -1           2    5.6     -5.6s
   18      (8, 9)        -2       2           0    6.0    -12.0s
   19     (8, 11)         0      -1          -1    7.2     +7.2s
   20     (9, 10)         0       2           2    5.8    +11.6s
   21    (10, 11)         3       0           3    7.0          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=3, out=3  OK
  Node 2: in=3, out=3  OK
  Node 3: in=4, out=4  OK
  Node 4: in=2, out=2  OK
  Node 5: in=3, out=3  OK
  Node 6: in=4, out=4  OK
  Node 7: in=2, out=2  OK
  Node 8: in=2, out=2  OK
  Node 9: in=2, out=2  OK
  Node 10: in=4, out=4  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 32 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 22

  Summary:
    Original path length:  32 edges
    Spliced path length:   32 edges
    Splices performed:     22
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)          -2        -2  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)           3         3  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)           1         1  ✓
    7     (2, 11)          -2        -2  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           2         2  ✓
   10      (3, 8)          -2        -2  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)           2         2  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           3         3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 53
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 1, 2] → J=203, T=200, cost=0 → queued

[Iter 1] cost=0, J=203, T=200, edges=36, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 1, 2]
  [backtrack] Found solution with 70 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.6s
  *** SOLUTION FOUND! J=203, T_tour=199.6s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [4, -4, 2, 0, 2, 2, 0, 0, 2, -1, 1, 2, 4, 2, 1, 0, 1, 1, -2, 4, -1, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [4, -4, 2, 0, 2, 2, 0, 0, 2, -1, 1, 2, 4, 2, 1, 0, 1, 1, -2, 4, -1, 0]
  Non-zero edges: [((0, 1), np.int64(4)), ((0, 11), np.int64(-4)), ((1, 2), np.int64(2)), ((1, 5), np.int64(2)), ((2, 3), np.int64(2)), ((3, 4), np.int64(2)), ((3, 6), np.int64(-1)), ((3, 8), np.int64(1)), ((4, 5), np.int64(2)), ((5, 6), np.int64(4)), ((6, 7), np.int64(2)), ((6, 9), np.int64(1)), ((7, 8), np.int64(1)), ((7, 10), np.int64(1)), ((8, 9), np.int64(-2)), ((8, 11), np.int64(4)), ((9, 10), np.int64(-1))]

Blocked edge 1: idx=4, edge=(1, 5), flow_B=2  →  need Cm[4]=-2
Blocked edge 2: idx=20, edge=(9, 10), flow_B=-1  →  need Cm[20]=1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=17   ||Cm||_1=15

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [2, 0, -1, 1, -1, -1, -1, 0, 1, 2, -1]

Cm = C_oriented @ beta*:
  [-1, 1, 1, 0, -2, 1, 0, 0, 1, 0, 0, 1, -1, 0, 0, -1, 1, -1, 1, 0, 1, -1]

Original flow_B:
  [4, -4, 2, 0, 2, 2, 0, 0, 2, -1, 1, 2, 4, 2, 1, 0, 1, 1, -2, 4, -1, 0]

flow_B + Cm (corrected flow):
  [3, -3, 3, 0, 0, 3, 0, 0, 3, -1, 1, 3, 3, 2, 1, -1, 2, 0, -1, 4, 0, -1]

Verification:
  flow_corrected[4] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[20] = 0  (should be 0, Cm=1, d=1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 17  (minimized by MIQP)
  ||Cm||_1  = 15
  ||flow_B||_2² = 98
  ||flow_corrected||_2² = 93

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         4      -1           3    4.2     -4.2s
    1     (0, 11)        -4       1          -3    5.6     -5.6s
    2      (1, 2)         2       1           3    5.5     +5.5s
    3      (1, 3)         0       0           0    6.2          
    4      (1, 5)         2      -2           0    7.6    -15.2s ← BLOCKED
    5      (2, 3)         2       1           3    4.7     +4.7s
    6      (2, 8)         0       0           0    5.6          
    7     (2, 11)         0       0           0    6.6          
    8      (3, 4)         2       1           3    6.3     +6.3s
    9      (3, 6)        -1       0          -1    6.3          
   10      (3, 8)         1       0           1    6.1          
   11      (4, 5)         2       1           3    6.4     +6.4s
   12      (5, 6)         4      -1           3    4.5     -4.5s
   13      (6, 7)         2       0           2    4.8          
   14      (6, 9)         1       0           1    5.8          
   15     (6, 10)         0      -1          -1    7.4     +7.4s
   16      (7, 8)         1       1           2    7.6     +7.6s
   17     (7, 10)         1      -1           0    4.9     -4.9s
   18      (8, 9)        -2       1          -1    5.9     -5.9s
   19     (8, 11)         4       0           4    5.9          
   20     (9, 10)        -1       1           0    5.7     -5.7s ← BLOCKED
   21    (10, 11)         0      -1          -1    7.9     +7.9s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=3, out=3  OK
  Node 2: in=3, out=3  OK
  Node 3: in=4, out=4  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=4, out=4  OK
  Node 7: in=2, out=2  OK
  Node 8: in=4, out=4  OK
  Node 9: in=1, out=1  OK
  Node 10: in=1, out=1  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 19

  Summary:
    Original path length:  36 edges
    Spliced path length:   35 edges
    Splices performed:     19
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           3         3  ✓
    1     (0, 11)          -3        -3  ✓
    2      (1, 2)           3         3  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)           3         3  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           3         3  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)           1         1  ✓
   11      (4, 5)           3         3  ✓
   12      (5, 6)           3         3  ✓
   13      (6, 7)           2         2  ✓
   14      (6, 9)           1         1  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           2         2  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)          -1        -1  ✓
   19     (8, 11)           4         4  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 54
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 1, 3, 2, 2, 2, 2, 2, 2] → J=220, T=200, cost=0 → queued

[Iter 1] cost=0, J=220, T=200, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 1, 3, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 413 backtracks in 0.00s
  [backtrack] Found solution with 265 backtracks in 0.00s
  [backtrack] Found solution with 562 backtracks in 0.00s
  [backtrack] Found solution with 168 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (493 backtracks in 0.00s)
  [backtrack] Found solution with 221 backtracks in 0.00s
  [backtrack] Found solution with 181 backtracks in 0.00s
  [backtrack] Found solution with 319 backtracks in 0.00s
  [backtrack] Found solution with 168 backtracks in 0.00s
  [backtrack] Found solution with 21 backtracks in 0.00s
  [backtrack] Found solution with 21 backtracks in 0.00s
  [backtrack] Found solution with 422 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=122.4s)
  Boundary nodes: [0, 1, 2, 4, 5, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 2, 2, 2, 1, 3, 2, 2, 2, 2, 2, 2] → J=210, T=199, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 1, 3, 2, 2, 2, 2, 2, 2] → J=218, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 1, 3, 2, 2, 2, 2, 2, 2] → J=213, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2] → J=215, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 1, 4, 2, 2, 2, 2, 2, 2] → J=218, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 1, 3, 2, 2, 3, 2, 2, 2] → J=219, T=198, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 1, 3, 2, 2, 2, 3, 2, 2] → J=217, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 1, 3, 2, 2, 2, 2, 2, 3] → J=212, T=200, cost=1 → queued

[Iter 2] cost=1, J=219, T=198, edges=36, frontier=7, MILP_calls=9
  V_MIN=[2, 2, 2, 2, 1, 3, 2, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 27 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.2s
  *** SOLUTION FOUND! J=219, T_tour=198.2s ***

============================================================
Search done: 2 iters, 9 MILP calls, 9 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 0, 0, 2, -2, 0, 2, 1, -6, 3, 1, 3, -3, -2, 2, -1, -2, 2, 0, 0, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 0, 0, 2, -2, 0, 2, 1, -6, 3, 1, 3, -3, -2, 2, -1, -2, 2, 0, 0, 0]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 5), np.int64(2)), ((2, 3), np.int64(-2)), ((2, 11), np.int64(2)), ((3, 4), np.int64(1)), ((3, 6), np.int64(-6)), ((3, 8), np.int64(3)), ((4, 5), np.int64(1)), ((5, 6), np.int64(3)), ((6, 7), np.int64(-3)), ((6, 9), np.int64(-2)), ((6, 10), np.int64(2)), ((7, 8), np.int64(-1)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(2))]

Blocked edge 1: idx=17, edge=(7, 10), flow_B=-2  →  need Cm[17]=2
Blocked edge 2: idx=18, edge=(8, 9), flow_B=2  →  need Cm[18]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=21   ||Cm||_1=17

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, 2, 1, -1, 2, 1, 0, -1, 0, -1, 1]

Cm = C_oriented @ beta*:
  [0, 0, -1, 0, 1, 1, -1, -1, 0, 0, 1, 0, 1, 1, 1, -1, -1, 2, -2, 1, -1, 0]

Original flow_B:
  [2, -2, 0, 0, 2, -2, 0, 2, 1, -6, 3, 1, 3, -3, -2, 2, -1, -2, 2, 0, 0, 0]

flow_B + Cm (corrected flow):
  [2, -2, -1, 0, 3, -1, -1, 1, 1, -6, 4, 1, 4, -2, -1, 1, -2, 0, 0, 1, -1, 0]

Verification:
  flow_corrected[17] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[18] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 21  (minimized by MIQP)
  ||Cm||_1  = 17
  ||flow_B||_2² = 102
  ||flow_corrected||_2² = 103

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    4.8          
    1     (0, 11)        -2       0          -2    7.1          
    2      (1, 2)         0      -1          -1    6.5     +6.5s
    3      (1, 3)         0       0           0    7.7          
    4      (1, 5)         2       1           3    5.3     +5.3s
    5      (2, 3)        -2       1          -1    5.0     -5.0s
    6      (2, 8)         0      -1          -1    6.9     +6.9s
    7     (2, 11)         2      -1           1    8.0     -8.0s
    8      (3, 4)         1       0           1    5.2          
    9      (3, 6)        -6       0          -6    4.7          
   10      (3, 8)         3       1           4    4.7     +4.7s
   11      (4, 5)         1       0           1    4.7          
   12      (5, 6)         3       1           4    6.3     +6.3s
   13      (6, 7)        -3       1          -2    5.9     -5.9s
   14      (6, 9)        -2       1          -1    5.8     -5.8s
   15     (6, 10)         2      -1           1    4.9     -4.9s
   16      (7, 8)        -1      -1          -2    7.4     +7.4s
   17     (7, 10)        -2       2           0    5.9    -11.8s ← BLOCKED
   18      (8, 9)         2      -2           0    4.2     -8.4s ← BLOCKED
   19     (8, 11)         0       1           1    8.0     +8.0s
   20     (9, 10)         0      -1          -1    4.8     +4.8s
   21    (10, 11)         0       0           0    6.9          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=3, out=3  OK
  Node 2: in=2, out=2  OK
  Node 3: in=6, out=6  OK
  Node 4: in=1, out=1  OK
  Node 5: in=4, out=4  OK
  Node 6: in=7, out=7  OK
  Node 7: in=2, out=2  OK
  Node 8: in=4, out=4  OK
  Node 9: in=1, out=1  OK
  Node 10: in=1, out=1  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 11

  Summary:
    Original path length:  36 edges
    Spliced path length:   35 edges
    Splices performed:     11
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)          -1        -1  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           3         3  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           1         1  ✓
    8      (3, 4)           1         1  ✓
    9      (3, 6)          -6        -6  ✓
   10      (3, 8)           4         4  ✓
   11      (4, 5)           1         1  ✓
   12      (5, 6)           4         4  ✓
   13      (6, 7)          -2        -2  ✓
   14      (6, 9)          -1        -1  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)          -2        -2  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)           1         1  ✓
   20     (9, 10)          -1        -1  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 55
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 1, 2, 2, 2, 2] → J=185, T=200, cost=0 → queued

[Iter 1] cost=0, J=185, T=200, edges=34, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 1, 2, 2, 2, 2]
  [backtrack] Found solution with 113 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.9s
  *** SOLUTION FOUND! J=185, T_tour=199.9s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, -2, 0, -1, 0, -2, 0, -2, 1, 1, -2, -3, 1, -4, 1, 1, 0, 0, 0, -4, -3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, -2, 0, -1, 0, -2, 0, -2, 1, 1, -2, -3, 1, -4, 1, 1, 0, 0, 0, -4, -3]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 2), np.int64(-2)), ((1, 5), np.int64(-1)), ((2, 8), np.int64(-2)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(1)), ((3, 8), np.int64(1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-3)), ((6, 7), np.int64(1)), ((6, 9), np.int64(-4)), ((6, 10), np.int64(1)), ((7, 8), np.int64(1)), ((9, 10), np.int64(-4)), ((10, 11), np.int64(-3))]

Blocked edge 1: idx=14, edge=(6, 9), flow_B=-4  →  need Cm[14]=4
Blocked edge 2: idx=1, edge=(0, 11), flow_B=3  →  need Cm[1]=-3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=64   ||Cm||_1=28

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-3, -1, 1, 1, 2, 1, 3, 0, 0, -1, 3]

Cm = C_oriented @ beta*:
  [3, -3, 0, 2, 1, -1, -1, 2, 0, 2, -1, 0, 1, -1, 4, 0, 0, -1, -3, 1, 1, 0]

Original flow_B:
  [-3, 3, -2, 0, -1, 0, -2, 0, -2, 1, 1, -2, -3, 1, -4, 1, 1, 0, 0, 0, -4, -3]

flow_B + Cm (corrected flow):
  [0, 0, -2, 2, 0, -1, -3, 2, -2, 3, 0, -2, -2, 0, 0, 1, 1, -1, -3, 1, -3, -3]

Verification:
  flow_corrected[14] = 0  (should be 0, Cm=4, d=4)
  flow_corrected[1] = 0  (should be 0, Cm=-3, d=-3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 64  (minimized by MIQP)
  ||Cm||_1  = 28
  ||flow_B||_2² = 90
  ||flow_corrected||_2² = 74

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       3           0    4.0    -12.0s
    1     (0, 11)         3      -3           0    6.5    -19.5s ← BLOCKED
    2      (1, 2)        -2       0          -2    7.3          
    3      (1, 3)         0       2           2    7.6    +15.2s
    4      (1, 5)        -1       1           0    7.9     -7.9s
    5      (2, 3)         0      -1          -1    6.0     +6.0s
    6      (2, 8)        -2      -1          -3    5.4     +5.4s
    7     (2, 11)         0       2           2    7.5    +15.0s
    8      (3, 4)        -2       0          -2    5.6          
    9      (3, 6)         1       2           3    6.6    +13.2s
   10      (3, 8)         1      -1           0    4.1     -4.1s
   11      (4, 5)        -2       0          -2    7.2          
   12      (5, 6)        -3       1          -2    5.7     -5.7s
   13      (6, 7)         1      -1           0    6.2     -6.2s
   14      (6, 9)        -4       4           0    7.1    -28.4s ← BLOCKED
   15     (6, 10)         1       0           1    5.6          
   16      (7, 8)         1       0           1    7.6          
   17     (7, 10)         0      -1          -1    6.6     +6.6s
   18      (8, 9)         0      -3          -3    6.9    +20.7s
   19     (8, 11)         0       1           1    7.1     +7.1s
   20     (9, 10)        -4       1          -3    5.4     -5.4s
   21    (10, 11)        -3       0          -3    4.1          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=2, out=2  OK
  Node 2: in=4, out=4  OK
  Node 3: in=4, out=4  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=3, out=3  OK
  Node 7: in=1, out=1  OK
  Node 8: in=4, out=4  OK
  Node 9: in=3, out=3  OK
  Node 10: in=4, out=4  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 32 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 26

  Summary:
    Original path length:  34 edges
    Spliced path length:   32 edges
    Splices performed:     26
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)          -2        -2  ✓
    3      (1, 3)           2         2  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)          -3        -3  ✓
    7     (2, 11)           2         2  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           3         3  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)          -2        -2  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)          -3        -3  ✓
   19     (8, 11)           1         1  ✓
   20     (9, 10)          -3        -3  ✓
   21    (10, 11)          -3        -3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 56
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 1] → J=196, T=200, cost=0 → queued

[Iter 1] cost=0, J=196, T=200, edges=34, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 1]
  [backtrack] Found solution with 56 backtracks in 0.00s
  [backtrack] Found solution with 54 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (240 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (231 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (224 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (175 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] Found solution with 221 backtracks in 0.00s
  [backtrack] Found solution with 116 backtracks in 0.00s
  [backtrack] Found solution with 92 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=123.5s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 1] → J=182, T=200, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 1] → J=188, T=200, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 1] → J=188, T=200, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 1] → J=187, T=200, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 1] → J=186, T=199, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 1] → J=188, T=199, cost=1 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 1] → J=191, T=197, cost=1 → queued

[Iter 2] cost=1, J=191, T=197, edges=34, frontier=6, MILP_calls=8
  V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 1]
  [backtrack] Found solution with 40 backtracks in 0.00s
  [backtrack] Found solution with 42 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (155 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (176 backtracks in 0.00s)
  [backtrack] Found solution with 137 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (140 backtracks in 0.00s)
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] Found solution with 52 backtracks in 0.00s
  [backtrack] Found solution with 36 backtracks in 0.00s
  [backtrack] Found solution with 38 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=105.8s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 1] → J=179, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 3, 2, 2, 2, 3, 2, 3, 1] → J=183, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 3, 2, 2, 3, 2, 3, 1] → J=186, T=198, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 3, 2, 3, 1] → J=186, T=198, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1] → J=186, T=198, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 1] → J=188, T=198, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 4, 1] → J=183, T=199, cost=2 → queued

[Iter 3] cost=1, J=188, T=199, edges=34, frontier=12, MILP_calls=15
  V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 1]
  [backtrack] Found solution with 71 backtracks in 0.00s
  [backtrack] Found solution with 61 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 18 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (258 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (243 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (238 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (191 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (168 backtracks in 0.00s)
  [backtrack] Found solution with 143 backtracks in 0.00s
  [backtrack] Found solution with 74 backtracks in 0.00s
  [backtrack] Found solution with 72 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=122.8s)
  Boundary nodes: [0, 4, 5, 6, 7, 9] → expanding 6 children
    V_MIN=[4, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 1] → J=176, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 3, 2, 2, 2, 3, 3, 2, 1] → J=176, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 3, 2, 2, 3, 3, 2, 1] → J=185, T=198, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 3, 3, 2, 1] → J=181, T=196, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 1] → J=178, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 3, 4, 2, 1] → J=182, T=199, cost=2 → queued

[Iter 4] cost=1, J=188, T=200, edges=33, frontier=17, MILP_calls=21
  V_MIN=[3, 2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 1]
  [backtrack] EXHAUSTED search space (688 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (670 backtracks in 0.00s)
  [backtrack] Found solution with 129 backtracks in 0.00s
  [backtrack] Found solution with 62 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (514 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (573 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (170 backtracks in 0.00s)
  [backtrack] Found solution with 287 backtracks in 0.00s
  [backtrack] Found solution with 219 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (867 backtracks in 0.00s)
  [backtrack] Found solution with 337 backtracks in 0.00s
  [backtrack] Found solution with 117 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=95.9s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 1] → J=176, T=197, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 1] → J=188, T=198, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 4, 2, 2, 3, 2, 2, 1] → J=184, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 3, 3, 2, 3, 2, 2, 1] → J=186, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 3, 2, 3, 3, 2, 2, 1] → J=186, T=199, cost=2 → queued

[Iter 5] cost=1, J=188, T=200, edges=34, frontier=21, MILP_calls=26
  V_MIN=[3, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 1]
  [backtrack] Found solution with 11 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.7s
  *** SOLUTION FOUND! J=188, T_tour=199.7s ***

============================================================
Search done: 5 iters, 26 MILP calls, 26 states visited

Original flow_B is latency-feasible ✓
  flow_B = [3, -3, 1, 1, 1, -1, 2, 0, -3, 0, 3, -3, -2, -2, 0, 0, -2, 0, 2, 1, 2, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [3, -3, 1, 1, 1, -1, 2, 0, -3, 0, 3, -3, -2, -2, 0, 0, -2, 0, 2, 1, 2, 2]
  Non-zero edges: [((0, 1), np.int64(3)), ((0, 11), np.int64(-3)), ((1, 2), np.int64(1)), ((1, 3), np.int64(1)), ((1, 5), np.int64(1)), ((2, 3), np.int64(-1)), ((2, 8), np.int64(2)), ((3, 4), np.int64(-3)), ((3, 8), np.int64(3)), ((4, 5), np.int64(-3)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(-2)), ((7, 8), np.int64(-2)), ((8, 9), np.int64(2)), ((8, 11), np.int64(1)), ((9, 10), np.int64(2)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=4, edge=(1, 5), flow_B=1  →  need Cm[4]=-1
Blocked edge 2: idx=10, edge=(3, 8), flow_B=3  →  need Cm[10]=-3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=21   ||Cm||_1=15

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, -1, -1, 0, -2, 0, 0, 1, 0, 1, 1]

Cm = C_oriented @ beta*:
  [0, 0, 1, 0, -1, -1, 1, 1, 1, 1, -3, 1, 0, 0, 0, 1, 1, -1, 0, -1, 0, 0]

Original flow_B:
  [3, -3, 1, 1, 1, -1, 2, 0, -3, 0, 3, -3, -2, -2, 0, 0, -2, 0, 2, 1, 2, 2]

flow_B + Cm (corrected flow):
  [3, -3, 2, 1, 0, -2, 3, 1, -2, 1, 0, -2, -2, -2, 0, 1, -1, -1, 2, 0, 2, 2]

Verification:
  flow_corrected[4] = 0  (should be 0, Cm=-1, d=-1)
  flow_corrected[10] = 0  (should be 0, Cm=-3, d=-3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 21  (minimized by MIQP)
  ||Cm||_1  = 15
  ||flow_B||_2² = 78
  ||flow_corrected||_2² = 69

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         3       0           3    7.3          
    1     (0, 11)        -3       0          -3    4.4          
    2      (1, 2)         1       1           2    6.6     +6.6s
    3      (1, 3)         1       0           1    6.2          
    4      (1, 5)         1      -1           0    7.4     -7.4s ← BLOCKED
    5      (2, 3)        -1      -1          -2    5.1     +5.1s
    6      (2, 8)         2       1           3    5.8     +5.8s
    7     (2, 11)         0       1           1    7.5     +7.5s
    8      (3, 4)        -3       1          -2    6.9     -6.9s
    9      (3, 6)         0       1           1    6.9     +6.9s
   10      (3, 8)         3      -3           0    4.1    -12.3s ← BLOCKED
   11      (4, 5)        -3       1          -2    4.1     -4.1s
   12      (5, 6)        -2       0          -2    5.3          
   13      (6, 7)        -2       0          -2    6.3          
   14      (6, 9)         0       0           0    7.0          
   15     (6, 10)         0       1           1    6.9     +6.9s
   16      (7, 8)        -2       1          -1    8.0     -8.0s
   17     (7, 10)         0      -1          -1    7.9     +7.9s
   18      (8, 9)         2       0           2    6.2          
   19     (8, 11)         1      -1           0    8.0     -8.0s
   20     (9, 10)         2       0           2    6.0          
   21    (10, 11)         2       0           2    5.4          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=3, out=3  OK
  Node 2: in=4, out=4  OK
  Node 3: in=3, out=3  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=3, out=3  OK
  Node 7: in=2, out=2  OK
  Node 8: in=3, out=3  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 33 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 19

  Summary:
    Original path length:  34 edges
    Spliced path length:   33 edges
    Splices performed:     19
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           3         3  ✓
    1     (0, 11)          -3        -3  ✓
    2      (1, 2)           2         2  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)           3         3  ✓
    7     (2, 11)           1         1  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)          -2        -2  ✓
   13      (6, 7)          -2        -2  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)           2         2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           2         2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 57
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 1, 3] → J=268, T=198, cost=0 → queued

[Iter 1] cost=0, J=268, T=198, edges=42, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 1, 3]
  [backtrack] Found solution with 6 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.4s
  *** SOLUTION FOUND! J=268, T_tour=198.4s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 0, 0, 2, 2, 0, -2, -2, 4, 0, -2, 0, 7, -3, 0, 6, 1, 3, 3, 0, 1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 0, 0, 2, 2, 0, -2, -2, 4, 0, -2, 0, 7, -3, 0, 6, 1, 3, 3, 0, 1]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 5), np.int64(2)), ((2, 3), np.int64(2)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(4)), ((4, 5), np.int64(-2)), ((6, 7), np.int64(7)), ((6, 9), np.int64(-3)), ((7, 8), np.int64(6)), ((7, 10), np.int64(1)), ((8, 9), np.int64(3)), ((8, 11), np.int64(3)), ((10, 11), np.int64(1))]

Blocked edge 1: idx=5, edge=(2, 3), flow_B=2  →  need Cm[5]=-2
Blocked edge 2: idx=13, edge=(6, 7), flow_B=7  →  need Cm[13]=-7
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=104   ||Cm||_1=30

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -3, 0, 1, -2, -1, 0, -4, 0, 0, -4]

Cm = C_oriented @ beta*:
  [0, 0, 0, 0, 0, -2, 2, 0, -1, -3, 2, -1, -1, -7, 1, 2, -4, -3, 0, 0, 1, 0]

Original flow_B:
  [2, -2, 0, 0, 2, 2, 0, -2, -2, 4, 0, -2, 0, 7, -3, 0, 6, 1, 3, 3, 0, 1]

flow_B + Cm (corrected flow):
  [2, -2, 0, 0, 2, 0, 2, -2, -3, 1, 2, -3, -1, 0, -2, 2, 2, -2, 3, 3, 1, 1]

Verification:
  flow_corrected[5] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[13] = 0  (should be 0, Cm=-7, d=-7)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 104  (minimized by MIQP)
  ||Cm||_1  = 30
  ||flow_B||_2² = 158
  ||flow_corrected||_2² = 80

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    5.7          
    1     (0, 11)        -2       0          -2    6.3          
    2      (1, 2)         0       0           0    4.9          
    3      (1, 3)         0       0           0    5.8          
    4      (1, 5)         2       0           2    5.9          
    5      (2, 3)         2      -2           0    4.4     -8.8s ← BLOCKED
    6      (2, 8)         0       2           2    7.7    +15.4s
    7     (2, 11)        -2       0          -2    4.6          
    8      (3, 4)        -2      -1          -3    7.5     +7.5s
    9      (3, 6)         4      -3           1    4.2    -12.6s
   10      (3, 8)         0       2           2    8.0    +16.0s
   11      (4, 5)        -2      -1          -3    4.4     +4.4s
   12      (5, 6)         0      -1          -1    5.6     +5.6s
   13      (6, 7)         7      -7           0    4.3    -30.1s ← BLOCKED
   14      (6, 9)        -3       1          -2    4.1     -4.1s
   15     (6, 10)         0       2           2    6.9    +13.8s
   16      (7, 8)         6      -4           2    4.2    -16.8s
   17     (7, 10)         1      -3          -2    4.1     +4.1s
   18      (8, 9)         3       0           3    4.3          
   19     (8, 11)         3       0           3    5.1          
   20     (9, 10)         0       1           1    5.7     +5.7s
   21    (10, 11)         1       0           1    4.1          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=2, out=2  OK
  Node 2: in=2, out=2  OK
  Node 3: in=3, out=3  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=3, out=3  OK
  Node 7: in=2, out=2  OK
  Node 8: in=6, out=6  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 19

  Summary:
    Original path length:  42 edges
    Spliced path length:   36 edges
    Splices performed:     19
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           2         2  ✓
    7     (2, 11)          -2        -2  ✓
    8      (3, 4)          -3        -3  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)           2         2  ✓
   11      (4, 5)          -3        -3  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)          -2        -2  ✓
   15     (6, 10)           2         2  ✓
   16      (7, 8)           2         2  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           3         3  ✓
   19     (8, 11)           3         3  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 58
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 1, 2, 2, 2, 2, 2, 3, 2, 2] → J=235, T=200, cost=0 → queued

[Iter 1] cost=0, J=235, T=200, edges=38, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 1, 2, 2, 2, 2, 2, 3, 2, 2]
  [backtrack] Found solution with 2 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.7s
  *** SOLUTION FOUND! J=235, T_tour=199.7s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 2, 0, 0, -2, 4, 0, -2, 0, 0, -2, -2, 0, 0, -2, 3, -3, 4, 3, 4, -1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 2, 0, 0, -2, 4, 0, -2, 0, 0, -2, -2, 0, 0, -2, 3, -3, 4, 3, 4, -1]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(2)), ((2, 3), np.int64(-2)), ((2, 8), np.int64(4)), ((3, 4), np.int64(-2)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-2)), ((6, 10), np.int64(-2)), ((7, 8), np.int64(3)), ((7, 10), np.int64(-3)), ((8, 9), np.int64(4)), ((8, 11), np.int64(3)), ((9, 10), np.int64(4)), ((10, 11), np.int64(-1))]

Blocked edge 1: idx=8, edge=(3, 4), flow_B=-2  →  need Cm[8]=2
Blocked edge 2: idx=18, edge=(8, 9), flow_B=4  →  need Cm[18]=-4
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=49   ||Cm||_1=23

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, 1, 0, -1, 1, 1, 0, -1, 1, 1, 3]

Cm = C_oriented @ beta*:
  [0, 0, 0, 1, -1, 1, -1, 0, 2, 2, -2, 2, 1, 0, 3, 0, 0, 0, -4, 1, -1, -1]

Original flow_B:
  [2, -2, 2, 0, 0, -2, 4, 0, -2, 0, 0, -2, -2, 0, 0, -2, 3, -3, 4, 3, 4, -1]

flow_B + Cm (corrected flow):
  [2, -2, 2, 1, -1, -1, 3, 0, 0, 2, -2, 0, -1, 0, 3, -2, 3, -3, 0, 4, 3, -2]

Verification:
  flow_corrected[8] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[18] = 0  (should be 0, Cm=-4, d=-4)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 49  (minimized by MIQP)
  ||Cm||_1  = 23
  ||flow_B||_2² = 108
  ||flow_corrected||_2² = 93

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    4.7          
    1     (0, 11)        -2       0          -2    6.2          
    2      (1, 2)         2       0           2    7.1          
    3      (1, 3)         0       1           1    5.2     +5.2s
    4      (1, 5)         0      -1          -1    6.6     +6.6s
    5      (2, 3)        -2       1          -1    5.2     -5.2s
    6      (2, 8)         4      -1           3    4.1     -4.1s
    7     (2, 11)         0       0           0    7.8          
    8      (3, 4)        -2       2           0    4.6     -9.2s ← BLOCKED
    9      (3, 6)         0       2           2    5.1    +10.2s
   10      (3, 8)         0      -2          -2    6.3    +12.6s
   11      (4, 5)        -2       2           0    6.2    -12.4s
   12      (5, 6)        -2       1          -1    4.3     -4.3s
   13      (6, 7)         0       0           0    4.7          
   14      (6, 9)         0       3           3    6.9    +20.7s
   15     (6, 10)        -2       0          -2    4.5          
   16      (7, 8)         3       0           3    5.5          
   17     (7, 10)        -3       0          -3    4.1          
   18      (8, 9)         4      -4           0    6.1    -24.4s ← BLOCKED
   19     (8, 11)         3       1           4    5.0     +5.0s
   20     (9, 10)         4      -1           3    6.0     -6.0s
   21    (10, 11)        -1      -1          -2    5.5     +5.5s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=3, out=3  OK
  Node 2: in=3, out=3  OK
  Node 3: in=3, out=3  OK
  Node 5: in=1, out=1  OK
  Node 6: in=4, out=4  OK
  Node 7: in=3, out=3  OK
  Node 8: in=6, out=6  OK
  Node 9: in=3, out=3  OK
  Node 10: in=5, out=5  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 37 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 21

  Summary:
    Original path length:  38 edges
    Spliced path length:   37 edges
    Splices performed:     21
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           2         2  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)           3         3  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)           2         2  ✓
   10      (3, 8)          -2        -2  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           3         3  ✓
   15     (6, 10)          -2        -2  ✓
   16      (7, 8)           3         3  ✓
   17     (7, 10)          -3        -3  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)           4         4  ✓
   20     (9, 10)           3         3  ✓
   21    (10, 11)          -2        -2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 59
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2] → J=194, T=200, cost=0 → queued

[Iter 1] cost=0, J=194, T=200, edges=35, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (1124 backtracks in 0.00s)
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 860 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1090 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1006 backtracks in 0.00s)
  [backtrack] Found solution with 182 backtracks in 0.00s
  [backtrack] Found solution with 685 backtracks in 0.00s
  [backtrack] Found solution with 511 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (530 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (398 backtracks in 0.00s)
  [backtrack] Found solution with 386 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=82.1s)
  Boundary nodes: [0, 4, 5, 7, 9] → expanding 5 children
    V_MIN=[4, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2] → J=193, T=197, cost=1 → queued
    V_MIN=[3, 2, 3, 1, 3, 2, 2, 2, 2, 2, 2, 2] → J=182, T=199, cost=1 → queued
    V_MIN=[3, 2, 3, 1, 2, 3, 2, 2, 2, 2, 2, 2] → J=190, T=199, cost=1 → queued
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 3, 2, 2, 2, 2] → J=193, T=200, cost=1 → queued
    V_MIN=[3, 2, 3, 1, 2, 2, 2, 2, 2, 3, 2, 2] → J=189, T=199, cost=1 → queued

[Iter 2] cost=1, J=193, T=197, edges=34, frontier=4, MILP_calls=6
  V_MIN=[4, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 19 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=197.2s
  *** SOLUTION FOUND! J=193, T_tour=197.2s ***

============================================================
Search done: 2 iters, 6 MILP calls, 6 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-4, 4, -4, 0, 0, -2, 2, -4, -2, 0, 0, -2, -2, 0, -2, 0, -2, 2, 0, 0, -2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-4, 4, -4, 0, 0, -2, 2, -4, -2, 0, 0, -2, -2, 0, -2, 0, -2, 2, 0, 0, -2, 0]
  Non-zero edges: [((0, 1), np.int64(-4)), ((0, 11), np.int64(4)), ((1, 2), np.int64(-4)), ((2, 3), np.int64(-2)), ((2, 8), np.int64(2)), ((2, 11), np.int64(-4)), ((3, 4), np.int64(-2)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-2)), ((6, 9), np.int64(-2)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(2)), ((9, 10), np.int64(-2))]

Blocked edge 1: idx=8, edge=(3, 4), flow_B=-2  →  need Cm[8]=2
Blocked edge 2: idx=2, edge=(1, 2), flow_B=-4  →  need Cm[2]=4
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=47   ||Cm||_1=23

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [4, 0, -1, 0, -2, -1, 0, -1, 0, 3, -2]

Cm = C_oriented @ beta*:
  [0, 0, 4, -1, -3, 2, 1, 1, 2, -1, 0, 2, -1, -1, -1, 0, -1, 0, 1, -1, 0, 0]

Original flow_B:
  [-4, 4, -4, 0, 0, -2, 2, -4, -2, 0, 0, -2, -2, 0, -2, 0, -2, 2, 0, 0, -2, 0]

flow_B + Cm (corrected flow):
  [-4, 4, 0, -1, -3, 0, 3, -3, 0, -1, 0, 0, -3, -1, -3, 0, -3, 2, 1, -1, -2, 0]

Verification:
  flow_corrected[8] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[2] = 0  (should be 0, Cm=4, d=4)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 47  (minimized by MIQP)
  ||Cm||_1  = 23
  ||flow_B||_2² = 100
  ||flow_corrected||_2² = 99

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -4       0          -4    5.6          
    1     (0, 11)         4       0           4    5.8          
    2      (1, 2)        -4       4           0    4.9    -19.6s ← BLOCKED
    3      (1, 3)         0      -1          -1    4.5     +4.5s
    4      (1, 5)         0      -3          -3    4.4    +13.2s
    5      (2, 3)        -2       2           0    5.9    -11.8s
    6      (2, 8)         2       1           3    4.5     +4.5s
    7     (2, 11)        -4       1          -3    5.1     -5.1s
    8      (3, 4)        -2       2           0    7.4    -14.8s ← BLOCKED
    9      (3, 6)         0      -1          -1    5.3     +5.3s
   10      (3, 8)         0       0           0    4.3          
   11      (4, 5)        -2       2           0    7.1    -14.2s
   12      (5, 6)        -2      -1          -3    5.0     +5.0s
   13      (6, 7)         0      -1          -1    7.7     +7.7s
   14      (6, 9)        -2      -1          -3    7.2     +7.2s
   15     (6, 10)         0       0           0    5.3          
   16      (7, 8)        -2      -1          -3    6.0     +6.0s
   17     (7, 10)         2       0           2    4.9          
   18      (8, 9)         0       1           1    5.7     +5.7s
   19     (8, 11)         0      -1          -1    6.6     +6.6s
   20     (9, 10)        -2       0          -2    7.8          
   21    (10, 11)         0       0           0    5.8          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=4, out=4  OK
  Node 1: in=4, out=4  OK
  Node 2: in=3, out=3  OK
  Node 3: in=1, out=1  OK
  Node 5: in=3, out=3  OK
  Node 6: in=4, out=4  OK
  Node 7: in=3, out=3  OK
  Node 8: in=4, out=4  OK
  Node 9: in=3, out=3  OK
  Node 10: in=2, out=2  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 14

  Summary:
    Original path length:  34 edges
    Spliced path length:   35 edges
    Splices performed:     14
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -4        -4  ✓
    1     (0, 11)           4         4  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)          -3        -3  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           3         3  ✓
    7     (2, 11)          -3        -3  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)          -3        -3  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)          -3        -3  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)          -3        -3  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)           1         1  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)          -2        -2  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 60
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 3] → J=190, T=199, cost=0 → queued

[Iter 1] cost=0, J=190, T=199, edges=35, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 3]
  [backtrack] Found solution with 4 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.2s
  *** SOLUTION FOUND! J=190, T_tour=199.2s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -1, 0, -1, -2, 0, 1, 2, -5, 1, 2, 1, 0, -2, -2, 1, -1, 0, 2, -2, -5]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -1, 0, -1, -2, 0, 1, 2, -5, 1, 2, 1, 0, -2, -2, 1, -1, 0, 2, -2, -5]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-1)), ((1, 5), np.int64(-1)), ((2, 3), np.int64(-2)), ((2, 11), np.int64(1)), ((3, 4), np.int64(2)), ((3, 6), np.int64(-5)), ((3, 8), np.int64(1)), ((4, 5), np.int64(2)), ((5, 6), np.int64(1)), ((6, 9), np.int64(-2)), ((6, 10), np.int64(-2)), ((7, 8), np.int64(1)), ((7, 10), np.int64(-1)), ((8, 11), np.int64(2)), ((9, 10), np.int64(-2)), ((10, 11), np.int64(-5))]

Blocked edge 1: idx=4, edge=(1, 5), flow_B=-1  →  need Cm[4]=1
Blocked edge 2: idx=16, edge=(7, 8), flow_B=1  →  need Cm[16]=-1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=8   ||Cm||_1=8

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, 0, 0, 0, 0, 0, 0, -1, 0, -1, -1]

Cm = C_oriented @ beta*:
  [0, 0, 0, -1, 1, 0, 0, 0, -1, -1, 1, -1, 0, -1, 0, 0, -1, 0, 0, 0, 0, 0]

Original flow_B:
  [-2, 2, -1, 0, -1, -2, 0, 1, 2, -5, 1, 2, 1, 0, -2, -2, 1, -1, 0, 2, -2, -5]

flow_B + Cm (corrected flow):
  [-2, 2, -1, -1, 0, -2, 0, 1, 1, -6, 2, 1, 1, -1, -2, -2, 0, -1, 0, 2, -2, -5]

Verification:
  flow_corrected[4] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[16] = 0  (should be 0, Cm=-1, d=-1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 8  (minimized by MIQP)
  ||Cm||_1  = 8
  ||flow_B||_2² = 93
  ||flow_corrected||_2² = 101

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    5.3          
    1     (0, 11)         2       0           2    8.0          
    2      (1, 2)        -1       0          -1    4.5          
    3      (1, 3)         0      -1          -1    6.0     +6.0s
    4      (1, 5)        -1       1           0    5.1     -5.1s ← BLOCKED
    5      (2, 3)        -2       0          -2    4.9          
    6      (2, 8)         0       0           0    6.0          
    7     (2, 11)         1       0           1    6.5          
    8      (3, 4)         2      -1           1    6.5     -6.5s
    9      (3, 6)        -5      -1          -6    4.3     +4.3s
   10      (3, 8)         1       1           2    6.3     +6.3s
   11      (4, 5)         2      -1           1    7.4     -7.4s
   12      (5, 6)         1       0           1    5.2          
   13      (6, 7)         0      -1          -1    8.0     +8.0s
   14      (6, 9)        -2       0          -2    6.2          
   15     (6, 10)        -2       0          -2    7.8          
   16      (7, 8)         1      -1           0    5.4     -5.4s ← BLOCKED
   17     (7, 10)        -1       0          -1    6.1          
   18      (8, 9)         0       0           0    8.0          
   19     (8, 11)         2       0           2    4.8          
   20     (9, 10)        -2       0          -2    7.9          
   21    (10, 11)        -5       0          -5    4.2          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=2, out=2  OK
  Node 2: in=2, out=2  OK
  Node 3: in=6, out=6  OK
  Node 4: in=1, out=1  OK
  Node 5: in=1, out=1  OK
  Node 6: in=6, out=6  OK
  Node 7: in=1, out=1  OK
  Node 8: in=2, out=2  OK
  Node 9: in=2, out=2  OK
  Node 10: in=5, out=5  OK
  Node 11: in=5, out=5  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 18

  Summary:
    Original path length:  35 edges
    Spliced path length:   35 edges
    Splices performed:     18
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)          -1        -1  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           1         1  ✓
    8      (3, 4)           1         1  ✓
    9      (3, 6)          -6        -6  ✓
   10      (3, 8)           2         2  ✓
   11      (4, 5)           1         1  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)          -2        -2  ✓
   15     (6, 10)          -2        -2  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)           2         2  ✓
   20     (9, 10)          -2        -2  ✓
   21    (10, 11)          -5        -5  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 61
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 3, 2, 3, 1, 3, 2, 2, 2, 2, 2] → J=204, T=200, cost=0 → queued

[Iter 1] cost=0, J=204, T=200, edges=34, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 3, 2, 3, 1, 3, 2, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (103 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (41 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (63 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (146 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (70 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (69 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (94 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (41 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 6, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 3, 2, 3, 1, 3, 2, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 2, 4, 1, 3, 2, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 2, 3, 1, 4, 2, 2, 2, 2, 2] → J=201, T=200, cost=1 → queued
    V_MIN=[3, 2, 3, 2, 3, 1, 3, 3, 2, 2, 2, 2] → J=196, T=199, cost=1 → queued
    V_MIN=[3, 2, 3, 2, 3, 1, 3, 2, 3, 2, 2, 2] → J=199, T=200, cost=1 → queued
    V_MIN=[3, 2, 3, 2, 3, 1, 3, 2, 2, 3, 2, 2] → J=194, T=200, cost=1 → queued
    V_MIN=[3, 2, 3, 2, 3, 1, 3, 2, 2, 2, 3, 2] → J=198, T=200, cost=1 → queued

[Iter 2] cost=1, J=201, T=200, edges=34, frontier=4, MILP_calls=8
  V_MIN=[3, 2, 3, 2, 3, 1, 4, 2, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (43 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (45 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (83 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (61 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (58 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (83 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (34 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (53 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (82 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (60 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[4, 2, 3, 2, 3, 1, 4, 2, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 2, 3, 1, 4, 2, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 2, 4, 1, 4, 2, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 2, 3, 1, 5, 2, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 2, 3, 1, 4, 3, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 2, 3, 1, 4, 2, 3, 2, 2, 2] → J=199, T=199, cost=2 → queued
    V_MIN=[3, 2, 3, 2, 3, 1, 4, 2, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 2, 3, 1, 4, 2, 2, 2, 3, 2] → J=198, T=200, cost=2 → queued

[Iter 3] cost=1, J=199, T=200, edges=34, frontier=5, MILP_calls=16
  V_MIN=[3, 2, 3, 2, 3, 1, 3, 2, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (414 backtracks in 0.00s)
  [backtrack] Found solution with 135 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (291 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (442 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (455 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (340 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (270 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (394 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (324 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (149 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (391 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (302 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=93.9s)
  Boundary nodes: [0, 2, 4, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 3, 2, 3, 1, 3, 2, 3, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 2, 3, 1, 3, 2, 3, 2, 2, 2] → J=199, T=199, cost=2 → queued
    V_MIN=[3, 2, 3, 2, 4, 1, 3, 2, 3, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 2, 3, 1, 3, 3, 3, 2, 2, 2] → J=196, T=199, cost=2 → queued
    V_MIN=[3, 2, 3, 2, 3, 1, 3, 2, 4, 2, 2, 2] → J=193, T=200, cost=2 → queued
    V_MIN=[3, 2, 3, 2, 3, 1, 3, 2, 3, 3, 2, 2] → J=194, T=200, cost=2 → queued
    V_MIN=[3, 2, 3, 2, 3, 1, 3, 2, 3, 2, 3, 2] → J=192, T=198, cost=2 → queued

[Iter 4] cost=1, J=198, T=200, edges=34, frontier=9, MILP_calls=23
  V_MIN=[3, 2, 3, 2, 3, 1, 3, 2, 2, 2, 3, 2]
  [backtrack] Found solution with 362 backtracks in 0.00s
  [backtrack] Found solution with 349 backtracks in 0.00s
  [backtrack] Found solution with 394 backtracks in 0.00s
  [backtrack] Found solution with 447 backtracks in 0.00s
  [backtrack] Found solution with 582 backtracks in 0.00s
  [backtrack] Found solution with 733 backtracks in 0.00s
  [backtrack] Found solution with 266 backtracks in 0.00s
  [backtrack] Found solution with 689 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (533 backtracks in 0.00s)
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 457 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=101.6s)
  Boundary nodes: [0, 2, 4, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 3, 2, 3, 1, 3, 2, 2, 2, 3, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 4, 2, 3, 1, 3, 2, 2, 2, 3, 2] → J=197, T=199, cost=2 → queued
    V_MIN=[3, 2, 3, 2, 4, 1, 3, 2, 2, 2, 3, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 2, 3, 1, 3, 3, 2, 2, 3, 2] → J=195, T=200, cost=2 → queued
    V_MIN=[3, 2, 3, 2, 3, 1, 3, 2, 2, 3, 3, 2] → MILP infeasible, pruned
    V_MIN=[3, 2, 3, 2, 3, 1, 3, 2, 2, 2, 4, 2] → J=191, T=199, cost=2 → queued

[Iter 5] cost=1, J=196, T=199, edges=34, frontier=11, MILP_calls=29
  V_MIN=[3, 2, 3, 2, 3, 1, 3, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.0s
  *** SOLUTION FOUND! J=196, T_tour=199.0s ***

============================================================
Search done: 5 iters, 29 MILP calls, 29 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, 0, 0, -3, 0, 3, -3, 3, -3, 0, 3, 0, -1, -2, 0, -3, 2, 0, 0, -2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, 0, 0, -3, 0, 3, -3, 3, -3, 0, 3, 0, -1, -2, 0, -3, 2, 0, 0, -2, 0]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 5), np.int64(-3)), ((2, 8), np.int64(3)), ((2, 11), np.int64(-3)), ((3, 4), np.int64(3)), ((3, 6), np.int64(-3)), ((4, 5), np.int64(3)), ((6, 7), np.int64(-1)), ((6, 9), np.int64(-2)), ((7, 8), np.int64(-3)), ((7, 10), np.int64(2)), ((9, 10), np.int64(-2))]

Blocked edge 1: idx=6, edge=(2, 8), flow_B=3  →  need Cm[6]=-3
Blocked edge 2: idx=17, edge=(7, 10), flow_B=2  →  need Cm[17]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=29   ||Cm||_1=17

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, -2, 0, 1, 3, 1, 0, 1, 0, -1, 1]

Cm = C_oriented @ beta*:
  [0, 0, -1, 0, 1, 2, -3, 0, 0, 0, 2, 0, 1, -1, 1, 1, 1, -2, 0, 0, 1, 0]

Original flow_B:
  [-3, 3, 0, 0, -3, 0, 3, -3, 3, -3, 0, 3, 0, -1, -2, 0, -3, 2, 0, 0, -2, 0]

flow_B + Cm (corrected flow):
  [-3, 3, -1, 0, -2, 2, 0, -3, 3, -3, 2, 3, 1, -2, -1, 1, -2, 0, 0, 0, -1, 0]

Verification:
  flow_corrected[6] = 0  (should be 0, Cm=-3, d=-3)
  flow_corrected[17] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 29  (minimized by MIQP)
  ||Cm||_1  = 17
  ||flow_B||_2² = 94
  ||flow_corrected||_2² = 79

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       0          -3    7.5          
    1     (0, 11)         3       0           3    5.8          
    2      (1, 2)         0      -1          -1    5.9     +5.9s
    3      (1, 3)         0       0           0    7.5          
    4      (1, 5)        -3       1          -2    6.7     -6.7s
    5      (2, 3)         0       2           2    4.3     +8.6s
    6      (2, 8)         3      -3           0    4.1    -12.3s ← BLOCKED
    7     (2, 11)        -3       0          -3    6.9          
    8      (3, 4)         3       0           3    6.8          
    9      (3, 6)        -3       0          -3    4.2          
   10      (3, 8)         0       2           2    5.9    +11.8s
   11      (4, 5)         3       0           3    5.5          
   12      (5, 6)         0       1           1    6.4     +6.4s
   13      (6, 7)        -1      -1          -2    6.9     +6.9s
   14      (6, 9)        -2       1          -1    4.8     -4.8s
   15     (6, 10)         0       1           1    6.1     +6.1s
   16      (7, 8)        -3       1          -2    5.2     -5.2s
   17     (7, 10)         2      -2           0    4.6     -9.2s ← BLOCKED
   18      (8, 9)         0       0           0    7.8          
   19     (8, 11)         0       0           0    6.4          
   20     (9, 10)        -2       1          -1    7.6     -7.6s
   21    (10, 11)         0       0           0    5.8          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=3, out=3  OK
  Node 2: in=3, out=3  OK
  Node 3: in=5, out=5  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=4, out=4  OK
  Node 7: in=2, out=2  OK
  Node 8: in=2, out=2  OK
  Node 9: in=1, out=1  OK
  Node 10: in=1, out=1  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 33 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 18

  Summary:
    Original path length:  34 edges
    Spliced path length:   33 edges
    Splices performed:     18
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -3        -3  ✓
    1     (0, 11)           3         3  ✓
    2      (1, 2)          -1        -1  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)          -2        -2  ✓
    5      (2, 3)           2         2  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)          -3        -3  ✓
    8      (3, 4)           3         3  ✓
    9      (3, 6)          -3        -3  ✓
   10      (3, 8)           2         2  ✓
   11      (4, 5)           3         3  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)          -2        -2  ✓
   14      (6, 9)          -1        -1  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)          -2        -2  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)          -1        -1  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 62
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2, 1] → J=196, T=199, cost=0 → queued

[Iter 1] cost=0, J=196, T=199, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2, 1]
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.3s
  *** SOLUTION FOUND! J=196, T_tour=199.3s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 0, 0, 2, 0, -4, 4, -2, 2, 0, -2, 0, -2, 5, -1, -1, -1, -5, 0, 0, -2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 0, 0, 2, 0, -4, 4, -2, 2, 0, -2, 0, -2, 5, -1, -1, -1, -5, 0, 0, -2]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 5), np.int64(2)), ((2, 8), np.int64(-4)), ((2, 11), np.int64(4)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(2)), ((4, 5), np.int64(-2)), ((6, 7), np.int64(-2)), ((6, 9), np.int64(5)), ((6, 10), np.int64(-1)), ((7, 8), np.int64(-1)), ((7, 10), np.int64(-1)), ((8, 9), np.int64(-5)), ((10, 11), np.int64(-2))]

Blocked edge 1: idx=7, edge=(2, 11), flow_B=4  →  need Cm[7]=-4
Blocked edge 2: idx=11, edge=(4, 5), flow_B=-2  →  need Cm[11]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=49   ||Cm||_1=25

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, -2, 4, 1, 3, 2, 0, 3, -2, 0, 3]

Cm = C_oriented @ beta*:
  [0, 0, -1, 1, 0, 2, 1, -4, 2, 1, 0, 2, 2, 1, 1, 1, 1, 0, 0, 2, 1, 2]

Original flow_B:
  [2, -2, 0, 0, 2, 0, -4, 4, -2, 2, 0, -2, 0, -2, 5, -1, -1, -1, -5, 0, 0, -2]

flow_B + Cm (corrected flow):
  [2, -2, -1, 1, 2, 2, -3, 0, 0, 3, 0, 0, 2, -1, 6, 0, 0, -1, -5, 2, 1, 0]

Verification:
  flow_corrected[7] = 0  (should be 0, Cm=-4, d=-4)
  flow_corrected[11] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 49  (minimized by MIQP)
  ||Cm||_1  = 25
  ||flow_B||_2² = 117
  ||flow_corrected||_2² = 108

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    8.0          
    1     (0, 11)        -2       0          -2    6.9          
    2      (1, 2)         0      -1          -1    6.9     +6.9s
    3      (1, 3)         0       1           1    5.6     +5.6s
    4      (1, 5)         2       0           2    4.8          
    5      (2, 3)         0       2           2    7.8    +15.6s
    6      (2, 8)        -4       1          -3    4.9     -4.9s
    7     (2, 11)         4      -4           0    4.2    -16.8s ← BLOCKED
    8      (3, 4)        -2       2           0    7.5    -15.0s
    9      (3, 6)         2       1           3    7.6     +7.6s
   10      (3, 8)         0       0           0    7.9          
   11      (4, 5)        -2       2           0    6.4    -12.8s ← BLOCKED
   12      (5, 6)         0       2           2    7.9    +15.8s
   13      (6, 7)        -2       1          -1    5.6     -5.6s
   14      (6, 9)         5       1           6    4.6     +4.6s
   15     (6, 10)        -1       1           0    6.3     -6.3s
   16      (7, 8)        -1       1           0    5.5     -5.5s
   17     (7, 10)        -1       0          -1    5.2          
   18      (8, 9)        -5       0          -5    4.1          
   19     (8, 11)         0       2           2    5.9    +11.8s
   20     (9, 10)         0       1           1    7.6     +7.6s
   21    (10, 11)        -2       2           0    4.4     -8.8s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=3, out=3  OK
  Node 2: in=3, out=3  OK
  Node 3: in=3, out=3  OK
  Node 5: in=2, out=2  OK
  Node 6: in=6, out=6  OK
  Node 7: in=1, out=1  OK
  Node 8: in=5, out=5  OK
  Node 9: in=6, out=6  OK
  Node 10: in=1, out=1  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 21

  Summary:
    Original path length:  37 edges
    Spliced path length:   34 edges
    Splices performed:     21
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)          -1        -1  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           2         2  ✓
    6      (2, 8)          -3        -3  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)           3         3  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)           2         2  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)           6         6  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)          -5        -5  ✓
   19     (8, 11)           2         2  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 63
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 1, 3, 2, 3, 2, 3, 3, 2, 2, 2] → J=148, T=200, cost=0 → queued

[Iter 1] cost=0, J=148, T=200, edges=32, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 1, 3, 2, 3, 2, 3, 3, 2, 2, 2]
  [backtrack] Found solution with 151 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.6s
  *** SOLUTION FOUND! J=148, T_tour=199.6s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [3, -3, 0, 2, 1, 1, -1, 0, 2, 0, 1, 2, 3, 1, 2, 0, 3, -2, 0, 3, 2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [3, -3, 0, 2, 1, 1, -1, 0, 2, 0, 1, 2, 3, 1, 2, 0, 3, -2, 0, 3, 2, 0]
  Non-zero edges: [((0, 1), np.int64(3)), ((0, 11), np.int64(-3)), ((1, 3), np.int64(2)), ((1, 5), np.int64(1)), ((2, 3), np.int64(1)), ((2, 8), np.int64(-1)), ((3, 4), np.int64(2)), ((3, 8), np.int64(1)), ((4, 5), np.int64(2)), ((5, 6), np.int64(3)), ((6, 7), np.int64(1)), ((6, 9), np.int64(2)), ((7, 8), np.int64(3)), ((7, 10), np.int64(-2)), ((8, 11), np.int64(3)), ((9, 10), np.int64(2))]

Blocked edge 1: idx=4, edge=(1, 5), flow_B=1  →  need Cm[4]=-1
Blocked edge 2: idx=10, edge=(3, 8), flow_B=1  →  need Cm[10]=-1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=10   ||Cm||_1=10

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 0, -1, 1, -1, 0, -1, 0, 0, 1, 0]

Cm = C_oriented @ beta*:
  [-1, 1, 0, 0, -1, 0, 0, 0, 1, 0, -1, 1, 0, 0, 1, -1, 0, 0, 0, -1, 1, 0]

Original flow_B:
  [3, -3, 0, 2, 1, 1, -1, 0, 2, 0, 1, 2, 3, 1, 2, 0, 3, -2, 0, 3, 2, 0]

flow_B + Cm (corrected flow):
  [2, -2, 0, 2, 0, 1, -1, 0, 3, 0, 0, 3, 3, 1, 3, -1, 3, -2, 0, 2, 3, 0]

Verification:
  flow_corrected[4] = 0  (should be 0, Cm=-1, d=-1)
  flow_corrected[10] = 0  (should be 0, Cm=-1, d=-1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 10  (minimized by MIQP)
  ||Cm||_1  = 10
  ||flow_B||_2² = 74
  ||flow_corrected||_2² = 78

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         3      -1           2    7.1     -7.1s
    1     (0, 11)        -3       1          -2    6.7     -6.7s
    2      (1, 2)         0       0           0    7.4          
    3      (1, 3)         2       0           2    5.8          
    4      (1, 5)         1      -1           0    6.3     -6.3s ← BLOCKED
    5      (2, 3)         1       0           1    4.0          
    6      (2, 8)        -1       0          -1    7.5          
    7     (2, 11)         0       0           0    6.3          
    8      (3, 4)         2       1           3    7.8     +7.8s
    9      (3, 6)         0       0           0    7.6          
   10      (3, 8)         1      -1           0    6.7     -6.7s ← BLOCKED
   11      (4, 5)         2       1           3    7.6     +7.6s
   12      (5, 6)         3       0           3    4.8          
   13      (6, 7)         1       0           1    7.2          
   14      (6, 9)         2       1           3    4.1     +4.1s
   15     (6, 10)         0      -1          -1    7.7     +7.7s
   16      (7, 8)         3       0           3    6.7          
   17     (7, 10)        -2       0          -2    7.0          
   18      (8, 9)         0       0           0    7.9          
   19     (8, 11)         3      -1           2    5.6     -5.6s
   20     (9, 10)         2       1           3    5.3     +5.3s
   21    (10, 11)         0       0           0    6.0          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=2, out=2  OK
  Node 2: in=1, out=1  OK
  Node 3: in=3, out=3  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=4, out=4  OK
  Node 7: in=3, out=3  OK
  Node 8: in=3, out=3  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 32 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 14

  Summary:
    Original path length:  32 edges
    Spliced path length:   32 edges
    Splices performed:     14
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)           2         2  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)           1         1  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           3         3  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           3         3  ✓
   12      (5, 6)           3         3  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)           3         3  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           3         3  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)           2         2  ✓
   20     (9, 10)           3         3  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 64
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 3, 2] → J=221, T=199, cost=0 → queued

[Iter 1] cost=0, J=221, T=199, edges=40, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 3, 2]
  [backtrack] Found solution with 109 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.4s
  *** SOLUTION FOUND! J=221, T_tour=199.4s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 5, -1, -2, 0, 5, 0, 2, 2, -5, 2, 0, 0, 0, 2, 1, -1, -2, 3, -2, -1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 5, -1, -2, 0, 5, 0, 2, 2, -5, 2, 0, 0, 0, 2, 1, -1, -2, 3, -2, -1]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(5)), ((1, 3), np.int64(-1)), ((1, 5), np.int64(-2)), ((2, 8), np.int64(5)), ((3, 4), np.int64(2)), ((3, 6), np.int64(2)), ((3, 8), np.int64(-5)), ((4, 5), np.int64(2)), ((6, 10), np.int64(2)), ((7, 8), np.int64(1)), ((7, 10), np.int64(-1)), ((8, 9), np.int64(-2)), ((8, 11), np.int64(3)), ((9, 10), np.int64(-2)), ((10, 11), np.int64(-1))]

Blocked edge 1: idx=8, edge=(3, 4), flow_B=2  →  need Cm[8]=-2
Blocked edge 2: idx=15, edge=(6, 10), flow_B=2  →  need Cm[15]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=22   ||Cm||_1=16

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, 2, 0, 0, 0, -1, 0, -1, 1, -1, 0]

Cm = C_oriented @ beta*:
  [0, 0, 0, -1, 1, 0, 0, 0, -2, 1, 0, -2, -1, 1, 1, -2, 0, 1, -1, 1, 0, -1]

Original flow_B:
  [2, -2, 5, -1, -2, 0, 5, 0, 2, 2, -5, 2, 0, 0, 0, 2, 1, -1, -2, 3, -2, -1]

flow_B + Cm (corrected flow):
  [2, -2, 5, -2, -1, 0, 5, 0, 0, 3, -5, 0, -1, 1, 1, 0, 1, 0, -3, 4, -2, -2]

Verification:
  flow_corrected[8] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[15] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 22  (minimized by MIQP)
  ||Cm||_1  = 16
  ||flow_B||_2² = 124
  ||flow_corrected||_2² = 134

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    6.3          
    1     (0, 11)        -2       0          -2    4.7          
    2      (1, 2)         5       0           5    4.1          
    3      (1, 3)        -1      -1          -2    4.8     +4.8s
    4      (1, 5)        -2       1          -1    4.1     -4.1s
    5      (2, 3)         0       0           0    6.5          
    6      (2, 8)         5       0           5    4.9          
    7     (2, 11)         0       0           0    5.6          
    8      (3, 4)         2      -2           0    6.5    -13.0s ← BLOCKED
    9      (3, 6)         2       1           3    4.0     +4.0s
   10      (3, 8)        -5       0          -5    4.1          
   11      (4, 5)         2      -2           0    5.5    -11.0s
   12      (5, 6)         0      -1          -1    4.9     +4.9s
   13      (6, 7)         0       1           1    5.6     +5.6s
   14      (6, 9)         0       1           1    7.5     +7.5s
   15     (6, 10)         2      -2           0    5.0    -10.0s ← BLOCKED
   16      (7, 8)         1       0           1    6.4          
   17     (7, 10)        -1       1           0    4.9     -4.9s
   18      (8, 9)        -2      -1          -3    4.8     +4.8s
   19     (8, 11)         3       1           4    4.7     +4.7s
   20     (9, 10)        -2       0          -2    7.6          
   21    (10, 11)        -1      -1          -2    6.7     +6.7s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=5, out=5  OK
  Node 2: in=5, out=5  OK
  Node 3: in=5, out=5  OK
  Node 5: in=1, out=1  OK
  Node 6: in=3, out=3  OK
  Node 7: in=1, out=1  OK
  Node 8: in=9, out=9  OK
  Node 9: in=3, out=3  OK
  Node 10: in=2, out=2  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 40 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 20

  Summary:
    Original path length:  40 edges
    Spliced path length:   40 edges
    Splices performed:     20
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           5         5  ✓
    3      (1, 3)          -2        -2  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           5         5  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)           3         3  ✓
   10      (3, 8)          -5        -5  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)           1         1  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)          -3        -3  ✓
   19     (8, 11)           4         4  ✓
   20     (9, 10)          -2        -2  ✓
   21    (10, 11)          -2        -2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 65
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2] → J=196, T=198, cost=0 → queued

[Iter 1] cost=0, J=196, T=198, edges=39, frontier=0, MILP_calls=1
  V_MIN=[2, 1, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 221 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.5s
  *** SOLUTION FOUND! J=196, T_tour=198.5s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 2, 0, 0, -1, 3, 0, -2, 1, 0, -2, -2, -6, 3, 2, -6, 0, -3, 0, 0, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 2, 0, 0, -1, 3, 0, -2, 1, 0, -2, -2, -6, 3, 2, -6, 0, -3, 0, 0, 2]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(2)), ((2, 3), np.int64(-1)), ((2, 8), np.int64(3)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(-6)), ((6, 9), np.int64(3)), ((6, 10), np.int64(2)), ((7, 8), np.int64(-6)), ((8, 9), np.int64(-3)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=16, edge=(7, 8), flow_B=-6  →  need Cm[16]=6
Blocked edge 2: idx=1, edge=(0, 11), flow_B=-2  →  need Cm[1]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=93   ||Cm||_1=33

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -1, -1, 1, 0, 1, -2, 3, 3, -1, 2]

Cm = C_oriented @ beta*:
  [-2, 2, -2, -1, 1, 0, -1, -1, 0, 1, -2, 0, 1, 2, 0, 0, 6, -4, 1, 2, 1, -3]

Original flow_B:
  [2, -2, 2, 0, 0, -1, 3, 0, -2, 1, 0, -2, -2, -6, 3, 2, -6, 0, -3, 0, 0, 2]

flow_B + Cm (corrected flow):
  [0, 0, 0, -1, 1, -1, 2, -1, -2, 2, -2, -2, -1, -4, 3, 2, 0, -4, -2, 2, 1, -1]

Verification:
  flow_corrected[16] = 0  (should be 0, Cm=6, d=6)
  flow_corrected[1] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 93  (minimized by MIQP)
  ||Cm||_1  = 33
  ||flow_B||_2² = 133
  ||flow_corrected||_2² = 80

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2      -2           0    4.5     -9.0s
    1     (0, 11)        -2       2           0    6.2    -12.4s ← BLOCKED
    2      (1, 2)         2      -2           0    5.9    -11.8s
    3      (1, 3)         0      -1          -1    6.7     +6.7s
    4      (1, 5)         0       1           1    7.0     +7.0s
    5      (2, 3)        -1       0          -1    4.7          
    6      (2, 8)         3      -1           2    4.4     -4.4s
    7     (2, 11)         0      -1          -1    7.7     +7.7s
    8      (3, 4)        -2       0          -2    4.9          
    9      (3, 6)         1       1           2    4.4     +4.4s
   10      (3, 8)         0      -2          -2    7.2    +14.4s
   11      (4, 5)        -2       0          -2    4.4          
   12      (5, 6)        -2       1          -1    5.8     -5.8s
   13      (6, 7)        -6       2          -4    4.4     -8.8s
   14      (6, 9)         3       0           3    6.1          
   15     (6, 10)         2       0           2    5.8          
   16      (7, 8)        -6       6           0    4.7    -28.2s ← BLOCKED
   17     (7, 10)         0      -4          -4    7.9    +31.6s
   18      (8, 9)        -3       1          -2    6.7     -6.7s
   19     (8, 11)         0       2           2    6.5    +13.0s
   20     (9, 10)         0       1           1    6.2     +6.2s
   21    (10, 11)         2      -3          -1    4.1     -4.1s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=1, out=1  OK
  Node 2: in=2, out=2  OK
  Node 3: in=4, out=4  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=6, out=6  OK
  Node 7: in=4, out=4  OK
  Node 8: in=4, out=4  OK
  Node 9: in=3, out=3  OK
  Node 10: in=4, out=4  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 26

  Summary:
    Original path length:  39 edges
    Spliced path length:   34 edges
    Splices performed:     26
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)           2         2  ✓
    7     (2, 11)          -1        -1  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           2         2  ✓
   10      (3, 8)          -2        -2  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)          -4        -4  ✓
   14      (6, 9)           3         3  ✓
   15     (6, 10)           2         2  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)          -4        -4  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)           2         2  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 66
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=230, T=200, cost=0 → queued

[Iter 1] cost=0, J=230, T=200, edges=40, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (11323 backtracks in 0.02s)
  [backtrack] EXHAUSTED search space (10396 backtracks in 0.02s)
  [backtrack] EXHAUSTED search space (8504 backtracks in 0.02s)
  [backtrack] Found solution with 772 backtracks in 0.00s
  [backtrack] Found solution with 352 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 774 backtracks in 0.00s
  [backtrack] Found solution with 3726 backtracks in 0.01s
  [backtrack] Found solution with 2771 backtracks in 0.01s
  [backtrack] Found solution with 1180 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (5679 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (5442 backtracks in 0.01s)
  DFS: latency violated (1 nodes, worst_gap=105.7s)
  Boundary nodes: [0, 1, 2, 4, 7, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=223, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=223, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=227, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 1, 3] → J=217, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 1, 3] → J=230, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3] → J=229, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3] → J=229, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 1, 4] → J=222, T=199, cost=1 → queued

[Iter 2] cost=1, J=230, T=200, edges=40, frontier=7, MILP_calls=9
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (717 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (671 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (629 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (5291 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3202 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3525 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (5394 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3698 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3811 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2520 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (675 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (420 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 3, 2, 2, 1, 3] → J=223, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 1, 3] → J=223, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 3, 3, 2, 2, 1, 3] → J=224, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 3, 2, 2, 1, 3] → J=216, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 3, 2, 2, 1, 3] → J=223, T=198, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 3] → J=229, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 3] → J=226, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 1, 4] → J=218, T=200, cost=2 → queued

[Iter 3] cost=1, J=229, T=200, edges=40, frontier=14, MILP_calls=17
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3]
  [backtrack] EXHAUSTED search space (779 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (733 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (679 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (5678 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3264 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3838 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (5666 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3867 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3317 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3090 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (742 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (455 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3] → J=222, T=198, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 3, 1, 3] → J=222, T=198, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 1, 3] → J=227, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 3, 1, 3] → J=216, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 1, 3] → J=228, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 4, 1, 3] → J=228, T=198, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 3] → J=226, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 1, 4] → J=220, T=200, cost=2 → queued

[Iter 4] cost=1, J=229, T=200, edges=40, frontier=21, MILP_calls=25
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3]
  [backtrack] EXHAUSTED search space (5667 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (6013 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3342 backtracks in 0.01s)
  [backtrack] Found solution with 405 backtracks in 0.00s
  [backtrack] Found solution with 352 backtracks in 0.00s
  [backtrack] Found solution with 799 backtracks in 0.00s
  [backtrack] Found solution with 405 backtracks in 0.00s
  [backtrack] Found solution with 2056 backtracks in 0.00s
  [backtrack] Found solution with 1969 backtracks in 0.00s
  [backtrack] Found solution with 713 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (5736 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2808 backtracks in 0.01s)
  DFS: latency violated (1 nodes, worst_gap=104.8s)
  Boundary nodes: [0, 1, 2, 4, 5, 7, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3] → J=219, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3] → J=219, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 3] → J=224, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 3] → J=215, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 3] → J=224, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3, 3] → J=225, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 4] → J=222, T=199, cost=2 → queued

[Iter 5] cost=1, J=227, T=200, edges=40, frontier=27, MILP_calls=32
  V_MIN=[2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (969 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1039 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1438 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (760 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (5777 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (8030 backtracks in 0.02s)
  [backtrack] EXHAUSTED search space (11726 backtracks in 0.03s)
  [backtrack] EXHAUSTED search space (2687 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (4011 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (8726 backtracks in 0.02s)
  [backtrack] EXHAUSTED search space (2804 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (658 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 7, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 3, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=219, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=219, T=199, cost=2 → queued
    V_MIN=[2, 2, 4, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=220, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 1, 3] → J=217, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 2, 3, 3, 2, 2, 2, 1, 3] → J=223, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 1, 4] → J=221, T=200, cost=2 → queued

[Iter 6] cost=1, J=223, T=200, edges=40, frontier=32, MILP_calls=38
  V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (411 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (216 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (229 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2585 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1777 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (841 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1080 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1593 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2513 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1243 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (245 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (330 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 9, 10, 11] → expanding 7 children
    V_MIN=[4, 2, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=206, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 3, 2, 3, 2, 2, 2, 1, 3] → J=212, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 1, 3] → J=220, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 1, 4] → J=215, T=199, cost=2 → queued

[Iter 7] cost=1, J=223, T=200, edges=40, frontier=35, MILP_calls=42
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (338 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (327 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (228 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (959 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (554 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (777 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1309 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1086 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (884 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (907 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (260 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (212 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [1, 2, 4, 5, 9, 10, 11] → expanding 7 children
    V_MIN=[2, 4, 2, 2, 2, 2, 3, 2, 2, 2, 1, 3] → J=211, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 2, 2, 2, 1, 3] → J=212, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 2, 2, 2, 1, 3] → J=220, T=198, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 1, 4] → J=215, T=199, cost=2 → queued

[Iter 8] cost=1, J=222, T=199, edges=39, frontier=38, MILP_calls=46
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 1, 4]
  [backtrack] EXHAUSTED search space (6484 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (5873 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (4652 backtracks in 0.01s)
  [backtrack] Found solution with 183 backtracks in 0.00s
  [backtrack] Found solution with 173 backtracks in 0.00s
  [backtrack] Found solution with 849 backtracks in 0.00s
  [backtrack] Found solution with 186 backtracks in 0.00s
  [backtrack] Found solution with 1680 backtracks in 0.00s
  [backtrack] Found solution with 1023 backtracks in 0.00s
  [backtrack] Found solution with 846 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (7277 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (5461 backtracks in 0.01s)
  DFS: latency violated (1 nodes, worst_gap=83.5s)
  Boundary nodes: [0, 1, 2, 4, 5, 7, 9, 11] → expanding 8 children
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 1, 4] → J=210, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 1, 4] → J=220, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 1, 5] → J=212, T=200, cost=2 → queued

[Iter 9] cost=1, J=217, T=200, edges=39, frontier=40, MILP_calls=49
  V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 1, 3]
  [backtrack] EXHAUSTED search space (351 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (333 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (229 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3142 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1891 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1629 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (865 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (799 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1771 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1234 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (331 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (485 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 4, 7, 9, 10, 11] → expanding 7 children
    V_MIN=[2, 2, 2, 2, 4, 2, 3, 2, 2, 2, 1, 3] → J=205, T=199, cost=2 → queued

[Iter 10] cost=2, J=229, T=199, edges=40, frontier=40, MILP_calls=50
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 3]
  [backtrack] EXHAUSTED search space (559 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (513 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (475 backtracks in 0.00s)
  [backtrack] Found solution with 873 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (5359 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (4159 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2954 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3765 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (378 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (4463 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (510 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (430 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=176.1s)
  Boundary nodes: [0, 1, 2, 4, 5, 7, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 3] → J=217, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 3, 1, 3] → J=217, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 3, 3, 2, 3, 1, 3] → J=224, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 3, 2, 3, 1, 3] → J=213, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 3, 2, 3, 1, 3] → J=223, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 4, 2, 3, 1, 3] → J=224, T=199, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 4, 1, 3] → J=225, T=198, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 3, 2, 3] → J=226, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 4] → J=217, T=200, cost=3 → queued

[Iter 11] cost=2, J=228, T=200, edges=40, frontier=48, MILP_calls=59
  V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 1, 3]
  [backtrack] EXHAUSTED search space (20789 backtracks in 0.05s)
  [backtrack] EXHAUSTED search space (9754 backtracks in 0.02s)
  [backtrack] EXHAUSTED search space (17335 backtracks in 0.04s)
  [backtrack] EXHAUSTED search space (7884 backtracks in 0.02s)
  [backtrack] Found solution with 563 backtracks in 0.00s
  [backtrack] Found solution with 616 backtracks in 0.00s
  [backtrack] Found solution with 696 backtracks in 0.00s
  [backtrack] Found solution with 7217 backtracks in 0.02s
  [backtrack] Found solution with 327 backtracks in 0.00s
  [backtrack] Found solution with 2784 backtracks in 0.01s
  [backtrack] EXHAUSTED search space (10036 backtracks in 0.02s)
  [backtrack] EXHAUSTED search space (8732 backtracks in 0.02s)
  DFS: latency violated (2 nodes, worst_gap=177.1s)
  Boundary nodes: [0, 1, 2, 4, 5, 7, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 2, 2, 2, 2, 3, 3, 2, 2, 3, 1, 3] → J=216, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 2, 2, 3, 1, 3] → J=216, T=198, cost=3 → queued
    V_MIN=[2, 2, 3, 2, 2, 3, 3, 2, 2, 3, 1, 3] → J=223, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 3, 3, 3, 2, 2, 3, 1, 3] → J=216, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 4, 3, 2, 2, 3, 1, 3] → J=220, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 2, 4, 1, 3] → J=226, T=199, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 2, 3] → J=224, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 1, 4] → J=216, T=199, cost=3 → queued

[Iter 12] cost=2, J=228, T=198, edges=40, frontier=55, MILP_calls=67
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 4, 1, 3]
  [backtrack] EXHAUSTED search space (665 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (725 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (773 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (5083 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2941 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3404 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (5320 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2409 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1991 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3486 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (734 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (451 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 7, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 2, 4, 1, 3] → J=220, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 4, 1, 3] → J=220, T=200, cost=3 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 3, 2, 2, 4, 1, 3] → J=227, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 4, 1, 3] → J=215, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 5, 1, 3] → J=226, T=197, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 4, 2, 3] → J=225, T=199, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 4, 1, 4] → J=218, T=198, cost=3 → queued

[Iter 13] cost=2, J=227, T=200, edges=40, frontier=61, MILP_calls=74
  V_MIN=[2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 1, 3]
  [backtrack] EXHAUSTED search space (967 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (885 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (767 backtracks in 0.00s)
  [backtrack] Found solution with 3636 backtracks in 0.01s
  [backtrack] EXHAUSTED search space (8028 backtracks in 0.02s)
  [backtrack] EXHAUSTED search space (6459 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2080 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (5707 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (663 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (8443 backtracks in 0.02s)
  [backtrack] EXHAUSTED search space (3175 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1327 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=154.6s)
  Boundary nodes: [0, 1, 2, 4, 5, 7, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 1, 3] → J=218, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 2, 2, 3, 1, 3] → J=218, T=200, cost=3 → queued
    V_MIN=[2, 2, 4, 2, 2, 2, 3, 2, 2, 3, 1, 3] → J=220, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 3, 2, 2, 3, 1, 3] → J=213, T=199, cost=3 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 2, 3] → J=224, T=200, cost=3 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 1, 4] → J=217, T=199, cost=3 → queued

[Iter 14] cost=2, J=226, T=200, edges=40, frontier=66, MILP_calls=80
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 3]
  [backtrack] EXHAUSTED search space (391 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (362 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (342 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3227 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1960 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1773 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1673 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2236 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2330 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1270 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (351 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (226 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 3] → J=219, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 3] → J=219, T=200, cost=3 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 3, 3, 2, 2, 2, 3] → J=224, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 3, 2, 2, 2, 3] → J=213, T=198, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 3, 2, 2, 2, 3] → J=223, T=199, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3] → J=222, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 4] → J=218, T=200, cost=3 → queued

[Iter 15] cost=2, J=226, T=200, edges=40, frontier=72, MILP_calls=87
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 3]
  [backtrack] EXHAUSTED search space (1935 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1802 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1639 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (24013 backtracks in 0.05s)
  [backtrack] EXHAUSTED search space (17844 backtracks in 0.04s)
  [backtrack] EXHAUSTED search space (20758 backtracks in 0.05s)
  [backtrack] EXHAUSTED search space (27110 backtracks in 0.06s)
  [backtrack] EXHAUSTED search space (21059 backtracks in 0.05s)
  [backtrack] EXHAUSTED search space (18172 backtracks in 0.04s)
  [backtrack] EXHAUSTED search space (20141 backtracks in 0.04s)
  [backtrack] EXHAUSTED search space (1468 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1187 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 4, 5, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 3] → J=218, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 2, 3, 2, 3] → J=218, T=198, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 3] → J=215, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 3, 3] → J=222, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 4] → J=218, T=198, cost=3 → queued

[Iter 16] cost=2, J=225, T=200, edges=40, frontier=76, MILP_calls=92
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3, 3]
  [backtrack] Found solution with 79 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.7s
  *** SOLUTION FOUND! J=225, T_tour=199.7s ***

============================================================
Search done: 16 iters, 92 MILP calls, 92 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -1, 0, -1, -2, 0, 1, 2, -8, 4, 2, 1, -2, -2, -3, -2, 0, 2, 0, 0, -3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -1, 0, -1, -2, 0, 1, 2, -8, 4, 2, 1, -2, -2, -3, -2, 0, 2, 0, 0, -3]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-1)), ((1, 5), np.int64(-1)), ((2, 3), np.int64(-2)), ((2, 11), np.int64(1)), ((3, 4), np.int64(2)), ((3, 6), np.int64(-8)), ((3, 8), np.int64(4)), ((4, 5), np.int64(2)), ((5, 6), np.int64(1)), ((6, 7), np.int64(-2)), ((6, 9), np.int64(-2)), ((6, 10), np.int64(-3)), ((7, 8), np.int64(-2)), ((8, 9), np.int64(2)), ((10, 11), np.int64(-3))]

Blocked edge 1: idx=7, edge=(2, 11), flow_B=1  →  need Cm[7]=-1
Blocked edge 2: idx=15, edge=(6, 10), flow_B=-3  →  need Cm[15]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=21   ||Cm||_1=13

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -2, 1, -1, 1, 0, 0, 1, -1, 0, 0]

Cm = C_oriented @ beta*:
  [0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 1, 0, 0, -1, -2, 3, 0, -1, 1, 0, -1, 1]

Original flow_B:
  [-2, 2, -1, 0, -1, -2, 0, 1, 2, -8, 4, 2, 1, -2, -2, -3, -2, 0, 2, 0, 0, -3]

flow_B + Cm (corrected flow):
  [-2, 2, -1, 0, -1, -1, 0, 0, 2, -8, 5, 2, 1, -3, -4, 0, -2, -1, 3, 0, -1, -2]

Verification:
  flow_corrected[7] = 0  (should be 0, Cm=-1, d=-1)
  flow_corrected[15] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 21  (minimized by MIQP)
  ||Cm||_1  = 13
  ||flow_B||_2² = 138
  ||flow_corrected||_2² = 153

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    5.2          
    1     (0, 11)         2       0           2    4.1          
    2      (1, 2)        -1       0          -1    6.7          
    3      (1, 3)         0       0           0    7.6          
    4      (1, 5)        -1       0          -1    6.1          
    5      (2, 3)        -2       1          -1    6.2     -6.2s
    6      (2, 8)         0       0           0    6.7          
    7     (2, 11)         1      -1           0    6.5     -6.5s ← BLOCKED
    8      (3, 4)         2       0           2    5.4          
    9      (3, 6)        -8       0          -8    4.1          
   10      (3, 8)         4       1           5    4.7     +4.7s
   11      (4, 5)         2       0           2    7.5          
   12      (5, 6)         1       0           1    4.3          
   13      (6, 7)        -2      -1          -3    5.5     +5.5s
   14      (6, 9)        -2      -2          -4    4.5     +9.0s
   15     (6, 10)        -3       3           0    4.4    -13.2s ← BLOCKED
   16      (7, 8)        -2       0          -2    4.3          
   17     (7, 10)         0      -1          -1    4.3     +4.3s
   18      (8, 9)         2       1           3    4.1     +4.1s
   19     (8, 11)         0       0           0    7.1          
   20     (9, 10)         0      -1          -1    4.2     +4.2s
   21    (10, 11)        -3       1          -2    5.9     -5.9s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=2, out=2  OK
  Node 2: in=1, out=1  OK
  Node 3: in=8, out=8  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=8, out=8  OK
  Node 7: in=3, out=3  OK
  Node 8: in=5, out=5  OK
  Node 9: in=4, out=4  OK
  Node 10: in=2, out=2  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 41 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 26

  Summary:
    Original path length:  40 edges
    Spliced path length:   41 edges
    Splices performed:     26
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)          -1        -1  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           2         2  ✓
    9      (3, 6)          -8        -8  ✓
   10      (3, 8)           5         5  ✓
   11      (4, 5)           2         2  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)          -3        -3  ✓
   14      (6, 9)          -4        -4  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)          -2        -2  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)           3         3  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)          -1        -1  ✓
   21    (10, 11)          -2        -2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 67
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 1, 3, 2] → J=244, T=199, cost=0 → queued

[Iter 1] cost=0, J=244, T=199, edges=38, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 1, 3, 2]
  [backtrack] Found solution with 1005 backtracks in 0.00s
  [backtrack] Found solution with 130 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (870 backtracks in 0.00s)
  [backtrack] Found solution with 338 backtracks in 0.00s
  [backtrack] Found solution with 39 backtracks in 0.00s
  [backtrack] Found solution with 92 backtracks in 0.00s
  [backtrack] Found solution with 268 backtracks in 0.00s
  [backtrack] Found solution with 735 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (481 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (628 backtracks in 0.00s)
  [backtrack] Found solution with 701 backtracks in 0.00s
  [backtrack] Found solution with 68 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=126.1s)
  Boundary nodes: [4, 5, 6, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 3, 2, 1, 3, 2] → J=236, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 3, 2, 1, 3, 2] → J=243, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 1, 3, 2] → J=240, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 4, 2, 1, 3, 2] → J=240, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 3, 1, 3, 2] → J=241, T=199, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2] → J=239, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 1, 4, 2] → J=242, T=200, cost=1 → queued

[Iter 2] cost=1, J=243, T=200, edges=38, frontier=6, MILP_calls=8
  V_MIN=[2, 3, 2, 2, 2, 3, 2, 3, 2, 1, 3, 2]
  [backtrack] Found solution with 292 backtracks in 0.00s
  [backtrack] Found solution with 232 backtracks in 0.00s
  [backtrack] Found solution with 99 backtracks in 0.00s
  [backtrack] Found solution with 87 backtracks in 0.00s
  [backtrack] Found solution with 62 backtracks in 0.00s
  [backtrack] Found solution with 34 backtracks in 0.00s
  [backtrack] Found solution with 1241 backtracks in 0.00s
  [backtrack] Found solution with 1389 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1138 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1264 backtracks in 0.00s)
  [backtrack] Found solution with 1517 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1832 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=93.7s)
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 3, 2, 3, 2, 1, 3, 2] → J=240, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 2, 3, 2, 1, 3, 2] → J=236, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 2, 3, 2, 1, 3, 2] → J=240, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 2, 1, 3, 2] → J=240, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 4, 2, 1, 3, 2] → J=236, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 3, 3, 1, 3, 2] → J=240, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2] → J=233, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 3, 2, 1, 4, 2] → J=239, T=199, cost=2 → queued

[Iter 3] cost=1, J=242, T=200, edges=38, frontier=13, MILP_calls=16
  V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 1, 4, 2]
  [backtrack] Found solution with 1232 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1881 backtracks in 0.00s)
  [backtrack] Found solution with 2157 backtracks in 0.01s
  [backtrack] Found solution with 1928 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (4219 backtracks in 0.01s)
  [backtrack] Found solution with 531 backtracks in 0.00s
  [backtrack] Found solution with 1313 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (648 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1008 backtracks in 0.00s)
  [backtrack] Found solution with 1127 backtracks in 0.00s
  [backtrack] Found solution with 1571 backtracks in 0.00s
  [backtrack] Found solution with 1399 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=109.7s)
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 2, 3, 2, 1, 4, 2] → J=242, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 3, 2, 1, 4, 2] → J=232, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 1, 4, 2] → J=239, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 4, 2, 1, 4, 2] → J=240, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 3, 1, 4, 2] → J=240, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 4, 2] → J=234, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 2, 1, 5, 2] → J=237, T=199, cost=2 → queued

[Iter 4] cost=1, J=241, T=199, edges=38, frontier=19, MILP_calls=23
  V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 3, 1, 3, 2]
  [backtrack] Found solution with 397 backtracks in 0.00s
  [backtrack] Found solution with 319 backtracks in 0.00s
  [backtrack] Found solution with 18 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 826 backtracks in 0.00s
  [backtrack] Found solution with 81 backtracks in 0.00s
  [backtrack] Found solution with 924 backtracks in 0.00s
  [backtrack] Found solution with 715 backtracks in 0.00s
  [backtrack] Found solution with 111 backtracks in 0.00s
  [backtrack] Found solution with 1031 backtracks in 0.00s
  [backtrack] Found solution with 668 backtracks in 0.00s
  [backtrack] Found solution with 621 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=156.1s)
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 2, 3, 3, 1, 3, 2] → J=241, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 3, 3, 1, 3, 2] → J=232, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 3, 1, 3, 2] → J=240, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 4, 3, 1, 3, 2] → J=240, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 4, 1, 3, 2] → J=240, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 3, 2, 3, 2] → J=239, T=200, cost=2 → queued

[Iter 5] cost=1, J=240, T=200, edges=38, frontier=24, MILP_calls=29
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 1, 3, 2]
  [backtrack] EXHAUSTED search space (407 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (724 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (218 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (354 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (451 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (451 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (73 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (117 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (283 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (114 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (110 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (72 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 2, 1, 3, 2] → J=240, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 2, 1, 3, 2] → J=232, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 2, 1, 3, 2] → J=236, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 2, 1, 3, 2] → J=238, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 3, 2] → J=236, T=200, cost=2 → queued

[Iter 6] cost=1, J=240, T=200, edges=37, frontier=28, MILP_calls=34
  V_MIN=[2, 3, 2, 2, 2, 2, 2, 4, 2, 1, 3, 2]
  [backtrack] Found solution with 662 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.9s
  *** SOLUTION FOUND! J=240, T_tour=199.9s ***

============================================================
Search done: 6 iters, 34 MILP calls, 34 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 4, -1, -1, 3, 3, -2, 2, 0, 0, 2, 1, 2, -1, 0, -2, 4, 1, 0, 0, 4]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 4, -1, -1, 3, 3, -2, 2, 0, 0, 2, 1, 2, -1, 0, -2, 4, 1, 0, 0, 4]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(4)), ((1, 3), np.int64(-1)), ((1, 5), np.int64(-1)), ((2, 3), np.int64(3)), ((2, 8), np.int64(3)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(2)), ((4, 5), np.int64(2)), ((5, 6), np.int64(1)), ((6, 7), np.int64(2)), ((6, 9), np.int64(-1)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(4)), ((8, 9), np.int64(1)), ((10, 11), np.int64(4))]

Blocked edge 1: idx=5, edge=(2, 3), flow_B=3  →  need Cm[5]=-3
Blocked edge 2: idx=21, edge=(10, 11), flow_B=4  →  need Cm[21]=-4
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=51   ||Cm||_1=23

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 4, -3, -1, -4, -1, -1, -4, 4, 1, -3]

Cm = C_oriented @ beta*:
  [-1, 1, 0, 0, -1, -3, 1, 2, 0, -2, -1, 0, -1, 0, 0, -3, 0, 0, -1, 1, -1, -4]

Original flow_B:
  [2, -2, 4, -1, -1, 3, 3, -2, 2, 0, 0, 2, 1, 2, -1, 0, -2, 4, 1, 0, 0, 4]

flow_B + Cm (corrected flow):
  [1, -1, 4, -1, -2, 0, 4, 0, 2, -2, -1, 2, 0, 2, -1, -3, -2, 4, 0, 1, -1, 0]

Verification:
  flow_corrected[5] = 0  (should be 0, Cm=-3, d=-3)
  flow_corrected[21] = 0  (should be 0, Cm=-4, d=-4)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 51  (minimized by MIQP)
  ||Cm||_1  = 23
  ||flow_B||_2² = 99
  ||flow_corrected||_2² = 88

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2      -1           1    5.0     -5.0s
    1     (0, 11)        -2       1          -1    5.3     -5.3s
    2      (1, 2)         4       0           4    4.8          
    3      (1, 3)        -1       0          -1    5.4          
    4      (1, 5)        -1      -1          -2    5.0     +5.0s
    5      (2, 3)         3      -3           0    4.0    -12.0s ← BLOCKED
    6      (2, 8)         3       1           4    5.6     +5.6s
    7     (2, 11)        -2       2           0    5.6    -11.2s
    8      (3, 4)         2       0           2    4.2          
    9      (3, 6)         0      -2          -2    7.8    +15.6s
   10      (3, 8)         0      -1          -1    5.6     +5.6s
   11      (4, 5)         2       0           2    6.1          
   12      (5, 6)         1      -1           0    4.9     -4.9s
   13      (6, 7)         2       0           2    5.2          
   14      (6, 9)        -1       0          -1    6.2          
   15     (6, 10)         0      -3          -3    6.8    +20.4s
   16      (7, 8)        -2       0          -2    7.8          
   17     (7, 10)         4       0           4    6.4          
   18      (8, 9)         1      -1           0    5.6     -5.6s
   19     (8, 11)         0       1           1    5.4     +5.4s
   20     (9, 10)         0      -1          -1    7.3     +7.3s
   21    (10, 11)         4      -4           0    5.2    -20.8s ← BLOCKED

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=1, out=1  OK
  Node 1: in=4, out=4  OK
  Node 2: in=4, out=4  OK
  Node 3: in=3, out=3  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=4, out=4  OK
  Node 7: in=4, out=4  OK
  Node 8: in=4, out=4  OK
  Node 9: in=1, out=1  OK
  Node 10: in=4, out=4  OK
  Node 11: in=1, out=1  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 24

  Summary:
    Original path length:  37 edges
    Spliced path length:   34 edges
    Splices performed:     24
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           1         1  ✓
    1     (0, 11)          -1        -1  ✓
    2      (1, 2)           4         4  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)          -2        -2  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           4         4  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           2         2  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           2         2  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)           2         2  ✓
   14      (6, 9)          -1        -1  ✓
   15     (6, 10)          -3        -3  ✓
   16      (7, 8)          -2        -2  ✓
   17     (7, 10)           4         4  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)           1         1  ✓
   20     (9, 10)          -1        -1  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 68
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 3, 3, 3] → J=212, T=200, cost=0 → queued

[Iter 1] cost=0, J=212, T=200, edges=34, frontier=0, MILP_calls=1
  V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (586 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (407 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (345 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (235 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (369 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (306 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (193 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (185 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (539 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (225 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (211 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 9, 10] → expanding 7 children
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 2, 2, 3, 3, 3] → J=196, T=198, cost=1 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 3, 2, 2, 3, 3, 3] → J=209, T=199, cost=1 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 3, 2, 2, 3, 3, 3] → J=205, T=200, cost=1 → queued
    V_MIN=[2, 1, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3] → J=210, T=199, cost=1 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 3, 2, 3, 3, 3] → J=212, T=200, cost=1 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 4, 3, 3] → J=209, T=199, cost=1 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 3, 4, 3] → J=211, T=198, cost=1 → queued

[Iter 2] cost=1, J=212, T=200, edges=35, frontier=6, MILP_calls=8
  V_MIN=[2, 1, 2, 2, 2, 2, 3, 3, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (133 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (171 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (203 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (196 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (211 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (216 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (81 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (231 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (174 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (205 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (247 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (128 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 9, 10] → expanding 7 children
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 3, 2, 3, 3, 3] → J=195, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 3, 3, 2, 3, 3, 3] → J=205, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 3, 3, 2, 3, 3, 3] → J=205, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 3, 3, 3, 2, 3, 3, 3] → J=208, T=199, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 4, 2, 3, 3, 3] → J=206, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 3, 2, 4, 3, 3] → J=209, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 3, 2, 3, 4, 3] → J=210, T=198, cost=2 → queued

[Iter 3] cost=1, J=211, T=198, edges=34, frontier=12, MILP_calls=15
  V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 3, 4, 3]
  [backtrack] Found solution with 122 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 190 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (293 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (592 backtracks in 0.00s)
  [backtrack] Found solution with 428 backtracks in 0.00s
  [backtrack] Found solution with 159 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (486 backtracks in 0.00s)
  [backtrack] Found solution with 225 backtracks in 0.00s
  [backtrack] Found solution with 240 backtracks in 0.00s
  [backtrack] Found solution with 73 backtracks in 0.00s
  [backtrack] Found solution with 189 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=101.8s)
  Boundary nodes: [0, 3, 4, 5, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 2, 2, 3, 4, 3] → J=196, T=198, cost=2 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 3, 2, 2, 3, 4, 3] → J=209, T=199, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 3, 2, 2, 3, 4, 3] → J=197, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 3, 3, 2, 2, 3, 4, 3] → J=210, T=199, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 4, 2, 2, 3, 4, 3] → J=210, T=199, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 4, 4, 3] → J=209, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 3, 5, 3] → J=209, T=199, cost=2 → queued

[Iter 4] cost=1, J=210, T=199, edges=34, frontier=18, MILP_calls=22
  V_MIN=[2, 1, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3]
  [backtrack] Found solution with 105 backtracks in 0.00s
  [backtrack] Found solution with 20 backtracks in 0.00s
  [backtrack] Found solution with 269 backtracks in 0.00s
  [backtrack] Found solution with 255 backtracks in 0.00s
  [backtrack] Found solution with 232 backtracks in 0.00s
  [backtrack] Found solution with 213 backtracks in 0.00s
  [backtrack] Found solution with 263 backtracks in 0.00s
  [backtrack] Found solution with 514 backtracks in 0.00s
  [backtrack] Found solution with 446 backtracks in 0.00s
  [backtrack] Found solution with 496 backtracks in 0.00s
  [backtrack] Found solution with 47 backtracks in 0.00s
  [backtrack] Found solution with 141 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=98.5s)
  Boundary nodes: [0, 3, 4, 5, 7, 9] → expanding 6 children
    V_MIN=[3, 1, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3] → J=193, T=199, cost=2 → queued
    V_MIN=[2, 1, 2, 3, 2, 3, 3, 2, 2, 3, 3, 3] → J=205, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 3, 3, 3, 2, 2, 3, 3, 3] → J=205, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 4, 3, 2, 2, 3, 3, 3] → J=208, T=199, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 3, 3, 2, 2, 4, 3, 3] → J=206, T=199, cost=2 → queued

[Iter 5] cost=1, J=209, T=199, edges=33, frontier=22, MILP_calls=27
  V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 4, 3, 3]
  [backtrack] EXHAUSTED search space (202 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (163 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (207 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (564 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (555 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (546 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (263 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (444 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (149 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (659 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (680 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 2, 2, 4, 3, 3] → J=191, T=199, cost=2 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 3, 2, 2, 4, 3, 3] → J=205, T=199, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 3, 2, 2, 4, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 3, 4, 3, 3] → J=208, T=197, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 5, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 4, 3, 4] → J=209, T=197, cost=2 → queued

[Iter 6] cost=1, J=209, T=199, edges=34, frontier=25, MILP_calls=33
  V_MIN=[2, 1, 2, 3, 2, 2, 3, 2, 2, 3, 3, 3]
  [backtrack] Found solution with 322 backtracks in 0.00s
  [backtrack] Found solution with 281 backtracks in 0.00s
  [backtrack] Found solution with 341 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1444 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (989 backtracks in 0.00s)
  [backtrack] Found solution with 265 backtracks in 0.00s
  [backtrack] Found solution with 13 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1157 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (605 backtracks in 0.00s)
  [backtrack] Found solution with 863 backtracks in 0.00s
  [backtrack] Found solution with 719 backtracks in 0.00s
  [backtrack] Found solution with 383 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=92.3s)
  Boundary nodes: [0, 3, 4, 5, 7, 9] → expanding 6 children
    V_MIN=[3, 1, 2, 3, 2, 2, 3, 2, 2, 3, 3, 3] → J=191, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 4, 2, 2, 3, 2, 2, 3, 3, 3] → J=204, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 3, 3, 2, 3, 2, 2, 3, 3, 3] → J=205, T=200, cost=2 → queued

[Iter 7] cost=1, J=205, T=200, edges=35, frontier=27, MILP_calls=36
  V_MIN=[2, 1, 2, 2, 3, 2, 3, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (207 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (202 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (133 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (182 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (246 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (208 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (81 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (211 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (46 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (91 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (218 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 8, 9, 10, 11] → expanding 6 children
    V_MIN=[3, 1, 2, 2, 3, 2, 3, 2, 2, 3, 3, 3] → J=185, T=199, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 4, 2, 3, 2, 2, 3, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 2, 2, 3, 2, 3, 2, 3, 3, 3, 3] → J=204, T=200, cost=2 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 3, 2, 2, 3, 3, 4] → J=203, T=199, cost=2 → queued

[Iter 8] cost=1, J=196, T=198, edges=33, frontier=29, MILP_calls=40
  V_MIN=[3, 1, 2, 2, 2, 2, 3, 2, 2, 3, 3, 3]
  [backtrack] Found solution with 143 backtracks in 0.00s
  [backtrack] Found solution with 121 backtracks in 0.00s
  [backtrack] Found solution with 118 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (300 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (240 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (184 backtracks in 0.00s)
  [backtrack] Found solution with 14 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (237 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (241 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (162 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (179 backtracks in 0.00s)
  [backtrack] Found solution with 168 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=107.6s)
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[4, 1, 2, 2, 2, 2, 3, 2, 2, 3, 3, 3] → MILP infeasible, pruned
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 2, 3, 3, 3, 3] → J=195, T=199, cost=2 → queued
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 2, 2, 3, 3, 4] → J=196, T=200, cost=2 → queued

[Iter 9] cost=2, J=210, T=199, edges=34, frontier=30, MILP_calls=43
  V_MIN=[2, 1, 2, 2, 2, 3, 3, 2, 2, 3, 4, 3]
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 441 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1084 backtracks in 0.00s)
  [backtrack] Found solution with 116 backtracks in 0.00s
  [backtrack] Found solution with 134 backtracks in 0.00s
  [backtrack] Found solution with 205 backtracks in 0.00s
  [backtrack] Found solution with 384 backtracks in 0.00s
  [backtrack] Found solution with 131 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=98.5s)
  Boundary nodes: [0, 3, 4, 5, 7, 9, 10] → expanding 7 children
    V_MIN=[3, 1, 2, 2, 2, 3, 3, 2, 2, 3, 4, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 2, 3, 2, 3, 3, 2, 2, 3, 4, 3] → J=199, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 3, 3, 3, 2, 2, 3, 4, 3] → J=197, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 4, 3, 2, 2, 3, 4, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 2, 2, 2, 3, 3, 3, 2, 3, 4, 3] → J=205, T=196, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 3, 3, 2, 2, 4, 4, 3] → J=206, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 3, 3, 2, 2, 3, 5, 3] → J=206, T=199, cost=3 → queued

[Iter 10] cost=2, J=210, T=199, edges=34, frontier=34, MILP_calls=50
  V_MIN=[2, 1, 2, 2, 2, 2, 4, 2, 2, 3, 4, 3]
  [backtrack] Found solution with 105 backtracks in 0.00s
  [backtrack] Found solution with 20 backtracks in 0.00s
  [backtrack] Found solution with 269 backtracks in 0.00s
  [backtrack] Found solution with 255 backtracks in 0.00s
  [backtrack] Found solution with 232 backtracks in 0.00s
  [backtrack] Found solution with 213 backtracks in 0.00s
  [backtrack] Found solution with 263 backtracks in 0.00s
  [backtrack] Found solution with 514 backtracks in 0.00s
  [backtrack] Found solution with 446 backtracks in 0.00s
  [backtrack] Found solution with 496 backtracks in 0.00s
  [backtrack] Found solution with 47 backtracks in 0.00s
  [backtrack] Found solution with 141 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=98.5s)
  Boundary nodes: [0, 3, 4, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[3, 1, 2, 2, 2, 2, 4, 2, 2, 3, 4, 3] → J=196, T=198, cost=3 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 4, 2, 2, 3, 4, 3] → J=209, T=199, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 4, 2, 2, 3, 4, 3] → J=197, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 5, 2, 2, 3, 4, 3] → J=210, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 4, 3, 2, 3, 4, 3] → J=210, T=198, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 4, 2, 2, 4, 4, 3] → J=209, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 4, 2, 2, 3, 5, 3] → J=209, T=199, cost=3 → queued

[Iter 11] cost=2, J=210, T=198, edges=34, frontier=40, MILP_calls=57
  V_MIN=[2, 1, 2, 2, 2, 2, 3, 3, 2, 3, 4, 3]
  [backtrack] EXHAUSTED search space (1013 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (845 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (374 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1305 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (944 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (897 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (718 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1604 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (819 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (960 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1230 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (460 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 3, 2, 3, 4, 3] → J=192, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 3, 3, 2, 3, 4, 3] → J=204, T=199, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 3, 3, 2, 3, 4, 3] → J=191, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 4, 2, 3, 4, 3] → J=206, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 3] → J=209, T=198, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 3, 2, 4, 4, 3] → J=209, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 3, 2, 3, 5, 3] → J=206, T=200, cost=3 → queued

[Iter 12] cost=2, J=209, T=199, edges=33, frontier=46, MILP_calls=64
  V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 3, 5, 3]
  [backtrack] Found solution with 277 backtracks in 0.00s
  [backtrack] Found solution with 150 backtracks in 0.00s
  [backtrack] Found solution with 143 backtracks in 0.00s
  [backtrack] Found solution with 173 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (547 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (680 backtracks in 0.00s)
  [backtrack] Found solution with 11 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (690 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (647 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (518 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (456 backtracks in 0.00s)
  [backtrack] Found solution with 376 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=82.9s)
  Boundary nodes: [0, 2, 3, 4, 5, 7, 9, 10] → expanding 8 children
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 2, 2, 3, 5, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 3, 2, 2, 2, 3, 2, 2, 3, 5, 3] → J=208, T=199, cost=3 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 3, 2, 2, 3, 5, 3] → J=204, T=199, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 3, 2, 2, 3, 5, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 4, 5, 3] → J=203, T=197, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 3, 6, 3] → MILP infeasible, pruned

[Iter 13] cost=2, J=209, T=200, edges=33, frontier=48, MILP_calls=70
  V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 4, 4, 3]
  [backtrack] EXHAUSTED search space (221 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (221 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (133 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (232 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (512 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (437 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (486 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (430 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (296 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (690 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (409 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (309 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 1, 2, 2, 2, 2, 3, 2, 2, 4, 4, 3] → J=191, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 3, 2, 2, 3, 2, 2, 4, 4, 3] → J=205, T=200, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 3, 2, 3, 2, 2, 4, 4, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 3, 4, 4, 3] → J=208, T=197, cost=3 → queued
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 5, 4, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 4, 4, 4] → J=209, T=197, cost=3 → queued

[Iter 14] cost=2, J=209, T=197, edges=33, frontier=51, MILP_calls=76
  V_MIN=[2, 1, 2, 2, 2, 2, 3, 2, 2, 4, 3, 4]
  [backtrack] Found solution with 174 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=197.3s
  *** SOLUTION FOUND! J=209, T_tour=197.3s ***

============================================================
Search done: 14 iters, 76 MILP calls, 76 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -2, 0, 0, 0, 1, -3, 2, -2, 0, 2, 2, -2, 2, 0, 0, -2, 2, -1, 4, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -2, 0, 0, 0, 1, -3, 2, -2, 0, 2, 2, -2, 2, 0, 0, -2, 2, -1, 4, 2]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-2)), ((2, 8), np.int64(1)), ((2, 11), np.int64(-3)), ((3, 4), np.int64(2)), ((3, 6), np.int64(-2)), ((4, 5), np.int64(2)), ((5, 6), np.int64(2)), ((6, 7), np.int64(-2)), ((6, 9), np.int64(2)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(2)), ((8, 11), np.int64(-1)), ((9, 10), np.int64(4)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=19, edge=(8, 11), flow_B=-1  →  need Cm[19]=1
Blocked edge 2: idx=11, edge=(4, 5), flow_B=2  →  need Cm[11]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=20   ||Cm||_1=16

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, 0, 1, -1, 0, -1, 0, -1, 0, -1, -1]

Cm = C_oriented @ beta*:
  [0, 0, 0, -1, 1, 0, 1, -1, -2, 0, 1, -2, -1, -1, -1, 1, -1, 0, 0, 1, -1, 0]

Original flow_B:
  [-2, 2, -2, 0, 0, 0, 1, -3, 2, -2, 0, 2, 2, -2, 2, 0, 0, -2, 2, -1, 4, 2]

flow_B + Cm (corrected flow):
  [-2, 2, -2, -1, 1, 0, 2, -4, 0, -2, 1, 0, 1, -3, 1, 1, -1, -2, 2, 0, 3, 2]

Verification:
  flow_corrected[19] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[11] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 20  (minimized by MIQP)
  ||Cm||_1  = 16
  ||flow_B||_2² = 75
  ||flow_corrected||_2² = 73

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    7.9          
    1     (0, 11)         2       0           2    6.1          
    2      (1, 2)        -2       0          -2    6.0          
    3      (1, 3)         0      -1          -1    7.8     +7.8s
    4      (1, 5)         0       1           1    7.1     +7.1s
    5      (2, 3)         0       0           0    6.4          
    6      (2, 8)         1       1           2    4.7     +4.7s
    7     (2, 11)        -3      -1          -4    4.7     +4.7s
    8      (3, 4)         2      -2           0    4.1     -8.2s
    9      (3, 6)        -2       0          -2    4.9          
   10      (3, 8)         0       1           1    6.1     +6.1s
   11      (4, 5)         2      -2           0    6.8    -13.6s ← BLOCKED
   12      (5, 6)         2      -1           1    5.2     -5.2s
   13      (6, 7)        -2      -1          -3    4.4     +4.4s
   14      (6, 9)         2      -1           1    7.9     -7.9s
   15     (6, 10)         0       1           1    7.1     +7.1s
   16      (7, 8)         0      -1          -1    6.2     +6.2s
   17     (7, 10)        -2       0          -2    4.6          
   18      (8, 9)         2       0           2    7.0          
   19     (8, 11)        -1       1           0    6.1     -6.1s ← BLOCKED
   20     (9, 10)         4      -1           3    7.2     -7.2s
   21    (10, 11)         2       0           2    6.9          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=3, out=3  OK
  Node 2: in=4, out=4  OK
  Node 3: in=2, out=2  OK
  Node 5: in=1, out=1  OK
  Node 6: in=4, out=4  OK
  Node 7: in=3, out=3  OK
  Node 8: in=3, out=3  OK
  Node 9: in=3, out=3  OK
  Node 10: in=4, out=4  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 33 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 14

  Summary:
    Original path length:  33 edges
    Spliced path length:   33 edges
    Splices performed:     14
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)          -2        -2  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           2         2  ✓
    7     (2, 11)          -4        -4  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)           1         1  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)          -3        -3  ✓
   14      (6, 9)           1         1  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           2         2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           3         3  ✓
   21    (10, 11)           2         2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 69
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 1, 2, 3, 3, 3] → J=228, T=200, cost=0 → queued

[Iter 1] cost=0, J=228, T=200, edges=36, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 2, 3, 2, 2, 2, 1, 2, 3, 3, 3]
  [backtrack] Found solution with 121 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (258 backtracks in 0.00s)
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (295 backtracks in 0.00s)
  [backtrack] Found solution with 48 backtracks in 0.00s
  [backtrack] Found solution with 7 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (227 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (100 backtracks in 0.00s)
  [backtrack] Found solution with 96 backtracks in 0.00s
  [backtrack] Found solution with 96 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=130.6s)
  Boundary nodes: [2, 4, 5, 6, 7, 8, 9] → expanding 7 children
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 1, 2, 3, 3, 3] → J=227, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 3, 2, 2, 1, 2, 3, 3, 3] → J=221, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 2, 1, 2, 3, 3, 3] → J=223, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 1, 2, 3, 3, 3] → J=227, T=199, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 3, 3, 3] → J=221, T=199, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 1, 3, 3, 3, 3] → J=228, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 1, 2, 4, 3, 3] → J=222, T=199, cost=1 → queued

[Iter 2] cost=1, J=228, T=200, edges=35, frontier=6, MILP_calls=8
  V_MIN=[2, 3, 2, 3, 2, 2, 2, 1, 3, 3, 3, 3]
  [backtrack] Found solution with 2 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.7s
  *** SOLUTION FOUND! J=228, T_tour=199.7s ***

============================================================
Search done: 2 iters, 8 MILP calls, 8 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 1, -5, 2, -1, 1, 1, -2, -1, -3, -2, 0, 0, -2, 1, 1, -1, -1, 0, -3, -3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 1, -5, 2, -1, 1, 1, -2, -1, -3, -2, 0, 0, -2, 1, 1, -1, -1, 0, -3, -3]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(1)), ((1, 3), np.int64(-5)), ((1, 5), np.int64(2)), ((2, 3), np.int64(-1)), ((2, 8), np.int64(1)), ((2, 11), np.int64(1)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(-1)), ((3, 8), np.int64(-3)), ((4, 5), np.int64(-2)), ((6, 9), np.int64(-2)), ((6, 10), np.int64(1)), ((7, 8), np.int64(1)), ((7, 10), np.int64(-1)), ((8, 9), np.int64(-1)), ((9, 10), np.int64(-3)), ((10, 11), np.int64(-3))]

Blocked edge 1: idx=16, edge=(7, 8), flow_B=1  →  need Cm[16]=-1
Blocked edge 2: idx=15, edge=(6, 10), flow_B=1  →  need Cm[15]=-1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=12   ||Cm||_1=12

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 1, -1, 0, -1, -1, -1, -1, 0, 1, 0]

Cm = C_oriented @ beta*:
  [-1, 1, 0, 0, -1, 0, 0, 0, 0, 1, -1, 0, -1, 0, 1, -1, -1, 1, -1, -1, 0, 0]

Original flow_B:
  [-2, 2, 1, -5, 2, -1, 1, 1, -2, -1, -3, -2, 0, 0, -2, 1, 1, -1, -1, 0, -3, -3]

flow_B + Cm (corrected flow):
  [-3, 3, 1, -5, 1, -1, 1, 1, -2, 0, -4, -2, -1, 0, -1, 0, 0, 0, -2, -1, -3, -3]

Verification:
  flow_corrected[16] = 0  (should be 0, Cm=-1, d=-1)
  flow_corrected[15] = 0  (should be 0, Cm=-1, d=-1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 12  (minimized by MIQP)
  ||Cm||_1  = 12
  ||flow_B||_2² = 85
  ||flow_corrected||_2² = 97

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2      -1          -3    4.3     +4.3s
    1     (0, 11)         2       1           3    5.3     +5.3s
    2      (1, 2)         1       0           1    7.0          
    3      (1, 3)        -5       0          -5    5.3          
    4      (1, 5)         2      -1           1    5.9     -5.9s
    5      (2, 3)        -1       0          -1    4.7          
    6      (2, 8)         1       0           1    5.3          
    7     (2, 11)         1       0           1    5.8          
    8      (3, 4)        -2       0          -2    6.1          
    9      (3, 6)        -1       1           0    5.2     -5.2s
   10      (3, 8)        -3      -1          -4    5.1     +5.1s
   11      (4, 5)        -2       0          -2    6.7          
   12      (5, 6)         0      -1          -1    4.9     +4.9s
   13      (6, 7)         0       0           0    6.7          
   14      (6, 9)        -2       1          -1    5.7     -5.7s
   15     (6, 10)         1      -1           0    5.6     -5.6s ← BLOCKED
   16      (7, 8)         1      -1           0    5.3     -5.3s ← BLOCKED
   17     (7, 10)        -1       1           0    6.1     -6.1s
   18      (8, 9)        -1      -1          -2    8.0     +8.0s
   19     (8, 11)         0      -1          -1    6.1     +6.1s
   20     (9, 10)        -3       0          -3    6.7          
   21    (10, 11)        -3       0          -3    5.6          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=5, out=5  OK
  Node 2: in=2, out=2  OK
  Node 3: in=6, out=6  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=1, out=1  OK
  Node 8: in=4, out=4  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 7

  Summary:
    Original path length:  35 edges
    Spliced path length:   35 edges
    Splices performed:     7
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -3        -3  ✓
    1     (0, 11)           3         3  ✓
    2      (1, 2)           1         1  ✓
    3      (1, 3)          -5        -5  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)           1         1  ✓
    7     (2, 11)           1         1  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)          -4        -4  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)          -1        -1  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)          -3        -3  ✓
   21    (10, 11)          -3        -3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 70
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 2, 2, 2, 2] → J=239, T=199, cost=0 → queued

[Iter 1] cost=0, J=239, T=199, edges=37, frontier=0, MILP_calls=1
  V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 2, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 6, 8, 9, 10] → expanding 7 children
    V_MIN=[4, 3, 2, 3, 2, 1, 3, 2, 2, 2, 2, 2] → J=232, T=199, cost=1 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 3, 2, 2, 2, 2, 2] → J=237, T=199, cost=1 → queued
    V_MIN=[3, 3, 2, 3, 3, 1, 3, 2, 2, 2, 2, 2] → J=226, T=200, cost=1 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 4, 2, 2, 2, 2, 2] → J=238, T=200, cost=1 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 3, 2, 2, 2] → J=230, T=198, cost=1 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 2, 3, 2, 2] → J=224, T=200, cost=1 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 2, 2, 3, 2] → J=231, T=199, cost=1 → queued

[Iter 2] cost=1, J=238, T=200, edges=37, frontier=6, MILP_calls=8
  V_MIN=[3, 3, 2, 3, 2, 1, 4, 2, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (478 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (147 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (552 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (452 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (380 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (257 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (145 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (310 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (197 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (171 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (95 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 6, 8, 9, 10] → expanding 7 children
    V_MIN=[4, 3, 2, 3, 2, 1, 4, 2, 2, 2, 2, 2] → J=226, T=200, cost=2 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 4, 2, 2, 2, 2, 2] → J=237, T=199, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 3, 1, 4, 2, 2, 2, 2, 2] → J=225, T=200, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 5, 2, 2, 2, 2, 2] → J=233, T=199, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 4, 2, 3, 2, 2, 2] → J=229, T=199, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 4, 2, 2, 3, 2, 2] → J=224, T=199, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 4, 2, 2, 2, 3, 2] → J=231, T=199, cost=2 → queued

[Iter 3] cost=1, J=237, T=199, edges=36, frontier=12, MILP_calls=15
  V_MIN=[3, 3, 2, 4, 2, 1, 3, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 362 backtracks in 0.00s
  [backtrack] Found solution with 142 backtracks in 0.00s
  [backtrack] Found solution with 84 backtracks in 0.00s
  [backtrack] Found solution with 149 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (412 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (393 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (234 backtracks in 0.00s)
  [backtrack] Found solution with 276 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (360 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (383 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (328 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (189 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=105.2s)
  Boundary nodes: [0, 3, 4, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[4, 3, 2, 4, 2, 1, 3, 2, 2, 2, 2, 2] → J=226, T=200, cost=2 → queued
    V_MIN=[3, 3, 2, 5, 2, 1, 3, 2, 2, 2, 2, 2] → J=229, T=199, cost=2 → queued
    V_MIN=[3, 3, 2, 4, 3, 1, 3, 2, 2, 2, 2, 2] → J=219, T=200, cost=2 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 3, 3, 2, 2, 2, 2] → J=233, T=198, cost=2 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 3, 2, 3, 2, 2, 2] → J=227, T=198, cost=2 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 3, 2, 2, 3, 2, 2] → J=224, T=199, cost=2 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 3, 2, 2, 2, 3, 2] → J=224, T=199, cost=2 → queued

[Iter 4] cost=1, J=232, T=199, edges=36, frontier=18, MILP_calls=22
  V_MIN=[4, 3, 2, 3, 2, 1, 3, 2, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (490 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (237 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (535 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (191 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (426 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (306 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (136 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (319 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (355 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (283 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (140 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[5, 3, 2, 3, 2, 1, 3, 2, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[4, 3, 2, 3, 3, 1, 3, 2, 2, 2, 2, 2] → J=217, T=199, cost=2 → queued
    V_MIN=[4, 3, 2, 3, 2, 1, 3, 3, 2, 2, 2, 2] → J=227, T=200, cost=2 → queued
    V_MIN=[4, 3, 2, 3, 2, 1, 3, 2, 3, 2, 2, 2] → J=227, T=200, cost=2 → queued
    V_MIN=[4, 3, 2, 3, 2, 1, 3, 2, 2, 3, 2, 2] → J=218, T=199, cost=2 → queued
    V_MIN=[4, 3, 2, 3, 2, 1, 3, 2, 2, 2, 3, 2] → J=221, T=200, cost=2 → queued

[Iter 5] cost=1, J=231, T=199, edges=36, frontier=22, MILP_calls=28
  V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (327 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (133 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (396 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (357 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (310 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (296 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (278 backtracks in 0.00s)
  [backtrack] Found solution with 109 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (338 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (361 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (419 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (179 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=110.0s)
  Boundary nodes: [0, 3, 4, 8, 9, 10] → expanding 6 children
    V_MIN=[3, 3, 2, 3, 3, 1, 3, 2, 2, 2, 3, 2] → J=220, T=199, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 3, 2, 3, 2] → J=222, T=199, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 2, 3, 3, 2] → J=220, T=199, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 2, 2, 4, 2] → J=221, T=200, cost=2 → queued

[Iter 6] cost=1, J=230, T=198, edges=36, frontier=25, MILP_calls=32
  V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (479 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (185 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (579 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (463 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (412 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (279 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (167 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (131 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (295 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (275 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (240 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (167 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 6, 8, 9, 10] → expanding 7 children
    V_MIN=[3, 3, 2, 3, 3, 1, 3, 2, 3, 2, 2, 2] → J=219, T=200, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 4, 2, 2, 2] → J=225, T=200, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 3, 3, 2, 2] → J=224, T=200, cost=2 → queued

[Iter 7] cost=1, J=226, T=200, edges=36, frontier=27, MILP_calls=35
  V_MIN=[3, 3, 2, 3, 3, 1, 3, 2, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (104 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (117 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (51 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (145 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (76 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (30 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (64 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (65 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (66 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (29 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (105 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[3, 3, 2, 3, 4, 1, 3, 2, 2, 2, 2, 2] → J=204, T=200, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 3, 1, 3, 3, 2, 2, 2, 2] → J=222, T=200, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 3, 1, 3, 2, 2, 3, 2, 2] → J=215, T=200, cost=2 → queued

[Iter 8] cost=1, J=224, T=200, edges=35, frontier=29, MILP_calls=38
  V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 2, 3, 2, 2]
  [backtrack] EXHAUSTED search space (734 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1008 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (523 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (311 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (618 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (525 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (338 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (304 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (348 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (211 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (271 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (585 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[3, 3, 2, 3, 2, 1, 3, 3, 2, 3, 2, 2] → J=223, T=198, cost=2 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 3, 2, 2, 4, 2, 2] → J=218, T=200, cost=2 → queued

[Iter 9] cost=2, J=237, T=199, edges=36, frontier=30, MILP_calls=40
  V_MIN=[3, 3, 2, 4, 2, 1, 4, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 91 backtracks in 0.00s
  [backtrack] Found solution with 23 backtracks in 0.00s
  [backtrack] Found solution with 24 backtracks in 0.00s
  [backtrack] Found solution with 81 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (246 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (387 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (219 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (271 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (359 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (344 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (303 backtracks in 0.00s)
  [backtrack] Found solution with 195 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=109.4s)
  Boundary nodes: [0, 3, 4, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[4, 3, 2, 4, 2, 1, 4, 2, 2, 2, 2, 2] → J=222, T=198, cost=3 → queued
    V_MIN=[3, 3, 2, 5, 2, 1, 4, 2, 2, 2, 2, 2] → J=225, T=197, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 3, 1, 4, 2, 2, 2, 2, 2] → J=218, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 5, 2, 2, 2, 2, 2] → J=227, T=198, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 4, 3, 2, 2, 2, 2] → J=232, T=198, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 4, 2, 3, 2, 2, 2] → J=227, T=198, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 4, 2, 2, 3, 2, 2] → J=223, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 4, 2, 2, 2, 3, 2] → J=222, T=200, cost=3 → queued

[Iter 10] cost=2, J=233, T=198, edges=36, frontier=37, MILP_calls=48
  V_MIN=[3, 3, 2, 4, 2, 1, 3, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 497 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 107 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 285 backtracks in 0.00s
  [backtrack] Found solution with 271 backtracks in 0.00s
  [backtrack] Found solution with 120 backtracks in 0.00s
  [backtrack] Found solution with 113 backtracks in 0.00s
  [backtrack] Found solution with 114 backtracks in 0.00s
  [backtrack] Found solution with 264 backtracks in 0.00s
  [backtrack] Found solution with 314 backtracks in 0.00s
  [backtrack] Found solution with 99 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=103.8s)
  Boundary nodes: [0, 3, 4, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[4, 3, 2, 4, 2, 1, 3, 3, 2, 2, 2, 2] → J=218, T=197, cost=3 → queued
    V_MIN=[3, 3, 2, 5, 2, 1, 3, 3, 2, 2, 2, 2] → J=225, T=199, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 3, 1, 3, 3, 2, 2, 2, 2] → J=218, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 3, 4, 2, 2, 2, 2] → J=232, T=198, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 3, 3, 3, 2, 2, 2] → J=226, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 3, 3, 2, 3, 2, 2] → J=223, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 3, 3, 2, 2, 3, 2] → J=222, T=198, cost=3 → queued

[Iter 11] cost=2, J=233, T=199, edges=36, frontier=43, MILP_calls=55
  V_MIN=[3, 3, 2, 3, 2, 1, 5, 2, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (690 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (884 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (485 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (298 backtracks in 0.00s)
  [backtrack] Found solution with 401 backtracks in 0.00s
  [backtrack] Found solution with 528 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (337 backtracks in 0.00s)
  [backtrack] Found solution with 137 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (419 backtracks in 0.00s)
  [backtrack] Found solution with 374 backtracks in 0.00s
  [backtrack] Found solution with 424 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (536 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=100.1s)
  Boundary nodes: [0, 3, 4, 6, 8, 9, 10] → expanding 7 children
    V_MIN=[4, 3, 2, 3, 2, 1, 5, 2, 2, 2, 2, 2] → J=222, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 3, 1, 5, 2, 2, 2, 2, 2] → J=219, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 6, 2, 2, 2, 2, 2] → J=226, T=199, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 5, 2, 3, 2, 2, 2] → J=228, T=199, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 5, 2, 2, 3, 2, 2] → J=223, T=199, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 5, 2, 2, 2, 3, 2] → J=231, T=199, cost=3 → queued

[Iter 12] cost=2, J=231, T=199, edges=36, frontier=48, MILP_calls=61
  V_MIN=[3, 3, 2, 3, 2, 1, 4, 2, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (327 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (133 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (396 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (357 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (310 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (296 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (278 backtracks in 0.00s)
  [backtrack] Found solution with 109 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (338 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (361 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (419 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (179 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=110.0s)
  Boundary nodes: [0, 3, 4, 8, 9, 10] → expanding 6 children
    V_MIN=[4, 3, 2, 3, 2, 1, 4, 2, 2, 2, 3, 2] → J=217, T=198, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 3, 1, 4, 2, 2, 2, 3, 2] → J=217, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 4, 2, 3, 2, 3, 2] → J=222, T=199, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 4, 2, 2, 3, 3, 2] → J=217, T=199, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 4, 2, 2, 2, 4, 2] → J=221, T=200, cost=3 → queued

[Iter 13] cost=2, J=229, T=199, edges=36, frontier=52, MILP_calls=66
  V_MIN=[3, 3, 2, 3, 2, 1, 4, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 901 backtracks in 0.00s
  [backtrack] Found solution with 799 backtracks in 0.00s
  [backtrack] Found solution with 1047 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (737 backtracks in 0.00s)
  [backtrack] Found solution with 629 backtracks in 0.00s
  [backtrack] Found solution with 858 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1036 backtracks in 0.00s)
  [backtrack] Found solution with 1358 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (792 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1383 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1192 backtracks in 0.00s)
  [backtrack] Found solution with 170 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=100.1s)
  Boundary nodes: [0, 3, 4, 6, 8, 9, 10] → expanding 7 children
    V_MIN=[4, 3, 2, 3, 2, 1, 4, 2, 3, 2, 2, 2] → J=225, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 3, 1, 4, 2, 3, 2, 2, 2] → J=219, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 4, 2, 4, 2, 2, 2] → J=221, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 1, 4, 2, 3, 3, 2, 2] → J=223, T=199, cost=3 → queued

[Iter 14] cost=2, J=229, T=199, edges=35, frontier=55, MILP_calls=70
  V_MIN=[3, 3, 2, 5, 2, 1, 3, 2, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (242 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (253 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (221 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (111 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (212 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (114 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (172 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (172 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (217 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (153 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[4, 3, 2, 5, 2, 1, 3, 2, 2, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 3, 2, 6, 2, 1, 3, 2, 2, 2, 2, 2] → J=216, T=198, cost=3 → queued
    V_MIN=[3, 3, 2, 5, 3, 1, 3, 2, 2, 2, 2, 2] → J=216, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 5, 2, 1, 3, 2, 3, 2, 2, 2] → J=221, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 5, 2, 1, 3, 2, 2, 3, 2, 2] → J=212, T=198, cost=3 → queued
    V_MIN=[3, 3, 2, 5, 2, 1, 3, 2, 2, 2, 3, 2] → J=216, T=197, cost=3 → queued

[Iter 15] cost=2, J=227, T=198, edges=35, frontier=59, MILP_calls=76
  V_MIN=[3, 3, 2, 4, 2, 1, 3, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 94 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 84 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (194 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (146 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (191 backtracks in 0.00s)
  [backtrack] Found solution with 104 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (223 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (184 backtracks in 0.00s)
  [backtrack] Found solution with 99 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=107.9s)
  Boundary nodes: [0, 3, 4, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[4, 3, 2, 4, 2, 1, 3, 2, 3, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[3, 3, 2, 4, 3, 1, 3, 2, 3, 2, 2, 2] → J=212, T=199, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 3, 2, 4, 2, 2, 2] → J=224, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 3, 2, 3, 3, 2, 2] → J=224, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 4, 2, 1, 3, 2, 3, 2, 3, 2] → J=215, T=200, cost=3 → queued

[Iter 16] cost=2, J=227, T=200, edges=36, frontier=62, MILP_calls=81
  V_MIN=[4, 3, 2, 3, 2, 1, 3, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.5s
  *** SOLUTION FOUND! J=227, T_tour=199.5s ***

============================================================
Search done: 16 iters, 81 MILP calls, 81 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-4, 4, -4, 0, 0, -3, 0, -1, -2, -1, 0, -2, -2, -3, 0, 0, -1, -2, 2, -3, 2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-4, 4, -4, 0, 0, -3, 0, -1, -2, -1, 0, -2, -2, -3, 0, 0, -1, -2, 2, -3, 2, 0]
  Non-zero edges: [((0, 1), np.int64(-4)), ((0, 11), np.int64(4)), ((1, 2), np.int64(-4)), ((2, 3), np.int64(-3)), ((2, 11), np.int64(-1)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(-1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(-3)), ((7, 8), np.int64(-1)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(2)), ((8, 11), np.int64(-3)), ((9, 10), np.int64(2))]

Blocked edge 1: idx=13, edge=(6, 7), flow_B=-3  →  need Cm[13]=3
Blocked edge 2: idx=2, edge=(1, 2), flow_B=-4  →  need Cm[2]=4
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=58   ||Cm||_1=28

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [3, 1, 0, 0, -2, 0, 1, 2, 0, 1, 1]

Cm = C_oriented @ beta*:
  [1, -1, 4, -2, -1, 1, 2, 1, 1, 1, -3, 1, 0, 3, -1, -1, 2, 1, 1, 0, 0, 0]

Original flow_B:
  [-4, 4, -4, 0, 0, -3, 0, -1, -2, -1, 0, -2, -2, -3, 0, 0, -1, -2, 2, -3, 2, 0]

flow_B + Cm (corrected flow):
  [-3, 3, 0, -2, -1, -2, 2, 0, -1, 0, -3, -1, -2, 0, -1, -1, 1, -1, 3, -3, 2, 0]

Verification:
  flow_corrected[13] = 0  (should be 0, Cm=3, d=3)
  flow_corrected[2] = 0  (should be 0, Cm=4, d=4)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 58  (minimized by MIQP)
  ||Cm||_1  = 28
  ||flow_B||_2² = 102
  ||flow_corrected||_2² = 72

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -4       1          -3    6.4     -6.4s
    1     (0, 11)         4      -1           3    5.2     -5.2s
    2      (1, 2)        -4       4           0    4.2    -16.8s ← BLOCKED
    3      (1, 3)         0      -2          -2    6.8    +13.6s
    4      (1, 5)         0      -1          -1    4.7     +4.7s
    5      (2, 3)        -3       1          -2    4.8     -4.8s
    6      (2, 8)         0       2           2    6.9    +13.8s
    7     (2, 11)        -1       1           0    4.5     -4.5s
    8      (3, 4)        -2       1          -1    5.2     -5.2s
    9      (3, 6)        -1       1           0    7.7     -7.7s
   10      (3, 8)         0      -3          -3    7.9    +23.7s
   11      (4, 5)        -2       1          -1    7.9     -7.9s
   12      (5, 6)        -2       0          -2    4.5          
   13      (6, 7)        -3       3           0    4.0    -12.0s ← BLOCKED
   14      (6, 9)         0      -1          -1    7.2     +7.2s
   15     (6, 10)         0      -1          -1    6.7     +6.7s
   16      (7, 8)        -1       2           1    5.4          
   17     (7, 10)        -2       1          -1    5.4     -5.4s
   18      (8, 9)         2       1           3    6.0     +6.0s
   19     (8, 11)        -3       0          -3    6.1          
   20     (9, 10)         2       0           2    8.0          
   21    (10, 11)         0       0           0    7.8          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=3, out=3  OK
  Node 2: in=2, out=2  OK
  Node 3: in=4, out=4  OK
  Node 4: in=1, out=1  OK
  Node 5: in=2, out=2  OK
  Node 6: in=2, out=2  OK
  Node 7: in=1, out=1  OK
  Node 8: in=6, out=6  OK
  Node 9: in=3, out=3  OK
  Node 10: in=2, out=2  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 32 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 17

  Summary:
    Original path length:  36 edges
    Spliced path length:   32 edges
    Splices performed:     17
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -3        -3  ✓
    1     (0, 11)           3         3  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)          -2        -2  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)           2         2  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -1        -1  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)          -3        -3  ✓
   11      (4, 5)          -1        -1  ✓
   12      (5, 6)          -2        -2  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)          -1        -1  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)           3         3  ✓
   19     (8, 11)          -3        -3  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 71
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[1, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2] → J=264, T=200, cost=0 → queued

[Iter 1] cost=0, J=264, T=200, edges=38, frontier=0, MILP_calls=1
  V_MIN=[1, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2]
  [backtrack] Found solution with 6 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.5s
  *** SOLUTION FOUND! J=264, T_tour=199.5s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [1, -1, -2, 0, 3, 0, 1, -3, -3, 3, 0, -3, 0, 1, 2, 0, 3, -2, -2, 6, 0, -2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [1, -1, -2, 0, 3, 0, 1, -3, -3, 3, 0, -3, 0, 1, 2, 0, 3, -2, -2, 6, 0, -2]
  Non-zero edges: [((0, 1), np.int64(1)), ((0, 11), np.int64(-1)), ((1, 2), np.int64(-2)), ((1, 5), np.int64(3)), ((2, 8), np.int64(1)), ((2, 11), np.int64(-3)), ((3, 4), np.int64(-3)), ((3, 6), np.int64(3)), ((4, 5), np.int64(-3)), ((6, 7), np.int64(1)), ((6, 9), np.int64(2)), ((7, 8), np.int64(3)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(-2)), ((8, 11), np.int64(6)), ((10, 11), np.int64(-2))]

Blocked edge 1: idx=1, edge=(0, 11), flow_B=-1  →  need Cm[1]=1
Blocked edge 2: idx=11, edge=(4, 5), flow_B=-3  →  need Cm[11]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=32   ||Cm||_1=18

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, -1, 0, 0, 0, 2, -1, 1, 0, 1, 1]

Cm = C_oriented @ beta*:
  [-1, 1, 0, 0, -1, 1, 0, -1, 3, -1, -1, 3, 2, 0, 0, 1, 1, -1, 0, 0, 0, 0]

Original flow_B:
  [1, -1, -2, 0, 3, 0, 1, -3, -3, 3, 0, -3, 0, 1, 2, 0, 3, -2, -2, 6, 0, -2]

flow_B + Cm (corrected flow):
  [0, 0, -2, 0, 2, 1, 1, -4, 0, 2, -1, 0, 2, 1, 2, 1, 4, -3, -2, 6, 0, -2]

Verification:
  flow_corrected[1] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[11] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 32  (minimized by MIQP)
  ||Cm||_1  = 18
  ||flow_B||_2² = 114
  ||flow_corrected||_2² = 110

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         1      -1           0    4.4     -4.4s
    1     (0, 11)        -1       1           0    6.4     -6.4s ← BLOCKED
    2      (1, 2)        -2       0          -2    4.5          
    3      (1, 3)         0       0           0    7.6          
    4      (1, 5)         3      -1           2    5.0     -5.0s
    5      (2, 3)         0       1           1    7.8     +7.8s
    6      (2, 8)         1       0           1    7.2          
    7     (2, 11)        -3      -1          -4    5.7     +5.7s
    8      (3, 4)        -3       3           0    5.0    -15.0s
    9      (3, 6)         3      -1           2    5.5     -5.5s
   10      (3, 8)         0      -1          -1    6.3     +6.3s
   11      (4, 5)        -3       3           0    5.2    -15.6s ← BLOCKED
   12      (5, 6)         0       2           2    7.4    +14.8s
   13      (6, 7)         1       0           1    7.7          
   14      (6, 9)         2       0           2    4.2          
   15     (6, 10)         0       1           1    5.3     +5.3s
   16      (7, 8)         3       1           4    5.4     +5.4s
   17     (7, 10)        -2      -1          -3    6.5     +6.5s
   18      (8, 9)        -2       0          -2    4.3          
   19     (8, 11)         6       0           6    4.9          
   20     (9, 10)         0       0           0    7.7          
   21    (10, 11)        -2       0          -2    5.0          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=2, out=2  OK
  Node 2: in=4, out=4  OK
  Node 3: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=4, out=4  OK
  Node 7: in=4, out=4  OK
  Node 8: in=7, out=7  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=6, out=6  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 19

  Summary:
    Original path length:  38 edges
    Spliced path length:   36 edges
    Splices performed:     19
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)          -2        -2  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           1         1  ✓
    6      (2, 8)           1         1  ✓
    7     (2, 11)          -4        -4  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)           2         2  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)           2         2  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)           4         4  ✓
   17     (7, 10)          -3        -3  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)           6         6  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)          -2        -2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 72
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 3] → J=210, T=200, cost=0 → queued

[Iter 1] cost=0, J=210, T=200, edges=36, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 3]
  [backtrack] EXHAUSTED search space (4689 backtracks in 0.01s)
  [backtrack] Found solution with 442 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (6251 backtracks in 0.01s)
  [backtrack] Found solution with 1330 backtracks in 0.00s
  [backtrack] Found solution with 4442 backtracks in 0.01s
  [backtrack] Found solution with 937 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 590 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (4481 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (4526 backtracks in 0.01s)
  DFS: latency violated (1 nodes, worst_gap=88.8s)
  Boundary nodes: [0, 4, 5, 7, 8, 9] → expanding 6 children
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 3] → J=208, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 1, 2, 2, 3] → J=206, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 2, 2, 1, 2, 2, 3] → J=209, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 3, 1, 2, 2, 3] → J=205, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3] → J=209, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 2, 3] → J=209, T=200, cost=1 → queued

[Iter 2] cost=1, J=209, T=200, edges=36, frontier=5, MILP_calls=7
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3]
  [backtrack] Found solution with 89 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=199.5s
  *** SOLUTION FOUND! J=209, T_tour=199.5s ***

============================================================
Search done: 2 iters, 7 MILP calls, 7 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -3, 0, 1, 0, 0, -3, -2, 2, 0, -2, -1, -2, -2, 5, -2, 0, 0, -2, -2, 3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -3, 0, 1, 0, 0, -3, -2, 2, 0, -2, -1, -2, -2, 5, -2, 0, 0, -2, -2, 3]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-3)), ((1, 5), np.int64(1)), ((2, 11), np.int64(-3)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(2)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-1)), ((6, 7), np.int64(-2)), ((6, 9), np.int64(-2)), ((6, 10), np.int64(5)), ((7, 8), np.int64(-2)), ((8, 11), np.int64(-2)), ((9, 10), np.int64(-2)), ((10, 11), np.int64(3))]

Blocked edge 1: idx=16, edge=(7, 8), flow_B=-2  →  need Cm[16]=2
Blocked edge 2: idx=9, edge=(3, 6), flow_B=2  →  need Cm[9]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=27   ||Cm||_1=19

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, 0, -1, 0, -1, 2, 0, 1, 1, -1, 0]

Cm = C_oriented @ beta*:
  [0, 0, -1, 0, 1, -2, 0, 1, 1, -2, -1, 1, 2, 1, -1, 0, 2, -1, 1, 0, 0, -1]

Original flow_B:
  [-2, 2, -3, 0, 1, 0, 0, -3, -2, 2, 0, -2, -1, -2, -2, 5, -2, 0, 0, -2, -2, 3]

flow_B + Cm (corrected flow):
  [-2, 2, -4, 0, 2, -2, 0, -2, -1, 0, -1, -1, 1, -1, -3, 5, 0, -1, 1, -2, -2, 2]

Verification:
  flow_corrected[16] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[9] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 27  (minimized by MIQP)
  ||Cm||_1  = 19
  ||flow_B||_2² = 94
  ||flow_corrected||_2² = 89

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    5.7          
    1     (0, 11)         2       0           2    5.0          
    2      (1, 2)        -3      -1          -4    5.6     +5.6s
    3      (1, 3)         0       0           0    6.5          
    4      (1, 5)         1       1           2    6.3     +6.3s
    5      (2, 3)         0      -2          -2    7.1    +14.2s
    6      (2, 8)         0       0           0    6.5          
    7     (2, 11)        -3       1          -2    6.5     -6.5s
    8      (3, 4)        -2       1          -1    5.5     -5.5s
    9      (3, 6)         2      -2           0    4.7     -9.4s ← BLOCKED
   10      (3, 8)         0      -1          -1    7.0     +7.0s
   11      (4, 5)        -2       1          -1    5.6     -5.6s
   12      (5, 6)        -1       2           1    6.6          
   13      (6, 7)        -2       1          -1    5.3     -5.3s
   14      (6, 9)        -2      -1          -3    4.3     +4.3s
   15     (6, 10)         5       0           5    4.2          
   16      (7, 8)        -2       2           0    5.8    -11.6s ← BLOCKED
   17     (7, 10)         0      -1          -1    6.8     +6.8s
   18      (8, 9)         0       1           1    7.2     +7.2s
   19     (8, 11)        -2       0          -2    4.9          
   20     (9, 10)        -2       0          -2    6.6          
   21    (10, 11)         3      -1           2    7.5     -7.5s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=4, out=4  OK
  Node 2: in=4, out=4  OK
  Node 3: in=2, out=2  OK
  Node 4: in=1, out=1  OK
  Node 5: in=2, out=2  OK
  Node 6: in=5, out=5  OK
  Node 7: in=1, out=1  OK
  Node 8: in=2, out=2  OK
  Node 9: in=3, out=3  OK
  Node 10: in=5, out=5  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 19

  Summary:
    Original path length:  36 edges
    Spliced path length:   35 edges
    Splices performed:     19
    Path is continuous:    True
    Returns to source 1: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)          -4        -4  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)          -2        -2  ✓
    8      (3, 4)          -1        -1  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)          -1        -1  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)          -3        -3  ✓
   15     (6, 10)           5         5  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)           1         1  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)          -2        -2  ✓
   21    (10, 11)           2         2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 73
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 1, 2, 2, 3, 2, 2, 2] → J=212, T=200, cost=0 → queued

[Iter 1] cost=0, J=212, T=200, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 1, 2, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 128 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.9s
  *** SOLUTION FOUND! J=212, T_tour=199.9s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -4, 0, 2, 0, 0, -4, -2, -3, 5, -2, 0, -2, 0, -1, -1, -1, 2, 2, 2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -4, 0, 2, 0, 0, -4, -2, -3, 5, -2, 0, -2, 0, -1, -1, -1, 2, 2, 2, 0]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-4)), ((1, 5), np.int64(2)), ((2, 11), np.int64(-4)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(-3)), ((3, 8), np.int64(5)), ((4, 5), np.int64(-2)), ((6, 7), np.int64(-2)), ((6, 10), np.int64(-1)), ((7, 8), np.int64(-1)), ((7, 10), np.int64(-1)), ((8, 9), np.int64(2)), ((8, 11), np.int64(2)), ((9, 10), np.int64(2))]

Blocked edge 1: idx=17, edge=(7, 10), flow_B=-1  →  need Cm[17]=1
Blocked edge 2: idx=18, edge=(8, 9), flow_B=2  →  need Cm[18]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=15   ||Cm||_1=11

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 2, 0, -2, 0, 0, 0, -2, 1, 0, 0]

Cm = C_oriented @ beta*:
  [0, 0, 1, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1, -2, 1, -2, -1]

Original flow_B:
  [-2, 2, -4, 0, 2, 0, 0, -4, -2, -3, 5, -2, 0, -2, 0, -1, -1, -1, 2, 2, 2, 0]

flow_B + Cm (corrected flow):
  [-2, 2, -3, -1, 2, 1, 0, -4, -2, -3, 5, -2, 0, -2, 0, -1, -2, 0, 0, 3, 0, -1]

Verification:
  flow_corrected[17] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[18] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 15  (minimized by MIQP)
  ||Cm||_1  = 11
  ||flow_B||_2² = 105
  ||flow_corrected||_2² = 100

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    5.0          
    1     (0, 11)         2       0           2    7.6          
    2      (1, 2)        -4       1          -3    4.6     -4.6s
    3      (1, 3)         0      -1          -1    6.4     +6.4s
    4      (1, 5)         2       0           2    5.0          
    5      (2, 3)         0       1           1    7.5     +7.5s
    6      (2, 8)         0       0           0    7.7          
    7     (2, 11)        -4       0          -4    4.4          
    8      (3, 4)        -2       0          -2    7.9          
    9      (3, 6)        -3       0          -3    4.2          
   10      (3, 8)         5       0           5    4.1          
   11      (4, 5)        -2       0          -2    6.1          
   12      (5, 6)         0       0           0    4.1          
   13      (6, 7)        -2       0          -2    5.3          
   14      (6, 9)         0       0           0    4.8          
   15     (6, 10)        -1       0          -1    5.1          
   16      (7, 8)        -1      -1          -2    7.9     +7.9s
   17     (7, 10)        -1       1           0    7.8     -7.8s ← BLOCKED
   18      (8, 9)         2      -2           0    7.3    -14.6s ← BLOCKED
   19     (8, 11)         2       1           3    6.6     +6.6s
   20     (9, 10)         2      -2           0    4.2     -8.4s
   21    (10, 11)         0      -1          -1    6.8     +6.8s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=4, out=4  OK
  Node 2: in=4, out=4  OK
  Node 3: in=6, out=6  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=3, out=3  OK
  Node 7: in=2, out=2  OK
  Node 8: in=5, out=5  OK
  Node 10: in=1, out=1  OK
  Node 11: in=5, out=5  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 11

  Summary:
    Original path length:  37 edges
    Spliced path length:   36 edges
    Splices performed:     11
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)          -3        -3  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           1         1  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)          -4        -4  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)          -3        -3  ✓
   10      (3, 8)           5         5  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)          -2        -2  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)          -2        -2  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)           3         3  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 74
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 3, 2, 2, 3, 2, 2, 2, 1, 3, 2] → J=273, T=199, cost=0 → queued

[Iter 1] cost=0, J=273, T=199, edges=40, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 3, 2, 2, 3, 2, 2, 2, 1, 3, 2]
  [backtrack] Found solution with 53 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.2s
  *** SOLUTION FOUND! J=273, T_tour=199.2s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -2, 1, -1, -3, 1, 0, -2, 0, 0, -2, -3, 2, 0, -5, -4, 6, -1, -2, -1, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -2, 1, -1, -3, 1, 0, -2, 0, 0, -2, -3, 2, 0, -5, -4, 6, -1, -2, -1, 0]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-2)), ((1, 3), np.int64(1)), ((1, 5), np.int64(-1)), ((2, 3), np.int64(-3)), ((2, 8), np.int64(1)), ((3, 4), np.int64(-2)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-3)), ((6, 7), np.int64(2)), ((6, 10), np.int64(-5)), ((7, 8), np.int64(-4)), ((7, 10), np.int64(6)), ((8, 9), np.int64(-1)), ((8, 11), np.int64(-2)), ((9, 10), np.int64(-1))]

Blocked edge 1: idx=18, edge=(8, 9), flow_B=-1  →  need Cm[18]=1
Blocked edge 2: idx=2, edge=(1, 2), flow_B=-2  →  need Cm[2]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=11   ||Cm||_1=9

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [2, 0, 0, 0, -1, -1, 0, 0, 0, 1, -1]

Cm = C_oriented @ beta*:
  [0, 0, 2, -1, -1, 1, 1, 0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 1, 0, 0, 0]

Original flow_B:
  [-2, 2, -2, 1, -1, -3, 1, 0, -2, 0, 0, -2, -3, 2, 0, -5, -4, 6, -1, -2, -1, 0]

flow_B + Cm (corrected flow):
  [-2, 2, 0, 0, -2, -2, 2, 0, -2, 0, 0, -2, -4, 2, -1, -5, -4, 6, 0, -2, -1, 0]

Verification:
  flow_corrected[18] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[2] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 11  (minimized by MIQP)
  ||Cm||_1  = 9
  ||flow_B||_2² = 128
  ||flow_corrected||_2² = 131

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    4.3          
    1     (0, 11)         2       0           2    4.6          
    2      (1, 2)        -2       2           0    5.3    -10.6s ← BLOCKED
    3      (1, 3)         1      -1           0    4.0     -4.0s
    4      (1, 5)        -1      -1          -2    6.9     +6.9s
    5      (2, 3)        -3       1          -2    4.3     -4.3s
    6      (2, 8)         1       1           2    5.7     +5.7s
    7     (2, 11)         0       0           0    7.2          
    8      (3, 4)        -2       0          -2    4.1          
    9      (3, 6)         0       0           0    6.1          
   10      (3, 8)         0       0           0    7.1          
   11      (4, 5)        -2       0          -2    7.2          
   12      (5, 6)        -3      -1          -4    5.4     +5.4s
   13      (6, 7)         2       0           2    5.6          
   14      (6, 9)         0      -1          -1    7.4     +7.4s
   15     (6, 10)        -5       0          -5    4.0          
   16      (7, 8)        -4       0          -4    4.7          
   17     (7, 10)         6       0           6    5.5          
   18      (8, 9)        -1       1           0    6.4     -6.4s ← BLOCKED
   19     (8, 11)        -2       0          -2    4.5          
   20     (9, 10)        -1       0          -1    4.1          
   21    (10, 11)         0       0           0    6.8          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=2, out=2  OK
  Node 2: in=2, out=2  OK
  Node 3: in=2, out=2  OK
  Node 4: in=2, out=2  OK
  Node 5: in=4, out=4  OK
  Node 6: in=6, out=6  OK
  Node 7: in=6, out=6  OK
  Node 8: in=4, out=4  OK
  Node 9: in=1, out=1  OK
  Node 10: in=6, out=6  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 39 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 18

  Summary:
    Original path length:  40 edges
    Spliced path length:   39 edges
    Splices performed:     18
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)          -2        -2  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)           2         2  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)          -4        -4  ✓
   13      (6, 7)           2         2  ✓
   14      (6, 9)          -1        -1  ✓
   15     (6, 10)          -5        -5  ✓
   16      (7, 8)          -4        -4  ✓
   17     (7, 10)           6         6  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)          -1        -1  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 75
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 1, 3, 3, 2, 2, 2, 2, 2, 3, 2, 2] → J=237, T=200, cost=0 → queued

[Iter 1] cost=0, J=237, T=200, edges=35, frontier=0, MILP_calls=1
  V_MIN=[2, 1, 3, 3, 2, 2, 2, 2, 2, 3, 2, 2]
  [backtrack] Found solution with 111 backtracks in 0.00s
  [backtrack] Found solution with 56 backtracks in 0.00s
  [backtrack] Found solution with 62 backtracks in 0.00s
  [backtrack] Found solution with 118 backtracks in 0.00s
  [backtrack] Found solution with 63 backtracks in 0.00s
  [backtrack] Found solution with 64 backtracks in 0.00s
  [backtrack] Found solution with 217 backtracks in 0.00s
  [backtrack] Found solution with 359 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (142 backtracks in 0.00s)
  [backtrack] Found solution with 530 backtracks in 0.00s
  [backtrack] Found solution with 452 backtracks in 0.00s
  [backtrack] Found solution with 141 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=127.7s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 11] → expanding 7 children
    V_MIN=[3, 1, 3, 3, 2, 2, 2, 2, 2, 3, 2, 2] → J=220, T=198, cost=1 → queued
    V_MIN=[2, 1, 3, 3, 3, 2, 2, 2, 2, 3, 2, 2] → J=228, T=200, cost=1 → queued
    V_MIN=[2, 1, 3, 3, 2, 3, 2, 2, 2, 3, 2, 2] → J=228, T=200, cost=1 → queued
    V_MIN=[2, 1, 3, 3, 2, 2, 3, 2, 2, 3, 2, 2] → J=235, T=200, cost=1 → queued
    V_MIN=[2, 1, 3, 3, 2, 2, 2, 3, 2, 3, 2, 2] → J=230, T=199, cost=1 → queued
    V_MIN=[2, 1, 3, 3, 2, 2, 2, 2, 2, 4, 2, 2] → J=230, T=200, cost=1 → queued
    V_MIN=[2, 1, 3, 3, 2, 2, 2, 2, 2, 3, 2, 3] → J=232, T=200, cost=1 → queued

[Iter 2] cost=1, J=235, T=200, edges=35, frontier=6, MILP_calls=8
  V_MIN=[2, 1, 3, 3, 2, 2, 3, 2, 2, 3, 2, 2]
  [backtrack] Found solution with 69 backtracks in 0.00s
  [backtrack] Found solution with 69 backtracks in 0.00s
  [backtrack] Found solution with 72 backtracks in 0.00s
  [backtrack] Found solution with 72 backtracks in 0.00s
  [backtrack] Found solution with 74 backtracks in 0.00s
  [backtrack] Found solution with 79 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (94 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] Found solution with 85 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=85.9s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 11] → expanding 7 children
    V_MIN=[3, 1, 3, 3, 2, 2, 3, 2, 2, 3, 2, 2] → J=216, T=198, cost=2 → queued
    V_MIN=[2, 1, 3, 3, 3, 2, 3, 2, 2, 3, 2, 2] → J=228, T=200, cost=2 → queued
    V_MIN=[2, 1, 3, 3, 2, 3, 3, 2, 2, 3, 2, 2] → J=228, T=200, cost=2 → queued
    V_MIN=[2, 1, 3, 3, 2, 2, 4, 2, 2, 3, 2, 2] → J=231, T=200, cost=2 → queued
    V_MIN=[2, 1, 3, 3, 2, 2, 3, 3, 2, 3, 2, 2] → J=228, T=199, cost=2 → queued
    V_MIN=[2, 1, 3, 3, 2, 2, 3, 2, 2, 4, 2, 2] → J=228, T=198, cost=2 → queued
    V_MIN=[2, 1, 3, 3, 2, 2, 3, 2, 2, 3, 2, 3] → J=231, T=197, cost=2 → queued

[Iter 3] cost=1, J=232, T=200, edges=34, frontier=12, MILP_calls=15
  V_MIN=[2, 1, 3, 3, 2, 2, 2, 2, 2, 3, 2, 3]
  [backtrack] Found solution with 451 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.6s
  *** SOLUTION FOUND! J=232, T_tour=199.6s ***

============================================================
Search done: 3 iters, 15 MILP calls, 15 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 0, -1, -1, 5, -2, -3, 2, 1, 1, 2, 1, 0, 2, 0, -2, 2, -3, 0, -1, 1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 0, -1, -1, 5, -2, -3, 2, 1, 1, 2, 1, 0, 2, 0, -2, 2, -3, 0, -1, 1]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 3), np.int64(-1)), ((1, 5), np.int64(-1)), ((2, 3), np.int64(5)), ((2, 8), np.int64(-2)), ((2, 11), np.int64(-3)), ((3, 4), np.int64(2)), ((3, 6), np.int64(1)), ((3, 8), np.int64(1)), ((4, 5), np.int64(2)), ((5, 6), np.int64(1)), ((6, 9), np.int64(2)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(2)), ((8, 9), np.int64(-3)), ((9, 10), np.int64(-1)), ((10, 11), np.int64(1))]

Blocked edge 1: idx=10, edge=(3, 8), flow_B=1  →  need Cm[10]=-1
Blocked edge 2: idx=7, edge=(2, 11), flow_B=-3  →  need Cm[7]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=24   ||Cm||_1=16

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 1, -3, -1, -2, 0, 0, -1, 1, 1, -1]

Cm = C_oriented @ beta*:
  [0, 0, 1, 0, -1, -1, -1, 3, 1, -1, -1, 1, 0, 0, -1, 0, 0, 0, 0, -2, -1, -1]

Original flow_B:
  [-2, 2, 0, -1, -1, 5, -2, -3, 2, 1, 1, 2, 1, 0, 2, 0, -2, 2, -3, 0, -1, 1]

flow_B + Cm (corrected flow):
  [-2, 2, 1, -1, -2, 4, -3, 0, 3, 0, 0, 3, 1, 0, 1, 0, -2, 2, -3, -2, -2, 0]

Verification:
  flow_corrected[10] = 0  (should be 0, Cm=-1, d=-1)
  flow_corrected[7] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 24  (minimized by MIQP)
  ||Cm||_1  = 16
  ||flow_B||_2² = 82
  ||flow_corrected||_2² = 84

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    7.7          
    1     (0, 11)         2       0           2    6.7          
    2      (1, 2)         0       1           1    4.9     +4.9s
    3      (1, 3)        -1       0          -1    5.0          
    4      (1, 5)        -1      -1          -2    4.9     +4.9s
    5      (2, 3)         5      -1           4    4.3     -4.3s
    6      (2, 8)        -2      -1          -3    4.7     +4.7s
    7     (2, 11)        -3       3           0    6.9    -20.7s ← BLOCKED
    8      (3, 4)         2       1           3    8.0     +8.0s
    9      (3, 6)         1      -1           0    4.6     -4.6s
   10      (3, 8)         1      -1           0    4.9     -4.9s ← BLOCKED
   11      (4, 5)         2       1           3    5.1     +5.1s
   12      (5, 6)         1       0           1    7.0          
   13      (6, 7)         0       0           0    7.9          
   14      (6, 9)         2      -1           1    7.1     -7.1s
   15     (6, 10)         0       0           0    6.8          
   16      (7, 8)        -2       0          -2    7.8          
   17     (7, 10)         2       0           2    4.3          
   18      (8, 9)        -3       0          -3    4.8          
   19     (8, 11)         0      -2          -2    6.7    +13.4s
   20     (9, 10)        -1      -1          -2    7.2     +7.2s
   21    (10, 11)         1      -1           0    6.6     -6.6s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=3, out=3  OK
  Node 2: in=4, out=4  OK
  Node 3: in=4, out=4  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=1, out=1  OK
  Node 7: in=2, out=2  OK
  Node 8: in=5, out=5  OK
  Node 9: in=3, out=3  OK
  Node 10: in=2, out=2  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 15

  Summary:
    Original path length:  34 edges
    Spliced path length:   34 edges
    Splices performed:     15
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)           1         1  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)          -2        -2  ✓
    5      (2, 3)           4         4  ✓
    6      (2, 8)          -3        -3  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           3         3  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           3         3  ✓
   12      (5, 6)           1         1  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           1         1  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)          -2        -2  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)          -3        -3  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)          -2        -2  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 76
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 2, 3, 2] → J=225, T=198, cost=0 → queued

[Iter 1] cost=0, J=225, T=198, edges=33, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 2, 3, 2]
  [backtrack] Found solution with 29 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.2s
  *** SOLUTION FOUND! J=225, T_tour=198.2s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, -2, 0, 4, -1, -1, 0, -2, 1, 0, -2, 2, 4, -1, 0, 0, 4, -1, 0, -2, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, -2, 0, 4, -1, -1, 0, -2, 1, 0, -2, 2, 4, -1, 0, 0, 4, -1, 0, -2, 2]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(-2)), ((1, 5), np.int64(4)), ((2, 3), np.int64(-1)), ((2, 8), np.int64(-1)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(2)), ((6, 7), np.int64(4)), ((6, 9), np.int64(-1)), ((7, 10), np.int64(4)), ((8, 9), np.int64(-1)), ((9, 10), np.int64(-2)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=4, edge=(1, 5), flow_B=4  →  need Cm[4]=-4
Blocked edge 2: idx=5, edge=(2, 3), flow_B=-1  →  need Cm[5]=1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=48   ||Cm||_1=22

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 0, -1, 0, 0, -3, -1, 0, 0, 4, -1]

Cm = C_oriented @ beta*:
  [-1, 1, 0, 3, -4, 1, -1, 0, 1, 2, 1, 1, -3, 0, -1, 0, 0, 0, 1, -1, 0, 0]

Original flow_B:
  [2, -2, -2, 0, 4, -1, -1, 0, -2, 1, 0, -2, 2, 4, -1, 0, 0, 4, -1, 0, -2, 2]

flow_B + Cm (corrected flow):
  [1, -1, -2, 3, 0, 0, -2, 0, -1, 3, 1, -1, -1, 4, -2, 0, 0, 4, 0, -1, -2, 2]

Verification:
  flow_corrected[4] = 0  (should be 0, Cm=-4, d=-4)
  flow_corrected[5] = 0  (should be 0, Cm=1, d=1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 48  (minimized by MIQP)
  ||Cm||_1  = 22
  ||flow_B||_2² = 85
  ||flow_corrected||_2² = 77

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2      -1           1    6.6     -6.6s
    1     (0, 11)        -2       1          -1    5.5     -5.5s
    2      (1, 2)        -2       0          -2    7.3          
    3      (1, 3)         0       3           3    7.7    +23.1s
    4      (1, 5)         4      -4           0    4.7    -18.8s ← BLOCKED
    5      (2, 3)        -1       1           0    7.3     -7.3s ← BLOCKED
    6      (2, 8)        -1      -1          -2    5.8     +5.8s
    7     (2, 11)         0       0           0    8.0          
    8      (3, 4)        -2       1          -1    7.0     -7.0s
    9      (3, 6)         1       2           3    6.3    +12.6s
   10      (3, 8)         0       1           1    7.1     +7.1s
   11      (4, 5)        -2       1          -1    6.0     -6.0s
   12      (5, 6)         2      -3          -1    7.6     -7.6s
   13      (6, 7)         4       0           4    6.7          
   14      (6, 9)        -1      -1          -2    7.5     +7.5s
   15     (6, 10)         0       0           0    7.3          
   16      (7, 8)         0       0           0    7.6          
   17     (7, 10)         4       0           4    5.8          
   18      (8, 9)        -1       1           0    5.1     -5.1s
   19     (8, 11)         0      -1          -1    7.6     +7.6s
   20     (9, 10)        -2       0          -2    4.4          
   21    (10, 11)         2       0           2    4.3          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=1, out=1  OK
  Node 1: in=3, out=3  OK
  Node 2: in=2, out=2  OK
  Node 3: in=4, out=4  OK
  Node 4: in=1, out=1  OK
  Node 5: in=1, out=1  OK
  Node 6: in=5, out=5  OK
  Node 7: in=4, out=4  OK
  Node 8: in=2, out=2  OK
  Node 9: in=2, out=2  OK
  Node 10: in=4, out=4  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 31 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 25

  Summary:
    Original path length:  33 edges
    Spliced path length:   31 edges
    Splices performed:     25
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           1         1  ✓
    1     (0, 11)          -1        -1  ✓
    2      (1, 2)          -2        -2  ✓
    3      (1, 3)           3         3  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)          -2        -2  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -1        -1  ✓
    9      (3, 6)           3         3  ✓
   10      (3, 8)           1         1  ✓
   11      (4, 5)          -1        -1  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)           4         4  ✓
   14      (6, 9)          -2        -2  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)           4         4  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)          -2        -2  ✓
   21    (10, 11)           2         2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 77
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 2, 2, 1, 3, 2, 2, 2, 2, 2, 2] → J=227, T=200, cost=0 → queued

[Iter 1] cost=0, J=227, T=200, edges=37, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 2, 2, 1, 3, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 301 backtracks in 0.00s
  [backtrack] Found solution with 33 backtracks in 0.00s
  [backtrack] Found solution with 166 backtracks in 0.00s
    ✓ Latency-feasible! source=2, T_tour=199.6s
  *** SOLUTION FOUND! J=227, T_tour=199.6s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, -5, -1, 3, 0, -3, -2, 1, -2, 0, 1, 4, 0, 2, 0, 2, -2, 0, -1, 2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, -5, -1, 3, 0, -3, -2, 1, -2, 0, 1, 4, 0, 2, 0, 2, -2, 0, -1, 2, 0]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 2), np.int64(-5)), ((1, 3), np.int64(-1)), ((1, 5), np.int64(3)), ((2, 8), np.int64(-3)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(1)), ((3, 6), np.int64(-2)), ((4, 5), np.int64(1)), ((5, 6), np.int64(4)), ((6, 9), np.int64(2)), ((7, 8), np.int64(2)), ((7, 10), np.int64(-2)), ((8, 11), np.int64(-1)), ((9, 10), np.int64(2))]

Blocked edge 1: idx=20, edge=(9, 10), flow_B=2  →  need Cm[20]=-2
Blocked edge 2: idx=1, edge=(0, 11), flow_B=3  →  need Cm[1]=-3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=49   ||Cm||_1=27

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-3, 1, 1, -2, 2, 2, 3, 0, 1, -2, 1]

Cm = C_oriented @ beta*:
  [3, -3, 0, 1, 2, -1, -1, 2, 0, -1, 1, 0, 2, 1, -1, 1, 1, 0, -1, 2, -2, -1]

Original flow_B:
  [-3, 3, -5, -1, 3, 0, -3, -2, 1, -2, 0, 1, 4, 0, 2, 0, 2, -2, 0, -1, 2, 0]

flow_B + Cm (corrected flow):
  [0, 0, -5, 0, 5, -1, -4, 0, 1, -3, 1, 1, 6, 1, 1, 1, 3, -2, -1, 1, 0, -1]

Verification:
  flow_corrected[20] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[1] = 0  (should be 0, Cm=-3, d=-3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 49  (minimized by MIQP)
  ||Cm||_1  = 27
  ||flow_B||_2² = 105
  ||flow_corrected||_2² = 134

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       3           0    7.3    -21.9s
    1     (0, 11)         3      -3           0    6.4    -19.2s ← BLOCKED
    2      (1, 2)        -5       0          -5    5.2          
    3      (1, 3)        -1       1           0    5.1     -5.1s
    4      (1, 5)         3       2           5    6.8    +13.6s
    5      (2, 3)         0      -1          -1    5.7     +5.7s
    6      (2, 8)        -3      -1          -4    4.2     +4.2s
    7     (2, 11)        -2       2           0    7.0    -14.0s
    8      (3, 4)         1       0           1    5.8          
    9      (3, 6)        -2      -1          -3    4.7     +4.7s
   10      (3, 8)         0       1           1    4.2     +4.2s
   11      (4, 5)         1       0           1    5.2          
   12      (5, 6)         4       2           6    4.3     +8.6s
   13      (6, 7)         0       1           1    7.0     +7.0s
   14      (6, 9)         2      -1           1    4.3     -4.3s
   15     (6, 10)         0       1           1    5.7     +5.7s
   16      (7, 8)         2       1           3    5.5     +5.5s
   17     (7, 10)        -2       0          -2    4.6          
   18      (8, 9)         0      -1          -1    6.2     +6.2s
   19     (8, 11)        -1       2           1    5.8          
   20     (9, 10)         2      -2           0    4.1     -8.2s ← BLOCKED
   21    (10, 11)         0      -1          -1    7.3     +7.3s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=5, out=5  OK
  Node 2: in=5, out=5  OK
  Node 3: in=3, out=3  OK
  Node 4: in=1, out=1  OK
  Node 5: in=6, out=6  OK
  Node 6: in=6, out=6  OK
  Node 7: in=3, out=3  OK
  Node 8: in=5, out=5  OK
  Node 9: in=1, out=1  OK
  Node 10: in=2, out=2  OK
  Node 11: in=1, out=1  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 38 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 21

  Summary:
    Original path length:  37 edges
    Spliced path length:   38 edges
    Splices performed:     21
    Path is continuous:    True
    Returns to source 2: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)          -5        -5  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           5         5  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)          -4        -4  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           1         1  ✓
    9      (3, 6)          -3        -3  ✓
   10      (3, 8)           1         1  ✓
   11      (4, 5)           1         1  ✓
   12      (5, 6)           6         6  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)           1         1  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)           3         3  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)          -1        -1  ✓
   19     (8, 11)           1         1  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 78
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[1, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 3] → J=250, T=198, cost=0 → queued

[Iter 1] cost=0, J=250, T=198, edges=36, frontier=0, MILP_calls=1
  V_MIN=[1, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 3]
  [backtrack] Found solution with 132 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (349 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (726 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (391 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1041 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1016 backtracks in 0.00s)
  [backtrack] Found solution with 209 backtracks in 0.00s
  [backtrack] Found solution with 45 backtracks in 0.00s
  [backtrack] Found solution with 112 backtracks in 0.00s
  [backtrack] Found solution with 695 backtracks in 0.00s
  [backtrack] Found solution with 209 backtracks in 0.00s
  [backtrack] Found solution with 209 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=126.8s)
  Boundary nodes: [0, 1, 2, 4, 7, 8, 9] → expanding 7 children
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 3] → J=243, T=199, cost=1 → queued
    V_MIN=[1, 3, 2, 2, 3, 2, 3, 2, 2, 2, 2, 3] → J=249, T=199, cost=1 → queued
    V_MIN=[1, 2, 3, 2, 3, 2, 3, 2, 2, 2, 2, 3] → J=250, T=200, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 4, 2, 3, 2, 2, 2, 2, 3] → J=250, T=199, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 3, 2, 3, 3, 2, 2, 2, 3] → J=245, T=199, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 3, 2, 3, 2, 3, 2, 2, 3] → J=245, T=200, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 3] → J=241, T=199, cost=1 → queued

[Iter 2] cost=1, J=250, T=199, edges=36, frontier=6, MILP_calls=8
  V_MIN=[1, 2, 2, 2, 4, 2, 3, 2, 2, 2, 2, 3]
  [backtrack] EXHAUSTED search space (576 backtracks in 0.00s)
  [backtrack] Found solution with 331 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (422 backtracks in 0.00s)
  [backtrack] Found solution with 654 backtracks in 0.00s
  [backtrack] Found solution with 739 backtracks in 0.00s
  [backtrack] Found solution with 823 backtracks in 0.00s
  [backtrack] Found solution with 1093 backtracks in 0.00s
  [backtrack] Found solution with 4 backtracks in 0.00s
  [backtrack] Found solution with 554 backtracks in 0.00s
  [backtrack] Found solution with 382 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (950 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (522 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=136.5s)
  Boundary nodes: [0, 1, 2, 4, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[2, 2, 2, 2, 4, 2, 3, 2, 2, 2, 2, 3] → J=238, T=199, cost=2 → queued
    V_MIN=[1, 3, 2, 2, 4, 2, 3, 2, 2, 2, 2, 3] → J=249, T=199, cost=2 → queued
    V_MIN=[1, 2, 3, 2, 4, 2, 3, 2, 2, 2, 2, 3] → J=250, T=200, cost=2 → queued
    V_MIN=[1, 2, 2, 2, 5, 2, 3, 2, 2, 2, 2, 3] → J=235, T=199, cost=2 → queued
    V_MIN=[1, 2, 2, 2, 4, 2, 3, 3, 2, 2, 2, 3] → J=240, T=199, cost=2 → queued
    V_MIN=[1, 2, 2, 2, 4, 2, 3, 2, 3, 2, 2, 3] → J=244, T=200, cost=2 → queued
    V_MIN=[1, 2, 2, 2, 4, 2, 3, 2, 2, 3, 2, 3] → J=235, T=199, cost=2 → queued
    V_MIN=[1, 2, 2, 2, 4, 2, 3, 2, 2, 2, 2, 4] → J=244, T=200, cost=2 → queued

[Iter 3] cost=1, J=250, T=200, edges=36, frontier=13, MILP_calls=16
  V_MIN=[1, 2, 3, 2, 3, 2, 3, 2, 2, 2, 2, 3]
  [backtrack] Found solution with 87 backtracks in 0.00s
  [backtrack] Found solution with 54 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=199.9s
  *** SOLUTION FOUND! J=250, T_tour=199.9s ***

============================================================
Search done: 3 iters, 16 MILP calls, 16 states visited

Original flow_B is latency-feasible ✓
  flow_B = [1, -1, 1, 1, -1, 3, 0, -2, 4, 0, 0, 4, 3, -2, 1, 4, -2, 0, -2, 0, -1, 3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [1, -1, 1, 1, -1, 3, 0, -2, 4, 0, 0, 4, 3, -2, 1, 4, -2, 0, -2, 0, -1, 3]
  Non-zero edges: [((0, 1), np.int64(1)), ((0, 11), np.int64(-1)), ((1, 2), np.int64(1)), ((1, 3), np.int64(1)), ((1, 5), np.int64(-1)), ((2, 3), np.int64(3)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(4)), ((4, 5), np.int64(4)), ((5, 6), np.int64(3)), ((6, 7), np.int64(-2)), ((6, 9), np.int64(1)), ((6, 10), np.int64(4)), ((7, 8), np.int64(-2)), ((8, 9), np.int64(-2)), ((9, 10), np.int64(-1)), ((10, 11), np.int64(3))]

Blocked edge 1: idx=20, edge=(9, 10), flow_B=-1  →  need Cm[20]=1
Blocked edge 2: idx=4, edge=(1, 5), flow_B=-1  →  need Cm[4]=1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=11   ||Cm||_1=11

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, 0, 0, 1, 1, 0, 1, 0, 0, -1, 0]

Cm = C_oriented @ beta*:
  [1, -1, 0, 0, 1, 0, -1, 1, -1, 0, 1, -1, 0, 0, 1, -1, 0, 0, 0, 0, 1, 0]

Original flow_B:
  [1, -1, 1, 1, -1, 3, 0, -2, 4, 0, 0, 4, 3, -2, 1, 4, -2, 0, -2, 0, -1, 3]

flow_B + Cm (corrected flow):
  [2, -2, 1, 1, 0, 3, -1, -1, 3, 0, 1, 3, 3, -2, 2, 3, -2, 0, -2, 0, 0, 3]

Verification:
  flow_corrected[20] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[4] = 0  (should be 0, Cm=1, d=1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 11  (minimized by MIQP)
  ||Cm||_1  = 11
  ||flow_B||_2² = 98
  ||flow_corrected||_2² = 83

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         1       1           2    7.0     +7.0s
    1     (0, 11)        -1      -1          -2    5.0     +5.0s
    2      (1, 2)         1       0           1    6.1          
    3      (1, 3)         1       0           1    6.7          
    4      (1, 5)        -1       1           0    5.2     -5.2s ← BLOCKED
    5      (2, 3)         3       0           3    7.5          
    6      (2, 8)         0      -1          -1    7.5     +7.5s
    7     (2, 11)        -2       1          -1    6.2     -6.2s
    8      (3, 4)         4      -1           3    4.9     -4.9s
    9      (3, 6)         0       0           0    7.7          
   10      (3, 8)         0       1           1    5.6     +5.6s
   11      (4, 5)         4      -1           3    4.6     -4.6s
   12      (5, 6)         3       0           3    5.3          
   13      (6, 7)        -2       0          -2    5.3          
   14      (6, 9)         1       1           2    7.6     +7.6s
   15     (6, 10)         4      -1           3    4.0     -4.0s
   16      (7, 8)        -2       0          -2    4.8          
   17     (7, 10)         0       0           0    7.2          
   18      (8, 9)        -2       0          -2    6.3          
   19     (8, 11)         0       0           0    6.4          
   20     (9, 10)        -1       1           0    7.9     -7.9s ← BLOCKED
   21    (10, 11)         3       0           3    5.6          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=2, out=2  OK
  Node 2: in=3, out=3  OK
  Node 3: in=4, out=4  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=5, out=5  OK
  Node 7: in=2, out=2  OK
  Node 8: in=3, out=3  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 9

  Summary:
    Original path length:  36 edges
    Spliced path length:   35 edges
    Splices performed:     9
    Path is continuous:    True
    Returns to source 1: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           1         1  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)           3         3  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)          -1        -1  ✓
    8      (3, 4)           3         3  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           1         1  ✓
   11      (4, 5)           3         3  ✓
   12      (5, 6)           3         3  ✓
   13      (6, 7)          -2        -2  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)           3         3  ✓
   16      (7, 8)          -2        -2  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)           3         3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 79
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3] → J=204, T=198, cost=0 → queued

[Iter 1] cost=0, J=204, T=198, edges=34, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3]
  [backtrack] Found solution with 125 backtracks in 0.00s
  [backtrack] Found solution with 84 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (174 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (111 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (111 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (50 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (76 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (137 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] Found solution with 6 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (130 backtracks in 0.00s)
  [backtrack] Found solution with 128 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=80.2s)
  Boundary nodes: [0, 1, 2, 4, 7, 9] → expanding 6 children
    V_MIN=[3, 2, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3] → J=200, T=198, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3] → J=203, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 3, 3, 1, 2, 3, 3] → J=203, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 4, 2, 3, 3, 1, 2, 3, 3] → J=200, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 4, 1, 2, 3, 3] → J=201, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 3, 1, 3, 3, 3] → J=197, T=200, cost=1 → queued

[Iter 2] cost=1, J=203, T=200, edges=34, frontier=5, MILP_calls=7
  V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3]
  [backtrack] EXHAUSTED search space (62 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (86 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (115 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (97 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (95 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (60 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (74 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (75 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (41 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (43 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (49 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 4, 6, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3] → J=200, T=200, cost=2 → queued
    V_MIN=[2, 4, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3] → J=200, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 3, 3, 1, 2, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 3, 2, 2, 3, 2, 4, 3, 1, 2, 3, 3] → J=200, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 1, 2, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 2, 2, 3, 3] → J=202, T=196, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 3, 3, 3] → J=197, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 2, 3, 4] → J=202, T=200, cost=2 → queued

[Iter 3] cost=1, J=203, T=200, edges=34, frontier=10, MILP_calls=15
  V_MIN=[2, 2, 3, 2, 3, 2, 3, 3, 1, 2, 3, 3]
  [backtrack] EXHAUSTED search space (79 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (57 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (45 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (44 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (82 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (91 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (115 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (76 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 6, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 2, 3, 2, 3, 2, 3, 3, 1, 2, 3, 3] → J=197, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 4, 2, 3, 3, 1, 2, 3, 3] → J=200, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 4, 3, 1, 2, 3, 3] → J=203, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 3, 4, 1, 2, 3, 3] → J=201, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 3, 3, 2, 2, 3, 3] → J=203, T=197, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 3, 3, 1, 3, 3, 3] → J=196, T=198, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 3, 3, 1, 2, 3, 4] → J=203, T=197, cost=2 → queued

[Iter 4] cost=1, J=201, T=200, edges=33, frontier=16, MILP_calls=22
  V_MIN=[2, 2, 2, 2, 3, 2, 3, 4, 1, 2, 3, 3]
  [backtrack] EXHAUSTED search space (59 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (116 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (114 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (115 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (44 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (91 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (68 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (54 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (51 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 4, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 2, 2, 2, 3, 2, 3, 4, 1, 2, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 2, 4, 2, 3, 4, 1, 2, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 5, 1, 2, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 4, 2, 2, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 4, 1, 3, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 4, 1, 2, 4, 3] → J=201, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 4, 1, 2, 3, 4] → MILP infeasible, pruned

[Iter 5] cost=1, J=200, T=198, edges=34, frontier=16, MILP_calls=29
  V_MIN=[3, 2, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3]
  [backtrack] Found solution with 15 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 38 backtracks in 0.00s
    ✓ Latency-feasible! source=2, T_tour=197.6s
  DFS: latency violated (1 nodes, worst_gap=128.3s)
  Boundary nodes: [0, 2, 4, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 2, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 2, 4, 2, 3, 3, 1, 2, 3, 3] → MILP infeasible, pruned
    V_MIN=[3, 2, 2, 2, 3, 2, 4, 3, 1, 2, 3, 3] → J=199, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 3, 2, 3, 3, 1, 3, 3, 3] → J=193, T=198, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 3, 2, 3, 3, 1, 2, 4, 3] → J=199, T=200, cost=2 → queued

[Iter 6] cost=1, J=200, T=200, edges=34, frontier=18, MILP_calls=34
  V_MIN=[2, 2, 2, 2, 4, 2, 3, 3, 1, 2, 3, 3]
  [backtrack] EXHAUSTED search space (72 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (37 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (76 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (81 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (51 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (53 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (59 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (76 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (37 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (36 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 4, 6, 7, 8, 9, 10, 11] → expanding 9 children
    V_MIN=[2, 2, 2, 2, 5, 2, 3, 3, 1, 2, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 2, 4, 2, 4, 3, 1, 2, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 2, 4, 2, 3, 3, 2, 2, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 2, 4, 2, 3, 3, 1, 3, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 2, 4, 2, 3, 3, 1, 2, 4, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 2, 4, 2, 3, 3, 1, 2, 3, 4] → MILP infeasible, pruned

[Iter 7] cost=1, J=197, T=200, edges=34, frontier=17, MILP_calls=40
  V_MIN=[2, 2, 2, 2, 3, 2, 3, 3, 1, 3, 3, 3]
  [backtrack] EXHAUSTED search space (76 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (107 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (41 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (107 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (107 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (106 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (81 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (99 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (41 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (45 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (39 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[2, 2, 2, 2, 3, 2, 4, 3, 1, 3, 3, 3] → J=196, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 3, 1, 4, 3, 3] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 3, 1, 3, 4, 3] → J=196, T=199, cost=2 → queued

[Iter 8] cost=2, J=203, T=197, edges=34, frontier=18, MILP_calls=43
  V_MIN=[2, 2, 3, 2, 3, 2, 3, 3, 2, 2, 3, 3]
  [backtrack] Found solution with 9 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=197.3s
  *** SOLUTION FOUND! J=203, T_tour=197.3s ***

============================================================
Search done: 8 iters, 43 MILP calls, 43 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 0, 0, 2, -3, 0, 3, -3, 0, 0, -3, -1, -3, 2, 0, 0, -3, -2, 2, 0, -3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 0, 0, 2, -3, 0, 3, -3, 0, 0, -3, -1, -3, 2, 0, 0, -3, -2, 2, 0, -3]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 5), np.int64(2)), ((2, 3), np.int64(-3)), ((2, 11), np.int64(3)), ((3, 4), np.int64(-3)), ((4, 5), np.int64(-3)), ((5, 6), np.int64(-1)), ((6, 7), np.int64(-3)), ((6, 9), np.int64(2)), ((7, 10), np.int64(-3)), ((8, 9), np.int64(-2)), ((8, 11), np.int64(2)), ((10, 11), np.int64(-3))]

Blocked edge 1: idx=0, edge=(0, 1), flow_B=2  →  need Cm[0]=-2
Blocked edge 2: idx=19, edge=(8, 11), flow_B=2  →  need Cm[19]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=18   ||Cm||_1=12

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 0, -2, 0, -1, 0, -2, -1, 0, 0, -1]

Cm = C_oriented @ beta*:
  [-2, 2, -1, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -2, 0, 0]

Original flow_B:
  [2, -2, 0, 0, 2, -3, 0, 3, -3, 0, 0, -3, -1, -3, 2, 0, 0, -3, -2, 2, 0, -3]

flow_B + Cm (corrected flow):
  [0, 0, -1, -1, 2, -3, -1, 3, -3, -1, 0, -3, -1, -4, 2, 0, -1, -3, -2, 0, 0, -3]

Verification:
  flow_corrected[0] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[19] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 18  (minimized by MIQP)
  ||Cm||_1  = 12
  ||flow_B||_2² = 88
  ||flow_corrected||_2² = 88

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2      -2           0    7.2    -14.4s ← BLOCKED
    1     (0, 11)        -2       2           0    6.0    -12.0s
    2      (1, 2)         0      -1          -1    6.2     +6.2s
    3      (1, 3)         0      -1          -1    6.1     +6.1s
    4      (1, 5)         2       0           2    5.1          
    5      (2, 3)        -3       0          -3    4.8          
    6      (2, 8)         0      -1          -1    5.4     +5.4s
    7     (2, 11)         3       0           3    5.1          
    8      (3, 4)        -3       0          -3    4.8          
    9      (3, 6)         0      -1          -1    5.6     +5.6s
   10      (3, 8)         0       0           0    6.1          
   11      (4, 5)        -3       0          -3    4.0          
   12      (5, 6)        -1       0          -1    7.9          
   13      (6, 7)        -3      -1          -4    7.4     +7.4s
   14      (6, 9)         2       0           2    7.2          
   15     (6, 10)         0       0           0    7.0          
   16      (7, 8)         0      -1          -1    7.8     +7.8s
   17     (7, 10)        -3       0          -3    7.9          
   18      (8, 9)        -2       0          -2    4.3          
   19     (8, 11)         2      -2           0    6.1    -12.2s ← BLOCKED
   20     (9, 10)         0       0           0    7.0          
   21    (10, 11)        -3       0          -3    5.2          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=2, out=2  OK
  Node 2: in=4, out=4  OK
  Node 3: in=4, out=4  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=4, out=4  OK
  Node 7: in=4, out=4  OK
  Node 8: in=2, out=2  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 10

  Summary:
    Original path length:  34 edges
    Spliced path length:   34 edges
    Splices performed:     10
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)          -1        -1  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)          -3        -3  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           3         3  ✓
    8      (3, 4)          -3        -3  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -3        -3  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)          -4        -4  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)          -3        -3  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)          -3        -3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 80
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=198, T=197, cost=0 → queued

[Iter 1] cost=0, J=198, T=197, edges=34, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (374 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (505 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (426 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (442 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (248 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (188 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (123 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (124 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (129 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (63 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (126 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [2, 4, 6, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=195, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 3, 1] → J=196, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 3, 1] → J=196, T=198, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 3, 1] → J=196, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 3, 2, 3, 1] → J=194, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 3, 1] → J=196, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 4, 1] → J=196, T=199, cost=1 → queued

[Iter 2] cost=1, J=196, T=199, edges=34, frontier=6, MILP_calls=8
  V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 4, 1]
  [backtrack] Found solution with 106 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.4s
  *** SOLUTION FOUND! J=196, T_tour=199.4s ***

============================================================
Search done: 2 iters, 8 MILP calls, 8 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 0, -3, 1, -2, 0, 2, -3, 0, -2, -3, -2, -2, 0, 0, 0, -2, -2, 0, -2, -4]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 0, -3, 1, -2, 0, 2, -3, 0, -2, -3, -2, -2, 0, 0, 0, -2, -2, 0, -2, -4]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 3), np.int64(-3)), ((1, 5), np.int64(1)), ((2, 3), np.int64(-2)), ((2, 11), np.int64(2)), ((3, 4), np.int64(-3)), ((3, 8), np.int64(-2)), ((4, 5), np.int64(-3)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(-2)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(-2)), ((9, 10), np.int64(-2)), ((10, 11), np.int64(-4))]

Blocked edge 1: idx=20, edge=(9, 10), flow_B=-2  →  need Cm[20]=2
Blocked edge 2: idx=12, edge=(5, 6), flow_B=-2  →  need Cm[12]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=20   ||Cm||_1=16

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -2, 0, 2, 0, 2, 0, 2, -1, -1, 1]

Cm = C_oriented @ beta*:
  [0, 0, 0, -1, 1, 0, 0, 0, 1, -1, -1, 1, 2, 0, 1, 0, 1, -1, 1, -1, 2, 1]

Original flow_B:
  [-2, 2, 0, -3, 1, -2, 0, 2, -3, 0, -2, -3, -2, -2, 0, 0, 0, -2, -2, 0, -2, -4]

flow_B + Cm (corrected flow):
  [-2, 2, 0, -4, 2, -2, 0, 2, -2, -1, -3, -2, 0, -2, 1, 0, 1, -3, -1, -1, 0, -3]

Verification:
  flow_corrected[20] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[12] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 20  (minimized by MIQP)
  ||Cm||_1  = 16
  ||flow_B||_2² = 84
  ||flow_corrected||_2² = 80

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    5.1          
    1     (0, 11)         2       0           2    6.1          
    2      (1, 2)         0       0           0    7.4          
    3      (1, 3)        -3      -1          -4    4.8     +4.8s
    4      (1, 5)         1       1           2    7.2     +7.2s
    5      (2, 3)        -2       0          -2    5.5          
    6      (2, 8)         0       0           0    7.2          
    7     (2, 11)         2       0           2    4.0          
    8      (3, 4)        -3       1          -2    6.7     -6.7s
    9      (3, 6)         0      -1          -1    5.2     +5.2s
   10      (3, 8)        -2      -1          -3    5.3     +5.3s
   11      (4, 5)        -3       1          -2    5.7     -5.7s
   12      (5, 6)        -2       2           0    5.9    -11.8s ← BLOCKED
   13      (6, 7)        -2       0          -2    7.8          
   14      (6, 9)         0       1           1    6.9     +6.9s
   15     (6, 10)         0       0           0    7.9          
   16      (7, 8)         0       1           1    6.3     +6.3s
   17     (7, 10)        -2      -1          -3    6.1     +6.1s
   18      (8, 9)        -2       1          -1    5.8     -5.8s
   19     (8, 11)         0      -1          -1    7.5     +7.5s
   20     (9, 10)        -2       2           0    6.5    -13.0s ← BLOCKED
   21    (10, 11)        -4       1          -3    6.1     -6.1s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=4, out=4  OK
  Node 2: in=2, out=2  OK
  Node 3: in=6, out=6  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=2, out=2  OK
  Node 7: in=3, out=3  OK
  Node 8: in=3, out=3  OK
  Node 9: in=1, out=1  OK
  Node 10: in=3, out=3  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 17

  Summary:
    Original path length:  34 edges
    Spliced path length:   34 edges
    Splices performed:     17
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)          -4        -4  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           2         2  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)          -1        -1  ✓
   10      (3, 8)          -3        -3  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)          -2        -2  ✓
   14      (6, 9)           1         1  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)          -3        -3  ✓
   18      (8, 9)          -1        -1  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)          -3        -3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 81
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 2] → J=185, T=200, cost=0 → queued

[Iter 1] cost=0, J=185, T=200, edges=32, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 2]
  [backtrack] EXHAUSTED search space (238 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (253 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (229 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (205 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (165 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (147 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (133 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (121 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (196 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (142 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 6, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 4, 3, 1, 2, 2, 2, 3, 2, 2] → J=185, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 4, 1, 2, 2, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 3, 3, 1, 3, 2, 2, 3, 2, 2] → J=180, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 3, 1, 2, 3, 2, 3, 2, 2] → J=177, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 3, 1, 2, 2, 3, 3, 2, 2] → J=183, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 3, 1, 2, 2, 2, 4, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 3, 3, 1, 2, 2, 2, 3, 2, 3] → J=183, T=199, cost=1 → queued

[Iter 2] cost=1, J=185, T=200, edges=32, frontier=4, MILP_calls=9
  V_MIN=[2, 2, 3, 4, 3, 1, 2, 2, 2, 3, 2, 2]
  [backtrack] Found solution with 513 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (315 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (720 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (727 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (939 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (360 backtracks in 0.00s)
  [backtrack] Found solution with 320 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (786 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (247 backtracks in 0.00s)
  [backtrack] Found solution with 173 backtracks in 0.00s
  [backtrack] Found solution with 214 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (463 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=111.8s)
  Boundary nodes: [0, 2, 3, 4, 6, 7, 8, 9, 11] → expanding 9 children
    V_MIN=[3, 2, 3, 4, 3, 1, 2, 2, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 4, 4, 3, 1, 2, 2, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 5, 3, 1, 2, 2, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 4, 4, 1, 2, 2, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 4, 3, 1, 3, 2, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 4, 3, 1, 2, 3, 2, 3, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 4, 3, 1, 2, 2, 3, 3, 2, 2] → J=183, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 4, 3, 1, 2, 2, 2, 4, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 4, 3, 1, 2, 2, 2, 3, 2, 3] → MILP infeasible, pruned

[Iter 3] cost=1, J=183, T=199, edges=32, frontier=4, MILP_calls=18
  V_MIN=[2, 2, 3, 3, 3, 1, 2, 2, 3, 3, 2, 2]
  [backtrack] Found solution with 34 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.6s
  *** SOLUTION FOUND! J=183, T_tour=198.6s ***

============================================================
Search done: 3 iters, 18 MILP calls, 18 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 1, 0, 1, -3, 3, 1, -3, 0, 0, -3, -2, -2, 0, 0, 0, -2, 3, 0, 3, 1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 1, 0, 1, -3, 3, 1, -3, 0, 0, -3, -2, -2, 0, 0, 0, -2, 3, 0, 3, 1]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(1)), ((1, 5), np.int64(1)), ((2, 3), np.int64(-3)), ((2, 8), np.int64(3)), ((2, 11), np.int64(1)), ((3, 4), np.int64(-3)), ((4, 5), np.int64(-3)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(-2)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(3)), ((9, 10), np.int64(3)), ((10, 11), np.int64(1))]

Blocked edge 1: idx=1, edge=(0, 11), flow_B=-2  →  need Cm[1]=2
Blocked edge 2: idx=18, edge=(8, 9), flow_B=3  →  need Cm[18]=-3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=37   ||Cm||_1=21

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, 2, -1, -1, -1, 0, -2, -3, 2, 0, 0]

Cm = C_oriented @ beta*:
  [-2, 2, -2, 0, 0, -1, 0, -1, 0, 0, -1, 0, 0, -1, 2, -1, -1, 0, -3, 1, -1, -2]

Original flow_B:
  [2, -2, 1, 0, 1, -3, 3, 1, -3, 0, 0, -3, -2, -2, 0, 0, 0, -2, 3, 0, 3, 1]

flow_B + Cm (corrected flow):
  [0, 0, -1, 0, 1, -4, 3, 0, -3, 0, -1, -3, -2, -3, 2, -1, -1, -2, 0, 1, 2, -1]

Verification:
  flow_corrected[1] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[18] = 0  (should be 0, Cm=-3, d=-3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 37  (minimized by MIQP)
  ||Cm||_1  = 21
  ||flow_B||_2² = 78
  ||flow_corrected||_2² = 75

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2      -2           0    7.1    -14.2s
    1     (0, 11)        -2       2           0    6.3    -12.6s ← BLOCKED
    2      (1, 2)         1      -2          -1    5.0          
    3      (1, 3)         0       0           0    6.2          
    4      (1, 5)         1       0           1    4.6          
    5      (2, 3)        -3      -1          -4    5.8     +5.8s
    6      (2, 8)         3       0           3    5.9          
    7     (2, 11)         1      -1           0    6.9     -6.9s
    8      (3, 4)        -3       0          -3    7.8          
    9      (3, 6)         0       0           0    6.5          
   10      (3, 8)         0      -1          -1    5.7     +5.7s
   11      (4, 5)        -3       0          -3    7.6          
   12      (5, 6)        -2       0          -2    5.3          
   13      (6, 7)        -2      -1          -3    7.9     +7.9s
   14      (6, 9)         0       2           2    6.8    +13.6s
   15     (6, 10)         0      -1          -1    7.7     +7.7s
   16      (7, 8)         0      -1          -1    8.0     +8.0s
   17     (7, 10)        -2       0          -2    6.9          
   18      (8, 9)         3      -3           0    5.3    -15.9s ← BLOCKED
   19     (8, 11)         0       1           1    5.1     +5.1s
   20     (9, 10)         3      -1           2    4.4     -4.4s
   21    (10, 11)         1      -2          -1    4.7          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=1, out=1  OK
  Node 2: in=4, out=4  OK
  Node 3: in=4, out=4  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=4, out=4  OK
  Node 7: in=3, out=3  OK
  Node 8: in=3, out=3  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=1, out=1  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 31 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 25

  Summary:
    Original path length:  32 edges
    Spliced path length:   31 edges
    Splices performed:     25
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)          -1        -1  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)          -4        -4  ✓
    6      (2, 8)           3         3  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -3        -3  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)          -3        -3  ✓
   12      (5, 6)          -2        -2  ✓
   13      (6, 7)          -3        -3  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)           1         1  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 82
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 2, 1, 2, 2] → J=288, T=200, cost=0 → queued

[Iter 1] cost=0, J=288, T=200, edges=39, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 2, 1, 2, 2]
  [backtrack] Found solution with 316 backtracks in 0.00s
  [backtrack] Found solution with 342 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1810 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (4684 backtracks in 0.01s)
  [backtrack] Found solution with 4215 backtracks in 0.01s
  [backtrack] Found solution with 138 backtracks in 0.00s
  [backtrack] Found solution with 162 backtracks in 0.00s
  [backtrack] Found solution with 987 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (2335 backtracks in 0.01s)
  [backtrack] Found solution with 1412 backtracks in 0.00s
  [backtrack] Found solution with 154 backtracks in 0.00s
  [backtrack] Found solution with 290 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=175.3s)
  Boundary nodes: [0, 1, 2, 3, 4, 5, 8, 9, 11] → expanding 9 children
    V_MIN=[3, 2, 2, 2, 2, 3, 3, 2, 2, 1, 2, 2] → J=261, T=199, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 2, 2, 1, 2, 2] → J=283, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 2, 3, 3, 2, 2, 1, 2, 2] → J=283, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 2, 2, 1, 2, 2] → J=288, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 3, 3, 2, 2, 1, 2, 2] → J=283, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 4, 3, 2, 2, 1, 2, 2] → J=276, T=198, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 2, 2] → J=284, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2] → J=278, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 2, 1, 2, 3] → J=282, T=200, cost=1 → queued

[Iter 2] cost=1, J=288, T=200, edges=39, frontier=8, MILP_calls=10
  V_MIN=[2, 2, 2, 3, 2, 3, 3, 2, 2, 1, 2, 2]
  [backtrack] Found solution with 597 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.6s
  *** SOLUTION FOUND! J=288, T_tour=199.6s ***

============================================================
Search done: 2 iters, 10 MILP calls, 10 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -1, 0, -1, 1, -1, -1, -2, 1, 2, -2, -3, -6, -1, 5, 0, -6, 1, 0, 0, -1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -1, 0, -1, 1, -1, -1, -2, 1, 2, -2, -3, -6, -1, 5, 0, -6, 1, 0, 0, -1]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-1)), ((1, 5), np.int64(-1)), ((2, 3), np.int64(1)), ((2, 8), np.int64(-1)), ((2, 11), np.int64(-1)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(1)), ((3, 8), np.int64(2)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-3)), ((6, 7), np.int64(-6)), ((6, 9), np.int64(-1)), ((6, 10), np.int64(5)), ((7, 10), np.int64(-6)), ((8, 9), np.int64(1)), ((10, 11), np.int64(-1))]

Blocked edge 1: idx=17, edge=(7, 10), flow_B=-6  →  need Cm[17]=6
Blocked edge 2: idx=7, edge=(2, 11), flow_B=-1  →  need Cm[7]=1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=81   ||Cm||_1=29

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, 5, -1, -2, 0, 0, 0, -2, -1, 0, -1]

Cm = C_oriented @ beta*:
  [0, 0, -1, 1, 0, -1, -1, 1, 0, -1, 1, 0, 0, 3, -1, -3, -3, 6, -1, -2, -2, 1]

Original flow_B:
  [-2, 2, -1, 0, -1, 1, -1, -1, -2, 1, 2, -2, -3, -6, -1, 5, 0, -6, 1, 0, 0, -1]

flow_B + Cm (corrected flow):
  [-2, 2, -2, 1, -1, 0, -2, 0, -2, 0, 3, -2, -3, -3, -2, 2, -3, 0, 0, -2, -2, 0]

Verification:
  flow_corrected[17] = 0  (should be 0, Cm=6, d=6)
  flow_corrected[7] = 0  (should be 0, Cm=1, d=1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 81  (minimized by MIQP)
  ||Cm||_1  = 29
  ||flow_B||_2² = 135
  ||flow_corrected||_2² = 78

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    6.6          
    1     (0, 11)         2       0           2    8.0          
    2      (1, 2)        -1      -1          -2    5.3     +5.3s
    3      (1, 3)         0       1           1    7.2     +7.2s
    4      (1, 5)        -1       0          -1    6.7          
    5      (2, 3)         1      -1           0    6.2     -6.2s
    6      (2, 8)        -1      -1          -2    4.3     +4.3s
    7     (2, 11)        -1       1           0    4.4     -4.4s ← BLOCKED
    8      (3, 4)        -2       0          -2    7.5          
    9      (3, 6)         1      -1           0    6.4     -6.4s
   10      (3, 8)         2       1           3    4.3     +4.3s
   11      (4, 5)        -2       0          -2    5.4          
   12      (5, 6)        -3       0          -3    5.5          
   13      (6, 7)        -6       3          -3    4.0    -12.0s
   14      (6, 9)        -1      -1          -2    5.8     +5.8s
   15     (6, 10)         5      -3           2    4.2    -12.6s
   16      (7, 8)         0      -3          -3    6.7    +20.1s
   17     (7, 10)        -6       6           0    4.1    -24.6s ← BLOCKED
   18      (8, 9)         1      -1           0    5.5     -5.5s
   19     (8, 11)         0      -2          -2    7.3    +14.6s
   20     (9, 10)         0      -2          -2    7.6    +15.2s
   21    (10, 11)        -1       1           0    5.3     -5.3s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=3, out=3  OK
  Node 2: in=2, out=2  OK
  Node 3: in=3, out=3  OK
  Node 4: in=2, out=2  OK
  Node 5: in=3, out=3  OK
  Node 6: in=5, out=5  OK
  Node 7: in=3, out=3  OK
  Node 8: in=5, out=5  OK
  Node 9: in=2, out=2  OK
  Node 10: in=2, out=2  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 30

  Summary:
    Original path length:  39 edges
    Spliced path length:   34 edges
    Splices performed:     30
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)          -2        -2  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)          -2        -2  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           3         3  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)          -3        -3  ✓
   13      (6, 7)          -3        -3  ✓
   14      (6, 9)          -2        -2  ✓
   15     (6, 10)           2         2  ✓
   16      (7, 8)          -3        -3  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)          -2        -2  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 83
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 2, 1] → J=211, T=199, cost=0 → queued

[Iter 1] cost=0, J=211, T=199, edges=36, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 2, 1]
  [backtrack] EXHAUSTED search space (716 backtracks in 0.00s)
  [backtrack] Found solution with 481 backtracks in 0.00s
  [backtrack] Found solution with 368 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (418 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (535 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (236 backtracks in 0.00s)
  [backtrack] Found solution with 135 backtracks in 0.00s
  [backtrack] Found solution with 210 backtracks in 0.00s
  [backtrack] Found solution with 310 backtracks in 0.00s
  [backtrack] Found solution with 300 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (177 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (550 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=91.3s)
  Boundary nodes: [0, 2, 4, 7, 8, 9] → expanding 6 children
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 2, 2, 2, 1] → J=195, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 3, 2, 2, 2, 1] → J=201, T=198, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 4, 2, 2, 3, 2, 2, 2, 1] → J=201, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 4, 2, 2, 2, 1] → J=203, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 1] → J=207, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 3, 2, 3, 2, 1] → J=197, T=200, cost=1 → queued

[Iter 2] cost=1, J=207, T=200, edges=36, frontier=5, MILP_calls=7
  V_MIN=[2, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 1]
  [backtrack] Found solution with 200 backtracks in 0.00s
  [backtrack] Found solution with 238 backtracks in 0.00s
  [backtrack] Found solution with 273 backtracks in 0.00s
    ✓ Latency-feasible! source=2, T_tour=200.0s
  DFS: latency violated (2 nodes, worst_gap=107.9s)
  Boundary nodes: [0, 2, 4, 7, 8, 9] → expanding 6 children
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 1] → J=192, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 3, 3, 2, 2, 1] → J=201, T=198, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 4, 2, 2, 3, 3, 2, 2, 1] → J=196, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 4, 3, 2, 2, 1] → J=199, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 3, 4, 2, 2, 1] → J=203, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 3, 3, 3, 2, 1] → J=197, T=200, cost=2 → queued

[Iter 3] cost=1, J=203, T=200, edges=35, frontier=10, MILP_calls=13
  V_MIN=[2, 2, 2, 3, 3, 2, 2, 4, 2, 2, 2, 1]
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (92 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (93 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (96 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (178 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (221 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (151 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (148 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 7, 8, 9] → expanding 6 children
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 4, 2, 2, 2, 1] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 4, 2, 2, 2, 1] → J=190, T=198, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 4, 2, 2, 4, 2, 2, 2, 1] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 5, 2, 2, 2, 1] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 4, 2, 3, 2, 1] → MILP infeasible, pruned

[Iter 4] cost=1, J=201, T=199, edges=35, frontier=10, MILP_calls=18
  V_MIN=[2, 2, 2, 3, 4, 2, 2, 3, 2, 2, 2, 1]
  [backtrack] Found solution with 8 backtracks in 0.00s
  [backtrack] Found solution with 8 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (68 backtracks in 0.00s)
  [backtrack] Found solution with 22 backtracks in 0.00s
  [backtrack] Found solution with 22 backtracks in 0.00s
  [backtrack] Found solution with 22 backtracks in 0.00s
  [backtrack] Found solution with 22 backtracks in 0.00s
  [backtrack] Found solution with 22 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (136 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (133 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (64 backtracks in 0.00s)
  [backtrack] Found solution with 8 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=104.5s)
  Boundary nodes: [0, 2, 4, 7, 8, 9] → expanding 6 children
    V_MIN=[3, 2, 2, 3, 4, 2, 2, 3, 2, 2, 2, 1] → MILP infeasible, pruned
    V_MIN=[2, 2, 3, 3, 4, 2, 2, 3, 2, 2, 2, 1] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 3, 5, 2, 2, 3, 2, 2, 2, 1] → MILP infeasible, pruned
    V_MIN=[2, 2, 2, 3, 4, 2, 2, 3, 2, 3, 2, 1] → MILP infeasible, pruned

[Iter 5] cost=1, J=201, T=198, edges=35, frontier=9, MILP_calls=22
  V_MIN=[2, 2, 3, 3, 3, 2, 2, 3, 2, 2, 2, 1]
  [backtrack] Found solution with 34 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=198.2s
  DFS: latency violated (2 nodes, worst_gap=102.3s)
  Boundary nodes: [0, 2, 3, 4, 7, 9] → expanding 6 children
    V_MIN=[3, 2, 3, 3, 3, 2, 2, 3, 2, 2, 2, 1] → MILP infeasible, pruned
    V_MIN=[2, 2, 4, 3, 3, 2, 2, 3, 2, 2, 2, 1] → J=191, T=198, cost=2 → queued
    V_MIN=[2, 2, 3, 4, 3, 2, 2, 3, 2, 2, 2, 1] → J=200, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 3, 2, 3, 2, 1] → J=188, T=199, cost=2 → queued

[Iter 6] cost=1, J=197, T=200, edges=35, frontier=11, MILP_calls=26
  V_MIN=[2, 2, 2, 3, 3, 2, 2, 3, 2, 3, 2, 1]
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.8s
  *** SOLUTION FOUND! J=197, T_tour=199.8s ***

============================================================
Search done: 6 iters, 26 MILP calls, 26 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, -1, -2, 1, 1, -2, 0, -3, 2, 0, -3, -2, -3, 3, 0, 0, -3, -2, 0, 1, -2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, -1, -2, 1, 1, -2, 0, -3, 2, 0, -3, -2, -3, 3, 0, 0, -3, -2, 0, 1, -2]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 2), np.int64(-1)), ((1, 3), np.int64(-2)), ((1, 5), np.int64(1)), ((2, 3), np.int64(1)), ((2, 8), np.int64(-2)), ((3, 4), np.int64(-3)), ((3, 6), np.int64(2)), ((4, 5), np.int64(-3)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(-3)), ((6, 9), np.int64(3)), ((7, 10), np.int64(-3)), ((8, 9), np.int64(-2)), ((9, 10), np.int64(1)), ((10, 11), np.int64(-2))]

Blocked edge 1: idx=9, edge=(3, 6), flow_B=2  →  need Cm[9]=-2
Blocked edge 2: idx=6, edge=(2, 8), flow_B=-2  →  need Cm[6]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=16   ||Cm||_1=12

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 1, 0, 0, -2, 0, 0, -2, 1, 0, -2]

Cm = C_oriented @ beta*:
  [0, 0, 1, -1, 0, -1, 2, 0, 0, -2, 0, 0, 0, -1, 0, -1, -1, 0, 0, 1, 0, -1]

Original flow_B:
  [-2, 2, -1, -2, 1, 1, -2, 0, -3, 2, 0, -3, -2, -3, 3, 0, 0, -3, -2, 0, 1, -2]

flow_B + Cm (corrected flow):
  [-2, 2, 0, -3, 1, 0, 0, 0, -3, 0, 0, -3, -2, -4, 3, -1, -1, -3, -2, 1, 1, -3]

Verification:
  flow_corrected[9] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[6] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 16  (minimized by MIQP)
  ||Cm||_1  = 12
  ||flow_B||_2² = 81
  ||flow_corrected||_2² = 91

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    5.5          
    1     (0, 11)         2       0           2    7.3          
    2      (1, 2)        -1       1           0    6.1     -6.1s
    3      (1, 3)        -2      -1          -3    4.5     +4.5s
    4      (1, 5)         1       0           1    5.7          
    5      (2, 3)         1      -1           0    7.3     -7.3s
    6      (2, 8)        -2       2           0    5.4    -10.8s ← BLOCKED
    7     (2, 11)         0       0           0    7.7          
    8      (3, 4)        -3       0          -3    4.7          
    9      (3, 6)         2      -2           0    4.1     -8.2s ← BLOCKED
   10      (3, 8)         0       0           0    4.9          
   11      (4, 5)        -3       0          -3    6.9          
   12      (5, 6)        -2       0          -2    5.1          
   13      (6, 7)        -3      -1          -4    6.3     +6.3s
   14      (6, 9)         3       0           3    6.5          
   15     (6, 10)         0      -1          -1    4.9     +4.9s
   16      (7, 8)         0      -1          -1    7.0     +7.0s
   17     (7, 10)        -3       0          -3    5.4          
   18      (8, 9)        -2       0          -2    5.3          
   19     (8, 11)         0       1           1    5.3     +5.3s
   20     (9, 10)         1       0           1    7.9          
   21    (10, 11)        -2      -1          -3    4.5     +4.5s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=3, out=3  OK
  Node 3: in=3, out=3  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=5, out=5  OK
  Node 7: in=4, out=4  OK
  Node 8: in=2, out=2  OK
  Node 9: in=3, out=3  OK
  Node 10: in=4, out=4  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 16

  Summary:
    Original path length:  35 edges
    Spliced path length:   35 edges
    Splices performed:     16
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)          -3        -3  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)          -3        -3  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -3        -3  ✓
   12      (5, 6)          -2        -2  ✓
   13      (6, 7)          -4        -4  ✓
   14      (6, 9)           3         3  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)          -3        -3  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)           1         1  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)          -3        -3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 84
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[1, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2] → J=160, T=200, cost=0 → queued

[Iter 1] cost=0, J=160, T=200, edges=34, frontier=0, MILP_calls=1
  V_MIN=[1, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 3 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 710 backtracks in 0.00s
    ✓ Latency-feasible! source=4, T_tour=199.8s
  DFS: latency violated (1 nodes, worst_gap=96.5s)
  Boundary nodes: [0, 1, 2, 4, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2] → J=152, T=199, cost=1 → queued
    V_MIN=[1, 3, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2] → J=158, T=200, cost=1 → queued
    V_MIN=[1, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2] → J=156, T=199, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2] → J=156, T=199, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2] → J=159, T=198, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2] → J=152, T=200, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2] → J=156, T=200, cost=1 → queued
    V_MIN=[1, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2] → J=158, T=200, cost=1 → queued

[Iter 2] cost=1, J=159, T=198, edges=34, frontier=7, MILP_calls=9
  V_MIN=[1, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 16 backtracks in 0.00s
  [backtrack] Found solution with 17 backtracks in 0.00s
  [backtrack] Found solution with 201 backtracks in 0.00s
  [backtrack] Found solution with 139 backtracks in 0.00s
    ✓ Latency-feasible! source=3, T_tour=198.0s
  DFS: latency violated (1 nodes, worst_gap=98.4s)
  Boundary nodes: [0, 1, 2, 4, 6, 7, 9, 10] → expanding 8 children
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2] → J=151, T=198, cost=2 → queued
    V_MIN=[1, 3, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2] → J=158, T=200, cost=2 → queued
    V_MIN=[1, 2, 3, 2, 3, 2, 3, 2, 2, 2, 2, 2] → J=156, T=199, cost=2 → queued
    V_MIN=[1, 2, 2, 2, 4, 2, 3, 2, 2, 2, 2, 2] → J=153, T=200, cost=2 → queued
    V_MIN=[1, 2, 2, 2, 3, 2, 4, 2, 2, 2, 2, 2] → J=158, T=200, cost=2 → queued
    V_MIN=[1, 2, 2, 2, 3, 2, 3, 3, 2, 2, 2, 2] → J=152, T=200, cost=2 → queued
    V_MIN=[1, 2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 2] → J=154, T=200, cost=2 → queued
    V_MIN=[1, 2, 2, 2, 3, 2, 3, 2, 2, 2, 3, 2] → J=158, T=200, cost=2 → queued

[Iter 3] cost=1, J=158, T=200, edges=34, frontier=14, MILP_calls=17
  V_MIN=[1, 3, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 2 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.7s
  *** SOLUTION FOUND! J=158, T_tour=199.7s ***

============================================================
Search done: 3 iters, 17 MILP calls, 17 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-1, 1, 2, -3, 0, 0, 1, 1, 3, -1, -5, 3, 3, 2, 0, 0, 0, 2, -2, -2, -2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-1, 1, 2, -3, 0, 0, 1, 1, 3, -1, -5, 3, 3, 2, 0, 0, 0, 2, -2, -2, -2, 0]
  Non-zero edges: [((0, 1), np.int64(-1)), ((0, 11), np.int64(1)), ((1, 2), np.int64(2)), ((1, 3), np.int64(-3)), ((2, 8), np.int64(1)), ((2, 11), np.int64(1)), ((3, 4), np.int64(3)), ((3, 6), np.int64(-1)), ((3, 8), np.int64(-5)), ((4, 5), np.int64(3)), ((5, 6), np.int64(3)), ((6, 7), np.int64(2)), ((7, 10), np.int64(2)), ((8, 9), np.int64(-2)), ((8, 11), np.int64(-2)), ((9, 10), np.int64(-2))]

Blocked edge 1: idx=0, edge=(0, 1), flow_B=-1  →  need Cm[0]=1
Blocked edge 2: idx=6, edge=(2, 8), flow_B=1  →  need Cm[6]=-1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=12   ||Cm||_1=12

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-2, -1, 1, 0, 2, 1, 1, 2, -1, -1, 2]

Cm = C_oriented @ beta*:
  [1, -1, -1, 1, 1, 0, -1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1]

Original flow_B:
  [-1, 1, 2, -3, 0, 0, 1, 1, 3, -1, -5, 3, 3, 2, 0, 0, 0, 2, -2, -2, -2, 0]

flow_B + Cm (corrected flow):
  [0, 0, 1, -2, 1, 0, 0, 1, 3, 0, -5, 3, 4, 3, 0, 1, 1, 2, -2, -2, -2, 1]

Verification:
  flow_corrected[0] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[6] = 0  (should be 0, Cm=-1, d=-1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 12  (minimized by MIQP)
  ||Cm||_1  = 12
  ||flow_B||_2² = 90
  ||flow_corrected||_2² = 94

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -1       1           0    7.9     -7.9s ← BLOCKED
    1     (0, 11)         1      -1           0    5.2     -5.2s
    2      (1, 2)         2      -1           1    6.6     -6.6s
    3      (1, 3)        -3       1          -2    6.1     -6.1s
    4      (1, 5)         0       1           1    7.5     +7.5s
    5      (2, 3)         0       0           0    7.5          
    6      (2, 8)         1      -1           0    7.8     -7.8s ← BLOCKED
    7     (2, 11)         1       0           1    4.4          
    8      (3, 4)         3       0           3    6.5          
    9      (3, 6)        -1       1           0    4.7     -4.7s
   10      (3, 8)        -5       0          -5    4.3          
   11      (4, 5)         3       0           3    8.0          
   12      (5, 6)         3       1           4    5.4     +5.4s
   13      (6, 7)         2       1           3    7.4     +7.4s
   14      (6, 9)         0       0           0    6.6          
   15     (6, 10)         0       1           1    4.8     +4.8s
   16      (7, 8)         0       1           1    7.9     +7.9s
   17     (7, 10)         2       0           2    4.6          
   18      (8, 9)        -2       0          -2    6.2          
   19     (8, 11)        -2       0          -2    5.1          
   20     (9, 10)        -2       0          -2    5.2          
   21    (10, 11)         0       1           1    5.3     +5.3s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=2, out=2  OK
  Node 2: in=1, out=1  OK
  Node 3: in=5, out=5  OK
  Node 4: in=3, out=3  OK
  Node 5: in=4, out=4  OK
  Node 6: in=4, out=4  OK
  Node 7: in=3, out=3  OK
  Node 8: in=5, out=5  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 6

  Summary:
    Original path length:  34 edges
    Spliced path length:   34 edges
    Splices performed:     6
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           1         1  ✓
    3      (1, 3)          -2        -2  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           1         1  ✓
    8      (3, 4)           3         3  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)          -5        -5  ✓
   11      (4, 5)           3         3  ✓
   12      (5, 6)           4         4  ✓
   13      (6, 7)           3         3  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)          -2        -2  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 85
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 1] → J=230, T=200, cost=0 → queued

[Iter 1] cost=0, J=230, T=200, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (812 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (459 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (412 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (819 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (788 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (556 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (623 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (624 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (872 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1087 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (140 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (694 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 6] → expanding 6 children
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 1] → J=222, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 1] → J=227, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 1] → J=229, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=224, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 1] → J=227, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3, 1] → J=229, T=199, cost=1 → queued

[Iter 2] cost=1, J=229, T=199, edges=37, frontier=5, MILP_calls=7
  V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (2351 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2135 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (783 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (881 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1809 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2588 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1702 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1201 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2056 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2638 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (380 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1402 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7] → expanding 6 children
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 1] → J=218, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 1] → J=226, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 3, 1] → J=228, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 3, 1] → J=224, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 3, 1] → J=224, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 1] → J=228, T=199, cost=2 → queued

[Iter 3] cost=1, J=229, T=199, edges=37, frontier=10, MILP_calls=13
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (2386 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1760 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1167 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2653 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2147 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1765 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2065 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1859 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1592 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1854 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3242 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1189 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 6, 7] → expanding 6 children
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3, 1] → J=222, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3, 1] → J=227, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 3, 1] → J=223, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 3, 1] → J=227, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 3, 1] → J=229, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 1] → J=229, T=199, cost=2 → queued

[Iter 4] cost=1, J=227, T=199, edges=37, frontier=15, MILP_calls=19
  V_MIN=[2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (560 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (466 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (423 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (345 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (402 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (536 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (155 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (571 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (947 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1117 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (770 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (603 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7] → expanding 6 children
    V_MIN=[3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 1] → J=216, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 3, 1] → J=222, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 3, 1] → J=224, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 3, 1] → J=222, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 3, 1] → J=224, T=200, cost=2 → queued

[Iter 5] cost=1, J=227, T=200, edges=38, frontier=19, MILP_calls=24
  V_MIN=[2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (799 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (553 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (904 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (759 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (737 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (667 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (718 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (705 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (592 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (975 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (602 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (440 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5] → expanding 5 children
    V_MIN=[3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 1] → J=221, T=200, cost=2 → queued
    V_MIN=[2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 3, 1] → J=223, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=220, T=200, cost=2 → queued

[Iter 6] cost=1, J=224, T=199, edges=37, frontier=21, MILP_calls=27
  V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (923 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (545 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (953 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1081 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1020 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1011 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (452 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (480 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (426 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (640 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (779 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (425 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 6, 7] → expanding 5 children
    V_MIN=[3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 1] → J=213, T=198, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 3, 1] → J=218, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 3, 1] → J=222, T=197, cost=2 → queued

[Iter 7] cost=1, J=222, T=200, edges=37, frontier=23, MILP_calls=30
  V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (1217 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (906 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1084 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (694 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (808 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (934 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (799 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (455 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (215 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (874 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (711 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (479 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7, 8] → expanding 7 children
    V_MIN=[4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 1] → J=210, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 1] → J=220, T=198, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 1] → J=221, T=200, cost=2 → queued

[Iter 8] cost=2, J=229, T=199, edges=37, frontier=25, MILP_calls=33
  V_MIN=[2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (250 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (403 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (315 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (458 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (433 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (418 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (877 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (848 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (691 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (453 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1198 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (251 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 3, 4, 5, 6] → expanding 7 children
    V_MIN=[3, 2, 2, 2, 2, 2, 4, 2, 2, 2, 3, 1] → J=222, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 2, 2, 2, 3, 1] → J=228, T=198, cost=3 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 4, 2, 2, 2, 3, 1] → J=226, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 4, 2, 2, 2, 3, 1] → J=228, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 4, 2, 2, 2, 3, 1] → J=223, T=199, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 4, 2, 2, 2, 3, 1] → J=227, T=199, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 3, 1] → J=228, T=196, cost=3 → queued

[Iter 9] cost=2, J=229, T=199, edges=37, frontier=31, MILP_calls=40
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 1]
  [backtrack] EXHAUSTED search space (250 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (403 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (315 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (458 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (433 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (418 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (877 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (848 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (691 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (453 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1198 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (251 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 1, 2, 3, 4, 5, 7] → expanding 7 children
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 1] → J=218, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 3, 1] → J=229, T=200, cost=3 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 3, 3, 2, 2, 3, 1] → J=227, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 3, 3, 2, 2, 3, 1] → J=227, T=198, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 3, 2, 2, 3, 1] → J=221, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 3, 2, 2, 3, 1] → J=224, T=200, cost=3 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 4, 2, 2, 3, 1] → J=228, T=200, cost=3 → queued

[Iter 10] cost=2, J=228, T=200, edges=37, frontier=37, MILP_calls=47
  V_MIN=[2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] Found solution with 229 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.5s
  *** SOLUTION FOUND! J=228, T_tour=199.5s ***

============================================================
Search done: 10 iters, 47 MILP calls, 47 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 0, -4, 2, 0, 2, -2, -2, 0, -2, -2, 0, 0, -3, 3, -2, 2, -2, 0, -5, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 0, -4, 2, 0, 2, -2, -2, 0, -2, -2, 0, 0, -3, 3, -2, 2, -2, 0, -5, 0]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 3), np.int64(-4)), ((1, 5), np.int64(2)), ((2, 8), np.int64(2)), ((2, 11), np.int64(-2)), ((3, 4), np.int64(-2)), ((3, 8), np.int64(-2)), ((4, 5), np.int64(-2)), ((6, 9), np.int64(-3)), ((6, 10), np.int64(3)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(2)), ((8, 9), np.int64(-2)), ((9, 10), np.int64(-5))]

Blocked edge 1: idx=17, edge=(7, 10), flow_B=2  →  need Cm[17]=-2
Blocked edge 2: idx=14, edge=(6, 9), flow_B=-3  →  need Cm[14]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=28   ||Cm||_1=14

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -2, 0, 2, 0, 0, 0, 1, 0, 0, 2]

Cm = C_oriented @ beta*:
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, -2, 0, 0, -1, 3, 0, 1, -2, -1, 0, 2, 0]

Original flow_B:
  [-2, 2, 0, -4, 2, 0, 2, -2, -2, 0, -2, -2, 0, 0, -3, 3, -2, 2, -2, 0, -5, 0]

flow_B + Cm (corrected flow):
  [-2, 2, 0, -4, 2, 0, 2, -2, -2, 2, -4, -2, 0, -1, 0, 3, -1, 0, -3, 0, -3, 0]

Verification:
  flow_corrected[17] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[14] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 28  (minimized by MIQP)
  ||Cm||_1  = 14
  ||flow_B||_2² = 103
  ||flow_corrected||_2² = 93

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       0          -2    5.6          
    1     (0, 11)         2       0           2    7.5          
    2      (1, 2)         0       0           0    4.8          
    3      (1, 3)        -4       0          -4    4.9          
    4      (1, 5)         2       0           2    5.1          
    5      (2, 3)         0       0           0    5.8          
    6      (2, 8)         2       0           2    5.4          
    7     (2, 11)        -2       0          -2    4.0          
    8      (3, 4)        -2       0          -2    5.6          
    9      (3, 6)         0       2           2    6.8    +13.6s
   10      (3, 8)        -2      -2          -4    7.3    +14.6s
   11      (4, 5)        -2       0          -2    5.3          
   12      (5, 6)         0       0           0    6.9          
   13      (6, 7)         0      -1          -1    6.0     +6.0s
   14      (6, 9)        -3       3           0    5.5    -16.5s ← BLOCKED
   15     (6, 10)         3       0           3    4.7          
   16      (7, 8)        -2       1          -1    6.1     -6.1s
   17     (7, 10)         2      -2           0    4.1     -8.2s ← BLOCKED
   18      (8, 9)        -2      -1          -3    6.4     +6.4s
   19     (8, 11)         0       0           0    7.1          
   20     (9, 10)        -5       2          -3    4.9     -9.8s
   21    (10, 11)         0       0           0    6.5          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=4, out=4  OK
  Node 2: in=2, out=2  OK
  Node 3: in=6, out=6  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=3, out=3  OK
  Node 7: in=1, out=1  OK
  Node 8: in=5, out=5  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 11

  Summary:
    Original path length:  37 edges
    Spliced path length:   35 edges
    Splices performed:     11
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)          -4        -4  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           2         2  ✓
    7     (2, 11)          -2        -2  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           2         2  ✓
   10      (3, 8)          -4        -4  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           3         3  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)          -3        -3  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)          -3        -3  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 86
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3] → J=215, T=198, cost=0 → queued

[Iter 1] cost=0, J=215, T=198, edges=35, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3]
  [backtrack] Found solution with 4 backtracks in 0.00s
  [backtrack] Found solution with 3 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 3 backtracks in 0.00s
  [backtrack] Found solution with 4 backtracks in 0.00s
    ✓ Latency-feasible! source=4, T_tour=198.1s
  DFS: latency violated (1 nodes, worst_gap=139.5s)
  Boundary nodes: [0, 1, 2, 4, 5, 7, 10] → expanding 7 children
    V_MIN=[3, 2, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3] → J=206, T=200, cost=1 → queued
    V_MIN=[2, 3, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3] → J=214, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 3] → J=214, T=200, cost=1 → queued
    V_MIN=[2, 2, 1, 3, 3, 2, 2, 2, 3, 2, 2, 3] → J=213, T=198, cost=1 → queued
    V_MIN=[2, 2, 1, 3, 2, 3, 2, 2, 3, 2, 2, 3] → J=214, T=200, cost=1 → queued
    V_MIN=[2, 2, 1, 3, 2, 2, 2, 3, 3, 2, 2, 3] → J=212, T=200, cost=1 → queued
    V_MIN=[2, 2, 1, 3, 2, 2, 2, 2, 3, 2, 3, 3] → J=214, T=200, cost=1 → queued

[Iter 2] cost=1, J=214, T=200, edges=35, frontier=6, MILP_calls=8
  V_MIN=[2, 2, 1, 3, 2, 3, 2, 2, 3, 2, 2, 3]
  [backtrack] Found solution with 74 backtracks in 0.00s
  [backtrack] Found solution with 3 backtracks in 0.00s
  [backtrack] Found solution with 61 backtracks in 0.00s
  [backtrack] Found solution with 59 backtracks in 0.00s
    ✓ Latency-feasible! source=3, T_tour=200.0s
  DFS: latency violated (1 nodes, worst_gap=108.8s)
  Boundary nodes: [0, 1, 2, 3, 4, 5, 7] → expanding 7 children
    V_MIN=[3, 2, 1, 3, 2, 3, 2, 2, 3, 2, 2, 3] → J=204, T=199, cost=2 → queued
    V_MIN=[2, 3, 1, 3, 2, 3, 2, 2, 3, 2, 2, 3] → J=211, T=198, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 2, 2, 3, 2, 2, 3] → J=211, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 4, 2, 3, 2, 2, 3, 2, 2, 3] → J=213, T=198, cost=2 → queued
    V_MIN=[2, 2, 1, 3, 3, 3, 2, 2, 3, 2, 2, 3] → J=213, T=198, cost=2 → queued
    V_MIN=[2, 2, 1, 3, 2, 4, 2, 2, 3, 2, 2, 3] → J=210, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 3, 2, 3, 2, 3, 3, 2, 2, 3] → J=211, T=200, cost=2 → queued

[Iter 3] cost=1, J=214, T=200, edges=35, frontier=12, MILP_calls=15
  V_MIN=[2, 2, 1, 3, 2, 2, 2, 2, 3, 2, 3, 3]
  [backtrack] Found solution with 4 backtracks in 0.00s
  [backtrack] Found solution with 6 backtracks in 0.00s
  [backtrack] Found solution with 6 backtracks in 0.00s
    ✓ Latency-feasible! source=2, T_tour=200.0s
  DFS: latency violated (1 nodes, worst_gap=118.3s)
  Boundary nodes: [0, 1, 2, 3, 4, 7, 10] → expanding 7 children
    V_MIN=[3, 2, 1, 3, 2, 2, 2, 2, 3, 2, 3, 3] → J=206, T=199, cost=2 → queued
    V_MIN=[2, 3, 1, 3, 2, 2, 2, 2, 3, 2, 3, 3] → J=214, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 3, 3] → J=214, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 4, 2, 2, 2, 2, 3, 2, 3, 3] → J=214, T=200, cost=2 → queued
    V_MIN=[2, 2, 1, 3, 3, 2, 2, 2, 3, 2, 3, 3] → J=211, T=199, cost=2 → queued
    V_MIN=[2, 2, 1, 3, 2, 2, 2, 3, 3, 2, 3, 3] → J=212, T=197, cost=2 → queued
    V_MIN=[2, 2, 1, 3, 2, 2, 2, 2, 3, 2, 4, 3] → J=213, T=197, cost=2 → queued

[Iter 4] cost=1, J=214, T=200, edges=36, frontier=18, MILP_calls=22
  V_MIN=[2, 3, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3]
  [backtrack] Found solution with 61 backtracks in 0.00s
  [backtrack] Found solution with 165 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 417 backtracks in 0.00s
  [backtrack] Found solution with 633 backtracks in 0.00s
  [backtrack] Found solution with 662 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (2057 backtracks in 0.00s)
  [backtrack] Found solution with 70 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 1857 backtracks in 0.00s
  [backtrack] Found solution with 3 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=130.4s)
  Boundary nodes: [0, 1, 4, 5, 6, 7] → expanding 6 children
    V_MIN=[3, 3, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3] → J=206, T=200, cost=2 → queued
    V_MIN=[2, 4, 1, 3, 2, 2, 2, 2, 3, 2, 2, 3] → J=213, T=200, cost=2 → queued
    V_MIN=[2, 3, 1, 3, 3, 2, 2, 2, 3, 2, 2, 3] → J=210, T=200, cost=2 → queued
    V_MIN=[2, 3, 1, 3, 2, 2, 3, 2, 3, 2, 2, 3] → J=214, T=199, cost=2 → queued
    V_MIN=[2, 3, 1, 3, 2, 2, 2, 3, 3, 2, 2, 3] → J=212, T=199, cost=2 → queued

[Iter 5] cost=1, J=214, T=200, edges=36, frontier=22, MILP_calls=27
  V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 3]
  [backtrack] Found solution with 61 backtracks in 0.00s
  [backtrack] Found solution with 165 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 417 backtracks in 0.00s
  [backtrack] Found solution with 633 backtracks in 0.00s
  [backtrack] Found solution with 662 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (2057 backtracks in 0.00s)
  [backtrack] Found solution with 70 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 1857 backtracks in 0.00s
  [backtrack] Found solution with 3 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=130.4s)
  Boundary nodes: [0, 2, 4, 5, 6, 7] → expanding 6 children
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 3] → J=206, T=199, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3] → J=211, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 2, 3, 2, 2, 3] → J=210, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 3, 2, 3, 2, 2, 3] → J=212, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 3, 3, 2, 2, 3] → J=211, T=199, cost=2 → queued

[Iter 6] cost=1, J=213, T=198, edges=35, frontier=26, MILP_calls=32
  V_MIN=[2, 2, 1, 3, 3, 2, 2, 2, 3, 2, 2, 3]
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.5s
  *** SOLUTION FOUND! J=213, T_tour=198.5s ***

============================================================
Search done: 6 iters, 32 MILP calls, 32 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 0, -2, 0, 1, -1, 0, -3, 0, 2, -3, -3, 0, -3, 0, -2, 2, 3, -4, 0, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 0, -2, 0, 1, -1, 0, -3, 0, 2, -3, -3, 0, -3, 0, -2, 2, 3, -4, 0, 2]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 3), np.int64(-2)), ((2, 3), np.int64(1)), ((2, 8), np.int64(-1)), ((3, 4), np.int64(-3)), ((3, 8), np.int64(2)), ((4, 5), np.int64(-3)), ((5, 6), np.int64(-3)), ((6, 9), np.int64(-3)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(2)), ((8, 9), np.int64(3)), ((8, 11), np.int64(-4)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=10, edge=(3, 8), flow_B=2  →  need Cm[10]=-2
Blocked edge 2: idx=1, edge=(0, 11), flow_B=2  →  need Cm[1]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=29   ||Cm||_1=21

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, -2, 1, 1, 0, 1, 2, 3, -2, -1, 2]

Cm = C_oriented @ beta*:
  [2, -2, 1, 0, 1, -1, 1, 1, 0, 1, -2, 0, 1, 1, 0, 1, 1, 0, 1, -1, 1, 2]

Original flow_B:
  [-2, 2, 0, -2, 0, 1, -1, 0, -3, 0, 2, -3, -3, 0, -3, 0, -2, 2, 3, -4, 0, 2]

flow_B + Cm (corrected flow):
  [0, 0, 1, -2, 1, 0, 0, 1, -3, 1, 0, -3, -2, 1, -3, 1, -1, 2, 4, -5, 1, 4]

Verification:
  flow_corrected[10] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[1] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 29  (minimized by MIQP)
  ||Cm||_1  = 21
  ||flow_B||_2² = 91
  ||flow_corrected||_2² = 104

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       2           0    7.2    -14.4s
    1     (0, 11)         2      -2           0    7.1    -14.2s ← BLOCKED
    2      (1, 2)         0       1           1    7.3     +7.3s
    3      (1, 3)        -2       0          -2    4.2          
    4      (1, 5)         0       1           1    5.2     +5.2s
    5      (2, 3)         1      -1           0    4.7     -4.7s
    6      (2, 8)        -1       1           0    5.6     -5.6s
    7     (2, 11)         0       1           1    7.6     +7.6s
    8      (3, 4)        -3       0          -3    5.2          
    9      (3, 6)         0       1           1    6.7     +6.7s
   10      (3, 8)         2      -2           0    7.4    -14.8s ← BLOCKED
   11      (4, 5)        -3       0          -3    5.1          
   12      (5, 6)        -3       1          -2    6.1     -6.1s
   13      (6, 7)         0       1           1    6.3     +6.3s
   14      (6, 9)        -3       0          -3    4.6          
   15     (6, 10)         0       1           1    7.0     +7.0s
   16      (7, 8)        -2       1          -1    6.4     -6.4s
   17     (7, 10)         2       0           2    4.2          
   18      (8, 9)         3       1           4    5.4     +5.4s
   19     (8, 11)        -4      -1          -5    6.7     +6.7s
   20     (9, 10)         0       1           1    4.8     +4.8s
   21    (10, 11)         2       2           4    4.6     +9.2s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=2, out=2  OK
  Node 2: in=1, out=1  OK
  Node 3: in=3, out=3  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=4, out=4  OK
  Node 7: in=2, out=2  OK
  Node 8: in=5, out=5  OK
  Node 9: in=4, out=4  OK
  Node 10: in=4, out=4  OK
  Node 11: in=5, out=5  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 18

  Summary:
    Original path length:  35 edges
    Spliced path length:   36 edges
    Splices performed:     18
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           1         1  ✓
    3      (1, 3)          -2        -2  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           1         1  ✓
    8      (3, 4)          -3        -3  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)          -3        -3  ✓
   12      (5, 6)          -2        -2  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)          -3        -3  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)           4         4  ✓
   19     (8, 11)          -5        -5  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)           4         4  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 87
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 2, 2, 2] → J=287, T=199, cost=0 → queued

[Iter 1] cost=0, J=287, T=199, edges=41, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (708 backtracks in 0.00s)
  [backtrack] Found solution with 870 backtracks in 0.00s
  [backtrack] Found solution with 856 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (561 backtracks in 0.00s)
  [backtrack] Found solution with 426 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (973 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (336 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (516 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (246 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (314 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (321 backtracks in 0.00s)
  [backtrack] Found solution with 864 backtracks in 0.00s
  DFS: latency violated (4 nodes, worst_gap=180.4s)
  Boundary nodes: [0, 4, 5, 9, 10] → expanding 5 children
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 3, 2, 2, 2] → J=285, T=200, cost=1 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 3, 2, 2, 2] → J=284, T=199, cost=1 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 2, 3, 2, 2, 2] → J=282, T=200, cost=1 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 3, 2, 2] → J=285, T=200, cost=1 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 2, 3, 2] → J=285, T=200, cost=1 → queued

[Iter 2] cost=1, J=285, T=200, edges=40, frontier=4, MILP_calls=6
  V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 3, 2, 2]
  [backtrack] EXHAUSTED search space (705 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1394 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (335 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (750 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (982 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1020 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (368 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (520 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (226 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (455 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (462 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (624 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 8, 9] → expanding 5 children
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 3, 3, 2, 2] → J=273, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 3, 3, 2, 2] → J=283, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 2, 3, 3, 2, 2] → J=276, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 4, 3, 2, 2] → J=284, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 4, 2, 2] → J=277, T=196, cost=2 → queued

[Iter 3] cost=1, J=285, T=200, edges=40, frontier=8, MILP_calls=11
  V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 2, 3, 2]
  [backtrack] EXHAUSTED search space (577 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (868 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1319 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (997 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (772 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (345 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (818 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (363 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (375 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (623 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (489 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (941 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 8, 10] → expanding 5 children
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 3, 2, 3, 2] → J=271, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 3, 2, 3, 2] → J=281, T=198, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 2, 3, 2, 3, 2] → J=276, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 4, 2, 3, 2] → J=279, T=195, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 2, 4, 2] → J=273, T=199, cost=2 → queued

[Iter 4] cost=1, J=285, T=200, edges=40, frontier=12, MILP_calls=16
  V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (652 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (555 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1026 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (619 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (526 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (259 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (144 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (194 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (645 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (307 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (254 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (813 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[4, 3, 3, 1, 2, 3, 2, 2, 3, 2, 2, 2] → J=276, T=200, cost=2 → queued
    V_MIN=[3, 3, 3, 1, 3, 3, 2, 2, 3, 2, 2, 2] → J=284, T=199, cost=2 → queued
    V_MIN=[3, 3, 3, 1, 2, 4, 2, 2, 3, 2, 2, 2] → J=273, T=200, cost=2 → queued
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 3, 3, 2, 2, 2] → J=282, T=199, cost=2 → queued
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 4, 2, 2, 2] → J=276, T=200, cost=2 → queued

[Iter 5] cost=1, J=284, T=199, edges=41, frontier=16, MILP_calls=21
  V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 3, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [4, 5, 6, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[2, 3, 3, 1, 4, 3, 2, 2, 3, 2, 2, 2] → J=269, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 3, 4, 2, 2, 3, 2, 2, 2] → J=282, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 3, 2, 3, 2, 2, 2] → J=283, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 2, 3, 3, 2, 2, 2] → J=283, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 4, 2, 2, 2] → J=283, T=200, cost=2 → queued

[Iter 6] cost=1, J=282, T=200, edges=40, frontier=20, MILP_calls=26
  V_MIN=[2, 3, 3, 1, 2, 4, 2, 2, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (443 backtracks in 0.00s)
  [backtrack] Found solution with 268 backtracks in 0.00s
  [backtrack] Found solution with 214 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (511 backtracks in 0.00s)
  [backtrack] Found solution with 129 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (158 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (230 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (147 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (590 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (254 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (263 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (833 backtracks in 0.00s)
  DFS: latency violated (4 nodes, worst_gap=180.9s)
  Boundary nodes: [0, 5, 6, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[2, 3, 3, 1, 2, 5, 2, 2, 3, 2, 2, 2] → J=279, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 3, 2, 3, 2, 2, 2] → J=281, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 3, 3, 2, 2, 2] → J=281, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 2, 4, 2, 2, 2] → J=279, T=200, cost=2 → queued

[Iter 7] cost=2, J=284, T=200, edges=40, frontier=23, MILP_calls=30
  V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 4, 3, 2, 2]
  [backtrack] EXHAUSTED search space (649 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1099 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1452 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (561 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (843 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (887 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (280 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (309 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (393 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (405 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (322 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1054 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 4, 3, 2, 2] → J=272, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 4, 3, 2, 2] → J=283, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 2, 4, 3, 2, 2] → J=276, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 3, 4, 3, 2, 2] → J=283, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 5, 3, 2, 2] → J=276, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 4, 4, 2, 2] → J=274, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 4, 3, 3, 2] → J=279, T=196, cost=3 → queued

[Iter 8] cost=2, J=284, T=199, edges=41, frontier=29, MILP_calls=37
  V_MIN=[3, 3, 3, 1, 3, 3, 2, 2, 3, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[4, 3, 3, 1, 3, 3, 2, 2, 3, 2, 2, 2] → J=276, T=200, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 4, 3, 2, 2, 3, 2, 2, 2] → J=264, T=199, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 3, 4, 2, 2, 3, 2, 2, 2] → J=266, T=199, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 3, 3, 3, 2, 3, 2, 2, 2] → J=274, T=197, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 3, 3, 2, 3, 3, 2, 2, 2] → J=274, T=197, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 3, 3, 2, 2, 4, 2, 2, 2] → J=270, T=199, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 3, 3, 2, 2, 3, 3, 2, 2] → J=273, T=199, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 3, 3, 2, 2, 3, 2, 3, 2] → J=268, T=200, cost=3 → queued

[Iter 9] cost=2, J=283, T=200, edges=41, frontier=36, MILP_calls=45
  V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 3, 3, 2, 2]
  [backtrack] EXHAUSTED search space (168 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (346 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (348 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (171 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (234 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (236 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (195 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (73 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (94 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (105 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (227 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 9, 10] → expanding 5 children
    V_MIN=[2, 3, 3, 1, 4, 3, 2, 2, 3, 3, 2, 2] → J=264, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 4, 2, 2, 3, 3, 2, 2] → J=271, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 3, 4, 2, 2] → J=272, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 3, 3, 3, 2] → J=281, T=198, cost=3 → queued

[Iter 10] cost=2, J=283, T=200, edges=41, frontier=39, MILP_calls=49
  V_MIN=[2, 3, 3, 1, 3, 3, 3, 2, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (168 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (277 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (348 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (171 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (234 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (236 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (195 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (94 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (73 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (164 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (108 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (227 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 6, 10] → expanding 5 children
    V_MIN=[2, 3, 3, 1, 4, 3, 3, 2, 3, 2, 2, 2] → J=268, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 4, 3, 2, 3, 2, 2, 2] → J=271, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 4, 2, 3, 2, 2, 2] → J=281, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 3, 2, 3, 2, 3, 2] → J=281, T=198, cost=3 → queued

[Iter 11] cost=2, J=283, T=200, edges=41, frontier=42, MILP_calls=53
  V_MIN=[2, 3, 3, 1, 3, 3, 2, 3, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (168 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (346 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (348 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (171 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (234 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (236 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (195 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (150 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (73 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (94 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (105 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (227 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 10] → expanding 5 children
    V_MIN=[2, 3, 3, 1, 4, 3, 2, 3, 3, 2, 2, 2] → J=268, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 4, 2, 3, 3, 2, 2, 2] → J=274, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 2, 4, 3, 2, 2, 2] → J=281, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 2, 3, 3, 2, 3, 2] → J=281, T=198, cost=3 → queued

[Iter 12] cost=2, J=283, T=200, edges=41, frontier=45, MILP_calls=57
  V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 4, 2, 2, 2]
  [backtrack] EXHAUSTED search space (142 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (177 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (309 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (277 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (249 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (198 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (224 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (186 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (94 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (116 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (128 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (225 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 8, 10] → expanding 5 children
    V_MIN=[2, 3, 3, 1, 4, 3, 2, 2, 4, 2, 2, 2] → J=269, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 4, 2, 2, 4, 2, 2, 2] → J=274, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 5, 2, 2, 2] → J=274, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 4, 2, 3, 2] → J=278, T=200, cost=3 → queued

[Iter 13] cost=2, J=282, T=199, edges=39, frontier=48, MILP_calls=61
  V_MIN=[3, 3, 3, 1, 2, 3, 2, 3, 3, 2, 2, 2]
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 376 backtracks in 0.00s
  [backtrack] Found solution with 292 backtracks in 0.00s
  [backtrack] Found solution with 166 backtracks in 0.00s
  [backtrack] Found solution with 153 backtracks in 0.00s
  [backtrack] Found solution with 412 backtracks in 0.00s
  [backtrack] Found solution with 504 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1488 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (477 backtracks in 0.00s)
  [backtrack] Found solution with 924 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1114 backtracks in 0.00s)
  [backtrack] Found solution with 289 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=93.2s)
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[4, 3, 3, 1, 2, 3, 2, 3, 3, 2, 2, 2] → J=275, T=200, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 2, 4, 2, 3, 3, 2, 2, 2] → J=273, T=200, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 2, 3, 3, 3, 3, 2, 2, 2] → J=275, T=200, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 4, 3, 2, 2, 2] → J=273, T=199, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 3, 4, 2, 2, 2] → J=275, T=200, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 3, 3, 3, 2, 2] → J=273, T=200, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 3, 3, 2, 3, 2] → J=271, T=200, cost=3 → queued

[Iter 14] cost=2, J=282, T=200, edges=40, frontier=54, MILP_calls=68
  V_MIN=[2, 3, 3, 1, 3, 4, 2, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 379 backtracks in 0.00s
  [backtrack] Found solution with 148 backtracks in 0.00s
  [backtrack] Found solution with 97 backtracks in 0.00s
  [backtrack] Found solution with 141 backtracks in 0.00s
  [backtrack] Found solution with 109 backtracks in 0.00s
  [backtrack] Found solution with 130 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (327 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (194 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (133 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (321 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (264 backtracks in 0.00s)
  [backtrack] Found solution with 322 backtracks in 0.00s
  DFS: latency violated (4 nodes, worst_gap=180.9s)
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[2, 3, 3, 1, 4, 4, 2, 2, 3, 2, 2, 2] → J=269, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 5, 2, 2, 3, 2, 2, 2] → J=274, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 4, 2, 2, 3, 2, 3, 2] → J=271, T=200, cost=3 → queued

[Iter 15] cost=2, J=281, T=198, edges=41, frontier=56, MILP_calls=71
  V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 3, 2, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 8, 10] → expanding 5 children
    V_MIN=[2, 3, 3, 1, 4, 3, 2, 2, 3, 2, 3, 2] → J=264, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 3, 3, 2, 2, 3, 2, 4, 2] → J=265, T=198, cost=3 → queued

[Iter 16] cost=2, J=281, T=199, edges=39, frontier=57, MILP_calls=73
  V_MIN=[2, 3, 3, 1, 2, 4, 3, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 279 backtracks in 0.00s
  [backtrack] Found solution with 391 backtracks in 0.00s
  [backtrack] Found solution with 339 backtracks in 0.00s
  [backtrack] Found solution with 16 backtracks in 0.00s
  [backtrack] Found solution with 38 backtracks in 0.00s
  [backtrack] Found solution with 137 backtracks in 0.00s
  [backtrack] Found solution with 224 backtracks in 0.00s
  [backtrack] Found solution with 233 backtracks in 0.00s
  [backtrack] Found solution with 55 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (757 backtracks in 0.00s)
  [backtrack] Found solution with 145 backtracks in 0.00s
  [backtrack] Found solution with 303 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=90.0s)
  Boundary nodes: [0, 4, 5, 6, 8, 9, 10] → expanding 7 children
    V_MIN=[3, 3, 3, 1, 2, 4, 3, 2, 3, 2, 2, 2] → J=273, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 5, 3, 2, 3, 2, 2, 2] → J=279, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 4, 2, 3, 2, 2, 2] → J=279, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 3, 2, 4, 2, 2, 2] → J=279, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 3, 2, 3, 3, 2, 2] → J=276, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 3, 2, 3, 2, 3, 2] → J=276, T=199, cost=3 → queued

[Iter 17] cost=2, J=281, T=199, edges=39, frontier=62, MILP_calls=79
  V_MIN=[2, 3, 3, 1, 2, 4, 2, 3, 3, 2, 2, 2]
  [backtrack] Found solution with 264 backtracks in 0.00s
  [backtrack] Found solution with 152 backtracks in 0.00s
  [backtrack] Found solution with 157 backtracks in 0.00s
  [backtrack] Found solution with 13 backtracks in 0.00s
  [backtrack] Found solution with 678 backtracks in 0.00s
  [backtrack] Found solution with 15 backtracks in 0.00s
  [backtrack] Found solution with 1057 backtracks in 0.00s
  [backtrack] Found solution with 970 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (380 backtracks in 0.00s)
  [backtrack] Found solution with 278 backtracks in 0.00s
  [backtrack] Found solution with 648 backtracks in 0.00s
  [backtrack] Found solution with 565 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=90.0s)
  Boundary nodes: [0, 4, 5, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[2, 3, 3, 1, 2, 5, 2, 3, 3, 2, 2, 2] → J=279, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 4, 3, 2, 2, 2] → J=279, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 3, 4, 2, 2, 2] → J=279, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 3, 3, 3, 2, 2] → J=276, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 3, 3, 2, 3, 2] → J=276, T=200, cost=3 → queued

[Iter 18] cost=2, J=279, T=199, edges=39, frontier=66, MILP_calls=84
  V_MIN=[2, 3, 3, 1, 2, 5, 2, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 303 backtracks in 0.00s
  [backtrack] Found solution with 302 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (360 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (262 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (261 backtracks in 0.00s)
  [backtrack] Found solution with 312 backtracks in 0.00s
  [backtrack] Found solution with 249 backtracks in 0.00s
  [backtrack] Found solution with 281 backtracks in 0.00s
  [backtrack] Found solution with 292 backtracks in 0.00s
  [backtrack] Found solution with 222 backtracks in 0.00s
  [backtrack] Found solution with 161 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (122 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=81.6s)
  Boundary nodes: [0, 2, 4, 5, 8, 9, 10] → expanding 7 children
    V_MIN=[3, 3, 3, 1, 2, 5, 2, 2, 3, 2, 2, 2] → J=273, T=200, cost=3 → queued
    V_MIN=[2, 3, 4, 1, 2, 5, 2, 2, 3, 2, 2, 2] → J=275, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 6, 2, 2, 3, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 3, 3, 1, 2, 5, 2, 2, 4, 2, 2, 2] → J=279, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 5, 2, 2, 3, 3, 2, 2] → J=271, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 5, 2, 2, 3, 2, 3, 2] → J=271, T=200, cost=3 → queued

[Iter 19] cost=2, J=279, T=195, edges=39, frontier=70, MILP_calls=90
  V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 4, 2, 3, 2]
  [backtrack] Found solution with 109 backtracks in 0.00s
  [backtrack] Found solution with 24 backtracks in 0.00s
  [backtrack] Found solution with 72 backtracks in 0.00s
  [backtrack] Found solution with 90 backtracks in 0.00s
  [backtrack] Found solution with 97 backtracks in 0.00s
  [backtrack] Found solution with 98 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (307 backtracks in 0.00s)
  [backtrack] Found solution with 119 backtracks in 0.00s
  [backtrack] Found solution with 119 backtracks in 0.00s
  [backtrack] Found solution with 244 backtracks in 0.00s
  [backtrack] Found solution with 203 backtracks in 0.00s
  [backtrack] Found solution with 74 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=94.7s)
  Boundary nodes: [0, 4, 5, 6, 8, 10] → expanding 6 children
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 4, 2, 3, 2] → J=268, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 2, 4, 2, 3, 2] → J=276, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 3, 2, 4, 2, 3, 2] → J=276, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 5, 2, 3, 2] → J=276, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 4, 2, 4, 2] → J=273, T=200, cost=3 → queued

[Iter 20] cost=2, J=279, T=200, edges=39, frontier=74, MILP_calls=95
  V_MIN=[2, 3, 3, 1, 2, 4, 2, 2, 4, 2, 2, 2]
  [backtrack] Found solution with 15 backtracks in 0.00s
  [backtrack] Found solution with 277 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (671 backtracks in 0.00s)
  [backtrack] Found solution with 223 backtracks in 0.00s
  [backtrack] Found solution with 230 backtracks in 0.00s
  [backtrack] Found solution with 247 backtracks in 0.00s
  [backtrack] Found solution with 158 backtracks in 0.00s
  [backtrack] Found solution with 34 backtracks in 0.00s
  [backtrack] Found solution with 339 backtracks in 0.00s
  [backtrack] Found solution with 193 backtracks in 0.00s
  [backtrack] Found solution with 1042 backtracks in 0.00s
  [backtrack] Found solution with 297 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=125.4s)
  Boundary nodes: [0, 2, 4, 8, 9, 10] → expanding 6 children
    V_MIN=[3, 3, 3, 1, 2, 4, 2, 2, 4, 2, 2, 2] → J=273, T=200, cost=3 → queued
    V_MIN=[2, 3, 4, 1, 2, 4, 2, 2, 4, 2, 2, 2] → J=275, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 2, 5, 2, 2, 2] → J=279, T=200, cost=3 → queued

[Iter 21] cost=2, J=277, T=196, edges=39, frontier=76, MILP_calls=98
  V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 4, 2, 2]
  [backtrack] Found solution with 112 backtracks in 0.00s
  [backtrack] Found solution with 275 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=196.4s
  DFS: latency violated (1 nodes, worst_gap=103.1s)
  Boundary nodes: [0, 4, 5, 8, 9, 10] → expanding 6 children
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 3, 4, 2, 2] → J=270, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 2, 3, 4, 2, 2] → J=274, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 5, 2, 2] → J=269, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 4, 3, 2] → J=273, T=200, cost=3 → queued

[Iter 22] cost=2, J=276, T=200, edges=37, frontier=79, MILP_calls=102
  V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 4, 2, 2, 2]
  [backtrack] Found solution with 314 backtracks in 0.00s
  [backtrack] Found solution with 340 backtracks in 0.00s
  [backtrack] Found solution with 342 backtracks in 0.00s
  [backtrack] Found solution with 431 backtracks in 0.00s
  [backtrack] Found solution with 294 backtracks in 0.00s
  [backtrack] Found solution with 315 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (310 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (270 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (184 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (347 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (283 backtracks in 0.00s)
  [backtrack] Found solution with 232 backtracks in 0.00s
  DFS: latency violated (4 nodes, worst_gap=181.1s)
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[4, 3, 3, 1, 2, 3, 2, 2, 4, 2, 2, 2] → J=275, T=200, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 2, 3, 3, 2, 4, 2, 2, 2] → J=275, T=200, cost=3 → queued
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 5, 2, 2, 2] → J=272, T=200, cost=3 → queued

[Iter 23] cost=2, J=276, T=199, edges=40, frontier=81, MILP_calls=105
  V_MIN=[2, 3, 3, 1, 2, 4, 2, 2, 3, 3, 2, 2]
  [backtrack] Found solution with 214 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (624 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (774 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (227 backtracks in 0.00s)
  [backtrack] Found solution with 154 backtracks in 0.00s
  [backtrack] Found solution with 773 backtracks in 0.00s
  [backtrack] Found solution with 542 backtracks in 0.00s
  [backtrack] Found solution with 319 backtracks in 0.00s
  [backtrack] Found solution with 364 backtracks in 0.00s
  [backtrack] Found solution with 539 backtracks in 0.00s
  [backtrack] Found solution with 448 backtracks in 0.00s
  [backtrack] Found solution with 360 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=100.0s)
  Boundary nodes: [0, 2, 4, 5, 9] → expanding 5 children
    V_MIN=[3, 3, 3, 1, 2, 4, 2, 2, 3, 3, 2, 2] → J=268, T=198, cost=3 → queued
    V_MIN=[2, 3, 4, 1, 2, 4, 2, 2, 3, 3, 2, 2] → J=276, T=200, cost=3 → queued

[Iter 24] cost=2, J=276, T=200, edges=40, frontier=82, MILP_calls=107
  V_MIN=[2, 3, 3, 1, 2, 4, 2, 2, 3, 2, 3, 2]
  [backtrack] Found solution with 186 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (529 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (774 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (227 backtracks in 0.00s)
  [backtrack] Found solution with 154 backtracks in 0.00s
  [backtrack] Found solution with 650 backtracks in 0.00s
  [backtrack] Found solution with 540 backtracks in 0.00s
  [backtrack] Found solution with 486 backtracks in 0.00s
  [backtrack] Found solution with 364 backtracks in 0.00s
  [backtrack] Found solution with 317 backtracks in 0.00s
  [backtrack] Found solution with 395 backtracks in 0.00s
  [backtrack] Found solution with 289 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=100.5s)
  Boundary nodes: [0, 2, 4, 5, 10] → expanding 5 children
    V_MIN=[3, 3, 3, 1, 2, 4, 2, 2, 3, 2, 3, 2] → J=268, T=198, cost=3 → queued
    V_MIN=[2, 3, 4, 1, 2, 4, 2, 2, 3, 2, 3, 2] → J=271, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 4, 2, 2, 3, 2, 4, 2] → J=271, T=200, cost=3 → queued

[Iter 25] cost=2, J=276, T=200, edges=41, frontier=84, MILP_calls=110
  V_MIN=[4, 3, 3, 1, 2, 3, 2, 2, 3, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [2, 5, 6, 7, 8, 9, 10] → expanding 7 children
    V_MIN=[4, 3, 4, 1, 2, 3, 2, 2, 3, 2, 2, 2] → J=273, T=200, cost=3 → queued
    V_MIN=[4, 3, 3, 1, 2, 4, 2, 2, 3, 2, 2, 2] → J=269, T=200, cost=3 → queued
    V_MIN=[4, 3, 3, 1, 2, 3, 3, 2, 3, 2, 2, 2] → J=275, T=200, cost=3 → queued
    V_MIN=[4, 3, 3, 1, 2, 3, 2, 2, 3, 3, 2, 2] → J=273, T=200, cost=3 → queued
    V_MIN=[4, 3, 3, 1, 2, 3, 2, 2, 3, 2, 3, 2] → J=271, T=198, cost=3 → queued

[Iter 26] cost=2, J=273, T=199, edges=40, frontier=88, MILP_calls=115
  V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 3, 3, 2, 2]
  [backtrack] EXHAUSTED search space (103 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (79 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (131 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (151 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (84 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (60 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (75 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (58 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (119 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (78 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (118 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 5, 7, 8, 9, 10] → expanding 6 children
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 3, 3, 3, 2] → J=271, T=200, cost=3 → queued

[Iter 27] cost=2, J=273, T=199, edges=38, frontier=88, MILP_calls=116
  V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 2, 4, 2]
  [backtrack] EXHAUSTED search space (622 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (849 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (291 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (579 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (658 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (857 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (254 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (397 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (259 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (156 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (475 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (97 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 6, 8, 10] → expanding 6 children
    V_MIN=[3, 3, 3, 1, 2, 3, 2, 2, 3, 2, 4, 2] → J=267, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 3, 2, 3, 2, 4, 2] → J=273, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 1, 2, 3, 2, 2, 3, 2, 5, 2] → J=269, T=200, cost=3 → queued

[Iter 28] cost=2, J=273, T=200, edges=38, frontier=90, MILP_calls=119
  V_MIN=[3, 3, 3, 1, 2, 4, 2, 2, 3, 2, 2, 2]
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 98 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=199.9s
  *** SOLUTION FOUND! J=273, T_tour=199.9s ***

============================================================
Search done: 28 iters, 119 MILP calls, 119 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, 2, 0, -5, 2, -1, 1, 2, 0, 0, 2, -3, -1, -2, 0, -3, 2, 0, -4, -2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, 2, 0, -5, 2, -1, 1, 2, 0, 0, 2, -3, -1, -2, 0, -3, 2, 0, -4, -2, 0]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 2), np.int64(2)), ((1, 5), np.int64(-5)), ((2, 3), np.int64(2)), ((2, 8), np.int64(-1)), ((2, 11), np.int64(1)), ((3, 4), np.int64(2)), ((4, 5), np.int64(2)), ((5, 6), np.int64(-3)), ((6, 7), np.int64(-1)), ((6, 9), np.int64(-2)), ((7, 8), np.int64(-3)), ((7, 10), np.int64(2)), ((8, 11), np.int64(-4)), ((9, 10), np.int64(-2))]

Blocked edge 1: idx=1, edge=(0, 11), flow_B=3  →  need Cm[1]=-3
Blocked edge 2: idx=14, edge=(6, 9), flow_B=-2  →  need Cm[14]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=40   ||Cm||_1=22

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-3, -1, 2, 0, 2, 1, 3, 0, -1, -1, 2]

Cm = C_oriented @ beta*:
  [3, -3, 0, 2, 1, -1, 0, 1, 0, 1, 0, 0, 1, -1, 2, 1, -1, 0, -2, 1, 0, 1]

Original flow_B:
  [-3, 3, 2, 0, -5, 2, -1, 1, 2, 0, 0, 2, -3, -1, -2, 0, -3, 2, 0, -4, -2, 0]

flow_B + Cm (corrected flow):
  [0, 0, 2, 2, -4, 1, -1, 2, 2, 1, 0, 2, -2, -2, 0, 1, -4, 2, -2, -3, -2, 1]

Verification:
  flow_corrected[1] = 0  (should be 0, Cm=-3, d=-3)
  flow_corrected[14] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 40  (minimized by MIQP)
  ||Cm||_1  = 22
  ||flow_B||_2² = 108
  ||flow_corrected||_2² = 86

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       3           0    4.7    -14.1s
    1     (0, 11)         3      -3           0    5.4    -16.2s ← BLOCKED
    2      (1, 2)         2       0           2    5.6          
    3      (1, 3)         0       2           2    7.0    +14.0s
    4      (1, 5)        -5       1          -4    5.1     -5.1s
    5      (2, 3)         2      -1           1    5.1     -5.1s
    6      (2, 8)        -1       0          -1    7.9          
    7     (2, 11)         1       1           2    4.2     +4.2s
    8      (3, 4)         2       0           2    5.7          
    9      (3, 6)         0       1           1    5.4     +5.4s
   10      (3, 8)         0       0           0    4.4          
   11      (4, 5)         2       0           2    4.8          
   12      (5, 6)        -3       1          -2    7.8     -7.8s
   13      (6, 7)        -1      -1          -2    4.0     +4.0s
   14      (6, 9)        -2       2           0    4.7     -9.4s ← BLOCKED
   15     (6, 10)         0       1           1    7.9     +7.9s
   16      (7, 8)        -3      -1          -4    5.4     +5.4s
   17     (7, 10)         2       0           2    5.3          
   18      (8, 9)         0      -2          -2    6.6    +13.2s
   19     (8, 11)        -4       1          -3    4.1     -4.1s
   20     (9, 10)        -2       0          -2    4.8          
   21    (10, 11)         0       1           1    7.8     +7.8s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=4, out=4  OK
  Node 2: in=3, out=3  OK
  Node 3: in=3, out=3  OK
  Node 4: in=2, out=2  OK
  Node 5: in=4, out=4  OK
  Node 6: in=3, out=3  OK
  Node 7: in=4, out=4  OK
  Node 8: in=5, out=5  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 19

  Summary:
    Original path length:  38 edges
    Spliced path length:   36 edges
    Splices performed:     19
    Path is continuous:    True
    Returns to source 1: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           2         2  ✓
    3      (1, 3)           2         2  ✓
    4      (1, 5)          -4        -4  ✓
    5      (2, 3)           1         1  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           2         2  ✓
    8      (3, 4)           2         2  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           2         2  ✓
   12      (5, 6)          -2        -2  ✓
   13      (6, 7)          -2        -2  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)          -4        -4  ✓
   17     (7, 10)           2         2  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)          -3        -3  ✓
   20     (9, 10)          -2        -2  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 88
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 1] → J=230, T=200, cost=0 → queued

[Iter 1] cost=0, J=230, T=200, edges=35, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] Found solution with 123 backtracks in 0.00s
  [backtrack] Found solution with 174 backtracks in 0.00s
  [backtrack] Found solution with 211 backtracks in 0.00s
  [backtrack] Found solution with 214 backtracks in 0.00s
  [backtrack] Found solution with 386 backtracks in 0.00s
    ✓ Latency-feasible! source=4, T_tour=200.0s
  DFS: latency violated (1 nodes, worst_gap=121.4s)
  Boundary nodes: [0, 1, 2, 4, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 1] → J=218, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 3, 1] → J=225, T=200, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 1] → J=223, T=197, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 3, 1] → J=227, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 1] → J=224, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 3, 1] → J=220, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 3, 1] → J=228, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 1] → J=223, T=199, cost=1 → queued

[Iter 2] cost=1, J=228, T=199, edges=35, frontier=7, MILP_calls=9
  V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 3, 1]
  [backtrack] Found solution with 498 backtracks in 0.00s
  [backtrack] Found solution with 426 backtracks in 0.00s
  [backtrack] Found solution with 145 backtracks in 0.00s
  [backtrack] Found solution with 227 backtracks in 0.00s
  [backtrack] Found solution with 510 backtracks in 0.00s
  [backtrack] Found solution with 411 backtracks in 0.00s
  [backtrack] Found solution with 204 backtracks in 0.00s
  [backtrack] Found solution with 64 backtracks in 0.00s
  [backtrack] Found solution with 187 backtracks in 0.00s
  [backtrack] Found solution with 88 backtracks in 0.00s
  [backtrack] Found solution with 312 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (622 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=84.0s)
  Boundary nodes: [0, 1, 2, 4, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 2, 2, 3, 3, 1] → J=216, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 3, 3, 1] → J=219, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 2, 2, 3, 3, 1] → J=220, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 2, 2, 3, 3, 1] → J=224, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 3, 2, 3, 3, 1] → J=220, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 3, 3, 3, 1] → J=220, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 4, 3, 1] → J=224, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 4, 1] → J=217, T=199, cost=2 → queued

[Iter 3] cost=1, J=227, T=199, edges=35, frontier=14, MILP_calls=17
  V_MIN=[2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] Found solution with 134 backtracks in 0.00s
  [backtrack] Found solution with 134 backtracks in 0.00s
  [backtrack] Found solution with 173 backtracks in 0.00s
  [backtrack] Found solution with 280 backtracks in 0.00s
  [backtrack] Found solution with 274 backtracks in 0.00s
  [backtrack] Found solution with 94 backtracks in 0.00s
  [backtrack] Found solution with 92 backtracks in 0.00s
  [backtrack] Found solution with 102 backtracks in 0.00s
  [backtrack] Found solution with 173 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (225 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (447 backtracks in 0.00s)
  [backtrack] Found solution with 134 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=83.8s)
  Boundary nodes: [0, 1, 2, 3, 4, 7, 8, 9, 10] → expanding 9 children
    V_MIN=[3, 2, 2, 3, 3, 2, 2, 2, 2, 2, 3, 1] → J=214, T=198, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 3, 1] → J=221, T=198, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 3, 1] → J=221, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 4, 3, 2, 2, 2, 2, 2, 3, 1] → J=224, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 4, 2, 2, 2, 2, 2, 3, 1] → J=222, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 3, 2, 2, 3, 1] → J=222, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 2, 3, 2, 3, 1] → J=220, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 4, 1] → J=221, T=199, cost=2 → queued

[Iter 4] cost=1, J=225, T=200, edges=35, frontier=21, MILP_calls=25
  V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 3, 1]
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 860 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1466 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2959 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2633 backtracks in 0.01s)
  [backtrack] Found solution with 771 backtracks in 0.00s
  [backtrack] Found solution with 1791 backtracks in 0.00s
  [backtrack] Found solution with 518 backtracks in 0.00s
  [backtrack] Found solution with 17 backtracks in 0.00s
  [backtrack] Found solution with 1429 backtracks in 0.00s
  [backtrack] Found solution with 2570 backtracks in 0.01s
  [backtrack] Found solution with 952 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=109.8s)
  Boundary nodes: [0, 1, 2, 3, 4, 7, 8, 9, 10] → expanding 9 children
    V_MIN=[3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 3, 1] → J=218, T=200, cost=2 → queued
    V_MIN=[2, 4, 2, 3, 2, 2, 2, 2, 2, 2, 3, 1] → J=219, T=199, cost=2 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 1] → J=221, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 4, 2, 2, 2, 2, 2, 2, 3, 1] → J=221, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 3, 2, 2, 3, 1] → J=221, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 3, 2, 3, 1] → J=218, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 4, 1] → J=215, T=200, cost=2 → queued

[Iter 5] cost=1, J=224, T=199, edges=35, frontier=27, MILP_calls=32
  V_MIN=[2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 1]
  [backtrack] Found solution with 3 backtracks in 0.00s
  [backtrack] Found solution with 4 backtracks in 0.00s
  [backtrack] Found solution with 120 backtracks in 0.00s
  [backtrack] Found solution with 66 backtracks in 0.00s
  [backtrack] Found solution with 211 backtracks in 0.00s
  [backtrack] Found solution with 5 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 122 backtracks in 0.00s
  [backtrack] Found solution with 125 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (435 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=89.1s)
  Boundary nodes: [0, 1, 2, 4, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 1] → J=210, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 3, 2, 2, 3, 1] → J=217, T=197, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 4, 2, 2, 3, 1] → J=211, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 3, 3, 2, 3, 1] → J=215, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 4, 1] → J=213, T=197, cost=2 → queued

[Iter 6] cost=1, J=223, T=199, edges=34, frontier=31, MILP_calls=37
  V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 1]
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=199.4s
  *** SOLUTION FOUND! J=223, T_tour=199.4s ***

============================================================
Search done: 6 iters, 37 MILP calls, 37 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 0, 0, -2, 2, -2, 0, -2, 4, 0, -2, -4, -2, 0, 2, 0, -2, -2, 0, -2, -2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 0, 0, -2, 2, -2, 0, -2, 4, 0, -2, -4, -2, 0, 2, 0, -2, -2, 0, -2, -2]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 5), np.int64(-2)), ((2, 3), np.int64(2)), ((2, 8), np.int64(-2)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(4)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-4)), ((6, 7), np.int64(-2)), ((6, 10), np.int64(2)), ((7, 10), np.int64(-2)), ((8, 9), np.int64(-2)), ((9, 10), np.int64(-2)), ((10, 11), np.int64(-2))]

Blocked edge 1: idx=15, edge=(6, 10), flow_B=2  →  need Cm[15]=-2
Blocked edge 2: idx=1, edge=(0, 11), flow_B=2  →  need Cm[1]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=28   ||Cm||_1=20

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-2, 1, 1, 1, 1, 0, 2, 0, 1, -1, 0]

Cm = C_oriented @ beta*:
  [2, -2, 0, 1, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, 1, -2, 1, 0, 0, 2, 1, -1]

Original flow_B:
  [-2, 2, 0, 0, -2, 2, -2, 0, -2, 4, 0, -2, -4, -2, 0, 2, 0, -2, -2, 0, -2, -2]

flow_B + Cm (corrected flow):
  [0, 0, 0, 1, -1, 1, -2, 1, -3, 4, 1, -3, -4, -1, 1, 0, 1, -2, -2, 2, -1, -3]

Verification:
  flow_corrected[15] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[1] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 28  (minimized by MIQP)
  ||Cm||_1  = 20
  ||flow_B||_2² = 84
  ||flow_corrected||_2² = 84

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2       2           0    4.4     -8.8s
    1     (0, 11)         2      -2           0    7.4    -14.8s ← BLOCKED
    2      (1, 2)         0       0           0    5.9          
    3      (1, 3)         0       1           1    7.5     +7.5s
    4      (1, 5)        -2       1          -1    5.2     -5.2s
    5      (2, 3)         2      -1           1    5.6     -5.6s
    6      (2, 8)        -2       0          -2    6.3          
    7     (2, 11)         0       1           1    4.5     +4.5s
    8      (3, 4)        -2      -1          -3    7.1     +7.1s
    9      (3, 6)         4       0           4    5.3          
   10      (3, 8)         0       1           1    6.6     +6.6s
   11      (4, 5)        -2      -1          -3    4.1     +4.1s
   12      (5, 6)        -4       0          -4    4.7          
   13      (6, 7)        -2       1          -1    5.7     -5.7s
   14      (6, 9)         0       1           1    4.9     +4.9s
   15     (6, 10)         2      -2           0    7.9    -15.8s ← BLOCKED
   16      (7, 8)         0       1           1    7.6     +7.6s
   17     (7, 10)        -2       0          -2    7.5          
   18      (8, 9)        -2       0          -2    4.1          
   19     (8, 11)         0       2           2    7.2    +14.4s
   20     (9, 10)        -2       1          -1    7.6     -7.6s
   21    (10, 11)        -2      -1          -3    6.8     +6.8s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=1, out=1  OK
  Node 2: in=2, out=2  OK
  Node 3: in=5, out=5  OK
  Node 4: in=3, out=3  OK
  Node 5: in=4, out=4  OK
  Node 6: in=5, out=5  OK
  Node 7: in=2, out=2  OK
  Node 8: in=4, out=4  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 34 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 23

  Summary:
    Original path length:  34 edges
    Spliced path length:   34 edges
    Splices performed:     23
    Path is continuous:    True
    Returns to source 1: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)           1         1  ✓
    6      (2, 8)          -2        -2  ✓
    7     (2, 11)           1         1  ✓
    8      (3, 4)          -3        -3  ✓
    9      (3, 6)           4         4  ✓
   10      (3, 8)           1         1  ✓
   11      (4, 5)          -3        -3  ✓
   12      (5, 6)          -4        -4  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)           1         1  ✓
   15     (6, 10)           0         0  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)           2         2  ✓
   20     (9, 10)          -1        -1  ✓
   21    (10, 11)          -3        -3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 89
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 3, 2] → J=171, T=200, cost=0 → queued

[Iter 1] cost=0, J=171, T=200, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 3, 2]
  [backtrack] Found solution with 4 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.5s
  *** SOLUTION FOUND! J=171, T_tour=199.5s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 0, 0, 2, -2, 0, 2, -2, 0, 0, -2, 0, -3, 2, 1, 0, -3, 3, -3, 5, 3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 0, 0, 2, -2, 0, 2, -2, 0, 0, -2, 0, -3, 2, 1, 0, -3, 3, -3, 5, 3]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 5), np.int64(2)), ((2, 3), np.int64(-2)), ((2, 11), np.int64(2)), ((3, 4), np.int64(-2)), ((4, 5), np.int64(-2)), ((6, 7), np.int64(-3)), ((6, 9), np.int64(2)), ((6, 10), np.int64(1)), ((7, 10), np.int64(-3)), ((8, 9), np.int64(3)), ((8, 11), np.int64(-3)), ((9, 10), np.int64(5)), ((10, 11), np.int64(3))]

Blocked edge 1: idx=21, edge=(10, 11), flow_B=3  →  need Cm[21]=-3
Blocked edge 2: idx=13, edge=(6, 7), flow_B=-3  →  need Cm[13]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=42   ||Cm||_1=20

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, 4, -2, -1, -1, 0, 0, -1, 3, 0, 0]

Cm = C_oriented @ beta*:
  [0, 0, 0, 0, 0, -1, -1, 2, 0, 0, -1, 0, 0, 3, 0, -3, 2, 1, -1, 1, -1, -3]

Original flow_B:
  [2, -2, 0, 0, 2, -2, 0, 2, -2, 0, 0, -2, 0, -3, 2, 1, 0, -3, 3, -3, 5, 3]

flow_B + Cm (corrected flow):
  [2, -2, 0, 0, 2, -3, -1, 4, -2, 0, -1, -2, 0, 0, 2, -2, 2, -2, 2, -2, 4, 0]

Verification:
  flow_corrected[21] = 0  (should be 0, Cm=-3, d=-3)
  flow_corrected[13] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 42  (minimized by MIQP)
  ||Cm||_1  = 20
  ||flow_B||_2² = 103
  ||flow_corrected||_2² = 87

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    4.5          
    1     (0, 11)        -2       0          -2    6.9          
    2      (1, 2)         0       0           0    4.4          
    3      (1, 3)         0       0           0    5.6          
    4      (1, 5)         2       0           2    6.7          
    5      (2, 3)        -2      -1          -3    4.6     +4.6s
    6      (2, 8)         0      -1          -1    7.3     +7.3s
    7     (2, 11)         2       2           4    4.5     +9.0s
    8      (3, 4)        -2       0          -2    6.4          
    9      (3, 6)         0       0           0    4.3          
   10      (3, 8)         0      -1          -1    6.0     +6.0s
   11      (4, 5)        -2       0          -2    7.7          
   12      (5, 6)         0       0           0    7.2          
   13      (6, 7)        -3       3           0    4.8    -14.4s ← BLOCKED
   14      (6, 9)         2       0           2    5.4          
   15     (6, 10)         1      -3          -2    6.1     +6.1s
   16      (7, 8)         0       2           2    7.9    +15.8s
   17     (7, 10)        -3       1          -2    6.0     -6.0s
   18      (8, 9)         3      -1           2    5.4     -5.4s
   19     (8, 11)        -3       1          -2    4.9     -4.9s
   20     (9, 10)         5      -1           4    4.7     -4.7s
   21    (10, 11)         3      -3           0    4.4    -13.2s ← BLOCKED

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=2, out=2  OK
  Node 2: in=4, out=4  OK
  Node 3: in=3, out=3  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=2, out=2  OK
  Node 7: in=2, out=2  OK
  Node 8: in=4, out=4  OK
  Node 9: in=4, out=4  OK
  Node 10: in=4, out=4  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 18

  Summary:
    Original path length:  37 edges
    Spliced path length:   35 edges
    Splices performed:     18
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)          -3        -3  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           4         4  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)          -2        -2  ✓
   16      (7, 8)           2         2  ✓
   17     (7, 10)          -2        -2  ✓
   18      (8, 9)           2         2  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)           4         4  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 90
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2] → J=205, T=200, cost=0 → queued

[Iter 1] cost=0, J=205, T=200, edges=33, frontier=0, MILP_calls=1
  V_MIN=[1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 10, 11] → expanding 9 children
    V_MIN=[2, 1, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2] → J=200, T=199, cost=1 → queued
    V_MIN=[1, 1, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2] → J=190, T=200, cost=1 → queued
    V_MIN=[1, 1, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2] → J=194, T=199, cost=1 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 3, 2, 2, 2, 2, 2] → J=203, T=199, cost=1 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 2, 3, 2, 2, 2, 2] → J=202, T=199, cost=1 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 2, 2, 3, 2, 2, 2] → J=204, T=200, cost=1 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 2, 2, 2, 3, 2, 2] → J=201, T=200, cost=1 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2] → J=202, T=200, cost=1 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 2, 3] → J=204, T=200, cost=1 → queued

[Iter 2] cost=1, J=204, T=200, edges=33, frontier=8, MILP_calls=10
  V_MIN=[1, 1, 3, 3, 2, 2, 2, 2, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (1056 backtracks in 0.00s)
  [backtrack] Found solution with 85 backtracks in 0.00s
  [backtrack] Found solution with 38 backtracks in 0.00s
  [backtrack] Found solution with 51 backtracks in 0.00s
  [backtrack] Found solution with 40 backtracks in 0.00s
  [backtrack] Found solution with 95 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (873 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (923 backtracks in 0.00s)
  [backtrack] Found solution with 86 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (482 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1108 backtracks in 0.00s)
  [backtrack] Found solution with 53 backtracks in 0.00s
  DFS: latency violated (4 nodes, worst_gap=175.7s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10] → expanding 7 children
    V_MIN=[2, 1, 3, 3, 2, 2, 2, 2, 3, 2, 2, 2] → J=200, T=199, cost=2 → queued
    V_MIN=[1, 1, 3, 3, 3, 2, 2, 2, 3, 2, 2, 2] → J=188, T=200, cost=2 → queued
    V_MIN=[1, 1, 3, 3, 2, 3, 2, 2, 3, 2, 2, 2] → J=193, T=200, cost=2 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 3, 2, 3, 2, 2, 2] → J=203, T=199, cost=2 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 2, 3, 3, 2, 2, 2] → J=202, T=199, cost=2 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 2, 2, 3, 3, 2, 2] → J=200, T=200, cost=2 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 2, 2, 3, 2, 3, 2] → J=202, T=200, cost=2 → queued

[Iter 3] cost=1, J=204, T=200, edges=33, frontier=14, MILP_calls=17
  V_MIN=[1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 2, 3]
  [backtrack] EXHAUSTED search space (1056 backtracks in 0.00s)
  [backtrack] Found solution with 85 backtracks in 0.00s
  [backtrack] Found solution with 38 backtracks in 0.00s
  [backtrack] Found solution with 51 backtracks in 0.00s
  [backtrack] Found solution with 40 backtracks in 0.00s
  [backtrack] Found solution with 95 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (873 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (923 backtracks in 0.00s)
  [backtrack] Found solution with 86 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (482 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1108 backtracks in 0.00s)
  [backtrack] Found solution with 53 backtracks in 0.00s
  DFS: latency violated (4 nodes, worst_gap=175.7s)
  Boundary nodes: [0, 4, 5, 6, 7, 9, 10, 11] → expanding 8 children
    V_MIN=[2, 1, 3, 3, 2, 2, 2, 2, 2, 2, 2, 3] → J=198, T=200, cost=2 → queued
    V_MIN=[1, 1, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3] → J=188, T=199, cost=2 → queued
    V_MIN=[1, 1, 3, 3, 2, 3, 2, 2, 2, 2, 2, 3] → J=189, T=200, cost=2 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 3, 2, 2, 2, 2, 3] → J=200, T=199, cost=2 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 2, 3, 2, 2, 2, 3] → J=197, T=200, cost=2 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 2, 2, 2, 3, 2, 3] → J=197, T=199, cost=2 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3] → J=202, T=200, cost=2 → queued
    V_MIN=[1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 2, 4] → J=202, T=200, cost=2 → queued

[Iter 4] cost=1, J=203, T=199, edges=33, frontier=21, MILP_calls=25
  V_MIN=[1, 1, 3, 3, 2, 2, 3, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 465 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.0s
  *** SOLUTION FOUND! J=203, T_tour=199.0s ***

============================================================
Search done: 4 iters, 25 MILP calls, 25 states visited

Original flow_B is latency-feasible ✓
  flow_B = [1, -1, 1, 0, 0, -4, 3, 2, -2, 2, -4, -2, -2, 2, -2, 0, 0, 2, 0, -1, -2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [1, -1, 1, 0, 0, -4, 3, 2, -2, 2, -4, -2, -2, 2, -2, 0, 0, 2, 0, -1, -2, 0]
  Non-zero edges: [((0, 1), np.int64(1)), ((0, 11), np.int64(-1)), ((1, 2), np.int64(1)), ((2, 3), np.int64(-4)), ((2, 8), np.int64(3)), ((2, 11), np.int64(2)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(2)), ((3, 8), np.int64(-4)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(2)), ((6, 9), np.int64(-2)), ((7, 10), np.int64(2)), ((8, 11), np.int64(-1)), ((9, 10), np.int64(-2))]

Blocked edge 1: idx=13, edge=(6, 7), flow_B=2  →  need Cm[13]=-2
Blocked edge 2: idx=5, edge=(2, 3), flow_B=-4  →  need Cm[5]=4
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=46   ||Cm||_1=24

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [3, 0, -1, -1, 1, -1, -1, -2, 1, 1, -1]

Cm = C_oriented @ beta*:
  [-1, 1, 2, -2, -1, 4, -2, 0, 0, 0, 2, 0, -1, -2, 0, 1, -1, -1, -1, 0, -1, -1]

Original flow_B:
  [1, -1, 1, 0, 0, -4, 3, 2, -2, 2, -4, -2, -2, 2, -2, 0, 0, 2, 0, -1, -2, 0]

flow_B + Cm (corrected flow):
  [0, 0, 3, -2, -1, 0, 1, 2, -2, 2, -2, -2, -3, 0, -2, 1, -1, 1, -1, -1, -3, -1]

Verification:
  flow_corrected[13] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[5] = 0  (should be 0, Cm=4, d=4)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 46  (minimized by MIQP)
  ||Cm||_1  = 24
  ||flow_B||_2² = 81
  ||flow_corrected||_2² = 63

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         1      -1           0    5.5     -5.5s
    1     (0, 11)        -1       1           0    5.0     -5.0s
    2      (1, 2)         1       2           3    4.8     +9.6s
    3      (1, 3)         0      -2          -2    6.2    +12.4s
    4      (1, 5)         0      -1          -1    7.3     +7.3s
    5      (2, 3)        -4       4           0    6.0    -24.0s ← BLOCKED
    6      (2, 8)         3      -2           1    6.8    -13.6s
    7     (2, 11)         2       0           2    7.0          
    8      (3, 4)        -2       0          -2    6.6          
    9      (3, 6)         2       0           2    5.5          
   10      (3, 8)        -4       2          -2    4.3     -8.6s
   11      (4, 5)        -2       0          -2    7.2          
   12      (5, 6)        -2      -1          -3    7.2     +7.2s
   13      (6, 7)         2      -2           0    4.2     -8.4s ← BLOCKED
   14      (6, 9)        -2       0          -2    6.4          
   15     (6, 10)         0       1           1    7.9     +7.9s
   16      (7, 8)         0      -1          -1    7.9     +7.9s
   17     (7, 10)         2      -1           1    7.3     -7.3s
   18      (8, 9)         0      -1          -1    6.8     +6.8s
   19     (8, 11)        -1       0          -1    6.5          
   20     (9, 10)        -2      -1          -3    6.4     +6.4s
   21    (10, 11)         0      -1          -1    6.7     +6.7s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=3, out=3  OK
  Node 2: in=3, out=3  OK
  Node 3: in=4, out=4  OK
  Node 4: in=2, out=2  OK
  Node 5: in=3, out=3  OK
  Node 6: in=4, out=4  OK
  Node 7: in=1, out=1  OK
  Node 8: in=3, out=3  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 31 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 19

  Summary:
    Original path length:  33 edges
    Spliced path length:   31 edges
    Splices performed:     19
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           3         3  ✓
    3      (1, 3)          -2        -2  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           1         1  ✓
    7     (2, 11)           2         2  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           2         2  ✓
   10      (3, 8)          -2        -2  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)          -3        -3  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)          -2        -2  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)           1         1  ✓
   18      (8, 9)          -1        -1  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)          -3        -3  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 91
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 1] → J=247, T=199, cost=0 → queued

[Iter 1] cost=0, J=247, T=199, edges=39, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 1]
  [backtrack] Found solution with 60 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.2s
  *** SOLUTION FOUND! J=247, T_tour=199.2s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 0, 0, 2, -2, 2, 0, -2, 0, 0, -2, 0, 2, -1, -1, -4, 6, -4, 2, -5, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 0, 0, 2, -2, 2, 0, -2, 0, 0, -2, 0, 2, -1, -1, -4, 6, -4, 2, -5, 0]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 5), np.int64(2)), ((2, 3), np.int64(-2)), ((2, 8), np.int64(2)), ((3, 4), np.int64(-2)), ((4, 5), np.int64(-2)), ((6, 7), np.int64(2)), ((6, 9), np.int64(-1)), ((6, 10), np.int64(-1)), ((7, 8), np.int64(-4)), ((7, 10), np.int64(6)), ((8, 9), np.int64(-4)), ((8, 11), np.int64(2)), ((9, 10), np.int64(-5))]

Blocked edge 1: idx=20, edge=(9, 10), flow_B=-5  →  need Cm[20]=5
Blocked edge 2: idx=5, edge=(2, 3), flow_B=-2  →  need Cm[5]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=63   ||Cm||_1=23

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -2, 2, 5, 2, 0, 0, 2, -1, 0, 0]

Cm = C_oriented @ beta*:
  [0, 0, 0, 0, 0, 2, 0, -2, 0, 0, 2, 0, 0, 0, 3, -3, 1, -1, 2, 1, 5, 1]

Original flow_B:
  [2, -2, 0, 0, 2, -2, 2, 0, -2, 0, 0, -2, 0, 2, -1, -1, -4, 6, -4, 2, -5, 0]

flow_B + Cm (corrected flow):
  [2, -2, 0, 0, 2, 0, 2, -2, -2, 0, 2, -2, 0, 2, 2, -4, -3, 5, -2, 3, 0, 1]

Verification:
  flow_corrected[20] = 0  (should be 0, Cm=5, d=5)
  flow_corrected[5] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 63  (minimized by MIQP)
  ||Cm||_1  = 23
  ||flow_B||_2² = 131
  ||flow_corrected||_2² = 104

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    5.4          
    1     (0, 11)        -2       0          -2    5.2          
    2      (1, 2)         0       0           0    6.8          
    3      (1, 3)         0       0           0    7.7          
    4      (1, 5)         2       0           2    4.3          
    5      (2, 3)        -2       2           0    4.3     -8.6s ← BLOCKED
    6      (2, 8)         2       0           2    6.3          
    7     (2, 11)         0      -2          -2    6.7    +13.4s
    8      (3, 4)        -2       0          -2    4.0          
    9      (3, 6)         0       0           0    5.7          
   10      (3, 8)         0       2           2    5.6    +11.2s
   11      (4, 5)        -2       0          -2    4.3          
   12      (5, 6)         0       0           0    7.1          
   13      (6, 7)         2       0           2    4.8          
   14      (6, 9)        -1       3           2    5.9     +5.9s
   15     (6, 10)        -1      -3          -4    6.6    +19.8s
   16      (7, 8)        -4       1          -3    4.0     -4.0s
   17     (7, 10)         6      -1           5    4.3     -4.3s
   18      (8, 9)        -4       2          -2    7.0    -14.0s
   19     (8, 11)         2       1           3    4.6     +4.6s
   20     (9, 10)        -5       5           0    6.1    -30.5s ← BLOCKED
   21    (10, 11)         0       1           1    6.7     +6.7s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=2, out=2  OK
  Node 2: in=2, out=2  OK
  Node 3: in=2, out=2  OK
  Node 4: in=2, out=2  OK
  Node 5: in=2, out=2  OK
  Node 6: in=4, out=4  OK
  Node 7: in=5, out=5  OK
  Node 8: in=6, out=6  OK
  Node 9: in=2, out=2  OK
  Node 10: in=5, out=5  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 38 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 21

  Summary:
    Original path length:  39 edges
    Spliced path length:   38 edges
    Splices performed:     21
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           2         2  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           2         2  ✓
    7     (2, 11)          -2        -2  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           2         2  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)           2         2  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)          -4        -4  ✓
   16      (7, 8)          -3        -3  ✓
   17     (7, 10)           5         5  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)           3         3  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 92
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 3, 2, 2, 1, 3, 2, 2, 2, 3, 2, 3] → J=249, T=199, cost=0 → queued

[Iter 1] cost=0, J=249, T=199, edges=36, frontier=0, MILP_calls=1
  V_MIN=[3, 3, 2, 2, 1, 3, 2, 2, 2, 3, 2, 3]
  [backtrack] Found solution with 47 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=199.4s
  *** SOLUTION FOUND! J=249, T_tour=199.4s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-3, 3, -2, 2, -3, -1, -1, 0, 1, 0, 0, 1, -2, 0, 2, -4, -2, 2, -3, 0, -1, -3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-3, 3, -2, 2, -3, -1, -1, 0, 1, 0, 0, 1, -2, 0, 2, -4, -2, 2, -3, 0, -1, -3]
  Non-zero edges: [((0, 1), np.int64(-3)), ((0, 11), np.int64(3)), ((1, 2), np.int64(-2)), ((1, 3), np.int64(2)), ((1, 5), np.int64(-3)), ((2, 3), np.int64(-1)), ((2, 8), np.int64(-1)), ((3, 4), np.int64(1)), ((4, 5), np.int64(1)), ((5, 6), np.int64(-2)), ((6, 9), np.int64(2)), ((6, 10), np.int64(-4)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(2)), ((8, 9), np.int64(-3)), ((9, 10), np.int64(-1)), ((10, 11), np.int64(-3))]

Blocked edge 1: idx=16, edge=(7, 8), flow_B=-2  →  need Cm[16]=2
Blocked edge 2: idx=20, edge=(9, 10), flow_B=-1  →  need Cm[20]=1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=15   ||Cm||_1=13

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, -1, 0, 1, 0, 0, 1, 2, 0, 0, 1]

Cm = C_oriented @ beta*:
  [1, -1, 0, 1, 0, -1, 0, 1, 0, 1, -1, 0, 0, 1, 0, 0, 2, -1, 1, 0, 1, 0]

Original flow_B:
  [-3, 3, -2, 2, -3, -1, -1, 0, 1, 0, 0, 1, -2, 0, 2, -4, -2, 2, -3, 0, -1, -3]

flow_B + Cm (corrected flow):
  [-2, 2, -2, 3, -3, -2, -1, 1, 1, 1, -1, 1, -2, 1, 2, -4, 0, 1, -2, 0, 0, -3]

Verification:
  flow_corrected[16] = 0  (should be 0, Cm=2, d=2)
  flow_corrected[20] = 0  (should be 0, Cm=1, d=1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 15  (minimized by MIQP)
  ||Cm||_1  = 13
  ||flow_B||_2² = 90
  ||flow_corrected||_2² = 79

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -3       1          -2    5.2     -5.2s
    1     (0, 11)         3      -1           2    7.3     -7.3s
    2      (1, 2)        -2       0          -2    5.8          
    3      (1, 3)         2       1           3    5.2     +5.2s
    4      (1, 5)        -3       0          -3    5.6          
    5      (2, 3)        -1      -1          -2    7.2     +7.2s
    6      (2, 8)        -1       0          -1    7.4          
    7     (2, 11)         0       1           1    6.9     +6.9s
    8      (3, 4)         1       0           1    7.1          
    9      (3, 6)         0       1           1    7.5     +7.5s
   10      (3, 8)         0      -1          -1    4.7     +4.7s
   11      (4, 5)         1       0           1    5.8          
   12      (5, 6)        -2       0          -2    7.1          
   13      (6, 7)         0       1           1    7.7     +7.7s
   14      (6, 9)         2       0           2    5.4          
   15     (6, 10)        -4       0          -4    4.5          
   16      (7, 8)        -2       2           0    5.5    -11.0s ← BLOCKED
   17     (7, 10)         2      -1           1    4.7     -4.7s
   18      (8, 9)        -3       1          -2    4.0     -4.0s
   19     (8, 11)         0       0           0    7.7          
   20     (9, 10)        -1       1           0    7.0     -7.0s ← BLOCKED
   21    (10, 11)        -3       0          -3    4.4          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=5, out=5  OK
  Node 2: in=3, out=3  OK
  Node 3: in=4, out=4  OK
  Node 4: in=1, out=1  OK
  Node 5: in=3, out=3  OK
  Node 6: in=5, out=5  OK
  Node 7: in=1, out=1  OK
  Node 8: in=2, out=2  OK
  Node 9: in=2, out=2  OK
  Node 10: in=4, out=4  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 35 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 14

  Summary:
    Original path length:  36 edges
    Spliced path length:   35 edges
    Splices performed:     14
    Path is continuous:    True
    Returns to source 1: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -2        -2  ✓
    1     (0, 11)           2         2  ✓
    2      (1, 2)          -2        -2  ✓
    3      (1, 3)           3         3  ✓
    4      (1, 5)          -3        -3  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           1         1  ✓
    8      (3, 4)           1         1  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           1         1  ✓
   12      (5, 6)          -2        -2  ✓
   13      (6, 7)           1         1  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)          -4        -4  ✓
   16      (7, 8)           0         0  ✓
   17     (7, 10)           1         1  ✓
   18      (8, 9)          -2        -2  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)           0         0  ✓
   21    (10, 11)          -3        -3  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 93
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 1, 2] → J=249, T=200, cost=0 → queued

[Iter 1] cost=0, J=249, T=200, edges=34, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 1, 2]
  [backtrack] Found solution with 559 backtracks in 0.00s
  [backtrack] Found solution with 727 backtracks in 0.00s
  [backtrack] Found solution with 459 backtracks in 0.00s
  [backtrack] Found solution with 229 backtracks in 0.00s
    ✓ Latency-feasible! source=3, T_tour=199.8s
  DFS: latency violated (1 nodes, worst_gap=138.7s)
  Boundary nodes: [0, 1, 2, 4, 5, 7, 9, 10] → expanding 8 children
    V_MIN=[3, 2, 2, 3, 2, 2, 3, 2, 2, 2, 1, 2] → J=243, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 2, 2, 2, 1, 2] → J=246, T=199, cost=1 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 3, 2, 2, 2, 1, 2] → J=248, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 3, 2, 2, 2, 1, 2] → J=244, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 3, 2, 2, 2, 1, 2] → J=247, T=198, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 3, 3, 2, 2, 1, 2] → J=243, T=197, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 3, 2, 2, 3, 1, 2] → J=246, T=199, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2] → J=248, T=198, cost=1 → queued

[Iter 2] cost=1, J=248, T=200, edges=34, frontier=7, MILP_calls=9
  V_MIN=[2, 2, 3, 3, 2, 2, 3, 2, 2, 2, 1, 2]
  [backtrack] Found solution with 158 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.6s
  *** SOLUTION FOUND! J=248, T_tour=199.6s ***

============================================================
Search done: 2 iters, 9 MILP calls, 9 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 0, 1, 1, 3, -3, 0, -2, 6, 0, -2, -1, 2, 2, 1, 2, 0, -2, 1, 0, 1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 0, 1, 1, 3, -3, 0, -2, 6, 0, -2, -1, 2, 2, 1, 2, 0, -2, 1, 0, 1]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 3), np.int64(1)), ((1, 5), np.int64(1)), ((2, 3), np.int64(3)), ((2, 8), np.int64(-3)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(6)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-1)), ((6, 7), np.int64(2)), ((6, 9), np.int64(2)), ((6, 10), np.int64(1)), ((7, 8), np.int64(2)), ((8, 9), np.int64(-2)), ((8, 11), np.int64(1)), ((10, 11), np.int64(1))]

Blocked edge 1: idx=9, edge=(3, 6), flow_B=6  →  need Cm[9]=-6
Blocked edge 2: idx=6, edge=(2, 8), flow_B=-3  →  need Cm[6]=3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=94   ||Cm||_1=34

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [-1, 1, 2, 1, -1, 3, 1, -1, 0, -3, -3]

Cm = C_oriented @ beta*:
  [1, -1, 0, -2, 3, -2, 3, -1, 0, -6, 2, 0, 3, 0, -1, -2, -1, 1, 2, 2, 1, 0]

Original flow_B:
  [2, -2, 0, 1, 1, 3, -3, 0, -2, 6, 0, -2, -1, 2, 2, 1, 2, 0, -2, 1, 0, 1]

flow_B + Cm (corrected flow):
  [3, -3, 0, -1, 4, 1, 0, -1, -2, 0, 2, -2, 2, 2, 1, -1, 1, 1, 0, 3, 1, 1]

Verification:
  flow_corrected[9] = 0  (should be 0, Cm=-6, d=-6)
  flow_corrected[6] = 0  (should be 0, Cm=3, d=3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 94  (minimized by MIQP)
  ||Cm||_1  = 34
  ||flow_B||_2² = 92
  ||flow_corrected||_2² = 72

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       1           3    7.4     +7.4s
    1     (0, 11)        -2      -1          -3    5.6     +5.6s
    2      (1, 2)         0       0           0    5.9          
    3      (1, 3)         1      -2          -1    6.8          
    4      (1, 5)         1       3           4    4.7    +14.1s
    5      (2, 3)         3      -2           1    4.3     -8.6s
    6      (2, 8)        -3       3           0    6.5    -19.5s ← BLOCKED
    7     (2, 11)         0      -1          -1    6.4     +6.4s
    8      (3, 4)        -2       0          -2    7.5          
    9      (3, 6)         6      -6           0    4.2    -25.2s ← BLOCKED
   10      (3, 8)         0       2           2    6.3    +12.6s
   11      (4, 5)        -2       0          -2    5.6          
   12      (5, 6)        -1       3           2    7.2     +7.2s
   13      (6, 7)         2       0           2    7.1          
   14      (6, 9)         2      -1           1    7.1     -7.1s
   15     (6, 10)         1      -2          -1    4.4          
   16      (7, 8)         2      -1           1    7.8     -7.8s
   17     (7, 10)         0       1           1    7.4     +7.4s
   18      (8, 9)        -2       2           0    5.1    -10.2s
   19     (8, 11)         1       2           3    5.9    +11.8s
   20     (9, 10)         0       1           1    5.9     +5.9s
   21    (10, 11)         1       0           1    6.6          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=4, out=4  OK
  Node 2: in=1, out=1  OK
  Node 3: in=3, out=3  OK
  Node 4: in=2, out=2  OK
  Node 5: in=4, out=4  OK
  Node 6: in=3, out=3  OK
  Node 7: in=2, out=2  OK
  Node 8: in=3, out=3  OK
  Node 9: in=1, out=1  OK
  Node 10: in=2, out=2  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 32 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 25

  Summary:
    Original path length:  34 edges
    Spliced path length:   32 edges
    Splices performed:     25
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           3         3  ✓
    1     (0, 11)          -3        -3  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)           4         4  ✓
    5      (2, 3)           1         1  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)          -1        -1  ✓
    8      (3, 4)          -2        -2  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)           2         2  ✓
   11      (4, 5)          -2        -2  ✓
   12      (5, 6)           2         2  ✓
   13      (6, 7)           2         2  ✓
   14      (6, 9)           1         1  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)           1         1  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)           3         3  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)           1         1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 94
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 1, 3, 2, 3, 2] → J=258, T=199, cost=0 → queued

[Iter 1] cost=0, J=258, T=199, edges=40, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 1, 3, 2, 3, 2]
  [backtrack] Found solution with 90 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.1s
  *** SOLUTION FOUND! J=258, T_tour=199.1s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 4, 0, -2, 0, 4, 0, 2, 3, -5, 2, 0, -1, 4, 0, 0, -1, 0, -1, 4, 3]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 4, 0, -2, 0, 4, 0, 2, 3, -5, 2, 0, -1, 4, 0, 0, -1, 0, -1, 4, 3]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(4)), ((1, 5), np.int64(-2)), ((2, 8), np.int64(4)), ((3, 4), np.int64(2)), ((3, 6), np.int64(3)), ((3, 8), np.int64(-5)), ((4, 5), np.int64(2)), ((6, 7), np.int64(-1)), ((6, 9), np.int64(4)), ((7, 10), np.int64(-1)), ((8, 11), np.int64(-1)), ((9, 10), np.int64(4)), ((10, 11), np.int64(3))]

Blocked edge 1: idx=14, edge=(6, 9), flow_B=4  →  need Cm[14]=-4
Blocked edge 2: idx=0, edge=(0, 1), flow_B=2  →  need Cm[0]=-2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=48   ||Cm||_1=26

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [2, 1, -2, -2, -3, -2, -2, 0, 1, 1, -2]

Cm = C_oriented @ beta*:
  [-2, 2, 0, -1, -1, -1, 1, 0, -1, 0, -1, -1, -2, 1, -4, 1, 1, 0, 2, -1, -2, -1]

Original flow_B:
  [2, -2, 4, 0, -2, 0, 4, 0, 2, 3, -5, 2, 0, -1, 4, 0, 0, -1, 0, -1, 4, 3]

flow_B + Cm (corrected flow):
  [0, 0, 4, -1, -3, -1, 5, 0, 1, 3, -6, 1, -2, 0, 0, 1, 1, -1, 2, -2, 2, 2]

Verification:
  flow_corrected[14] = 0  (should be 0, Cm=-4, d=-4)
  flow_corrected[0] = 0  (should be 0, Cm=-2, d=-2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 48  (minimized by MIQP)
  ||Cm||_1  = 26
  ||flow_B||_2² = 130
  ||flow_corrected||_2² = 122

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.0s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2      -2           0    7.1    -14.2s ← BLOCKED
    1     (0, 11)        -2       2           0    5.3    -10.6s
    2      (1, 2)         4       0           4    5.2          
    3      (1, 3)         0      -1          -1    7.1     +7.1s
    4      (1, 5)        -2      -1          -3    5.4     +5.4s
    5      (2, 3)         0      -1          -1    7.9     +7.9s
    6      (2, 8)         4       1           5    4.1     +4.1s
    7     (2, 11)         0       0           0    6.1          
    8      (3, 4)         2      -1           1    6.8     -6.8s
    9      (3, 6)         3       0           3    5.2          
   10      (3, 8)        -5      -1          -6    4.2     +4.2s
   11      (4, 5)         2      -1           1    6.5     -6.5s
   12      (5, 6)         0      -2          -2    6.1    +12.2s
   13      (6, 7)        -1       1           0    4.1     -4.1s
   14      (6, 9)         4      -4           0    4.6    -18.4s ← BLOCKED
   15     (6, 10)         0       1           1    6.5     +6.5s
   16      (7, 8)         0       1           1    7.4     +7.4s
   17     (7, 10)        -1       0          -1    5.6          
   18      (8, 9)         0       2           2    6.9    +13.8s
   19     (8, 11)        -1      -1          -2    4.8     +4.8s
   20     (9, 10)         4      -2           2    4.1     -8.2s
   21    (10, 11)         3      -1           2    4.6     -4.6s

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=4, out=4  OK
  Node 2: in=5, out=5  OK
  Node 3: in=6, out=6  OK
  Node 4: in=1, out=1  OK
  Node 5: in=3, out=3  OK
  Node 6: in=3, out=3  OK
  Node 7: in=1, out=1  OK
  Node 8: in=8, out=8  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 38 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 20

  Summary:
    Original path length:  40 edges
    Spliced path length:   38 edges
    Splices performed:     20
    Path is continuous:    True
    Returns to source 0: False
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)           4         4  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)          -3        -3  ✓
    5      (2, 3)          -1        -1  ✓
    6      (2, 8)           5         5  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           1         1  ✓
    9      (3, 6)           3         3  ✓
   10      (3, 8)          -6        -6  ✓
   11      (4, 5)           1         1  ✓
   12      (5, 6)          -2        -2  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)          -1        -1  ✓
   18      (8, 9)           2         2  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           2         2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 95
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 3, 2, 3] → J=271, T=199, cost=0 → queued

[Iter 1] cost=0, J=271, T=199, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 3, 2, 3]
  [backtrack] Found solution with 16 backtracks in 0.00s
  [backtrack] Found solution with 131 backtracks in 0.00s
  [backtrack] Found solution with 179 backtracks in 0.00s
  [backtrack] Found solution with 151 backtracks in 0.00s
  [backtrack] Found solution with 131 backtracks in 0.00s
  [backtrack] Found solution with 131 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (177 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (201 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (212 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (296 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (160 backtracks in 0.00s)
  [backtrack] Found solution with 179 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=96.5s)
  Boundary nodes: [0, 7, 8, 9, 10] → expanding 5 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 2, 3] → J=259, T=200, cost=1 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 2, 3, 2, 3] → J=263, T=200, cost=1 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 3, 3, 2, 3] → J=271, T=200, cost=1 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 4, 2, 3] → J=271, T=200, cost=1 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 3, 3, 3] → J=271, T=200, cost=1 → queued

[Iter 2] cost=1, J=271, T=200, edges=37, frontier=4, MILP_calls=6
  V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (1466 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (794 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1635 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1229 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2025 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1730 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1002 backtracks in 0.00s)
  [backtrack] Found solution with 466 backtracks in 0.00s
  [backtrack] Found solution with 1204 backtracks in 0.00s
  [backtrack] Found solution with 1138 backtracks in 0.00s
  [backtrack] Found solution with 845 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (452 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=106.4s)
  Boundary nodes: [0, 2, 5, 7, 8, 11] → expanding 6 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 3, 3, 2, 3] → J=259, T=200, cost=2 → queued
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 2, 3, 3, 2, 3] → J=270, T=200, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 3, 3, 2, 3] → J=270, T=199, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 3, 3, 2, 3] → J=263, T=200, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 4, 3, 2, 3] → J=269, T=200, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 3, 3, 2, 4] → J=270, T=200, cost=2 → queued

[Iter 3] cost=1, J=271, T=200, edges=37, frontier=9, MILP_calls=12
  V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 4, 2, 3]
  [backtrack] EXHAUSTED search space (1350 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1307 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1222 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2281 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2555 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2037 backtracks in 0.00s)
  [backtrack] Found solution with 508 backtracks in 0.00s
  [backtrack] Found solution with 335 backtracks in 0.00s
  [backtrack] Found solution with 774 backtracks in 0.00s
  [backtrack] Found solution with 636 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (384 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1486 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=106.4s)
  Boundary nodes: [0, 2, 5, 7, 11] → expanding 5 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 2, 4, 2, 3] → J=258, T=200, cost=2 → queued
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 2, 2, 4, 2, 3] → J=267, T=199, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 2, 4, 2, 3] → J=270, T=199, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 2, 4, 2, 3] → J=263, T=200, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 4, 2, 4] → J=267, T=199, cost=2 → queued

[Iter 4] cost=1, J=271, T=200, edges=37, frontier=13, MILP_calls=17
  V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (1350 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1307 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1222 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2281 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2555 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2037 backtracks in 0.00s)
  [backtrack] Found solution with 508 backtracks in 0.00s
  [backtrack] Found solution with 335 backtracks in 0.00s
  [backtrack] Found solution with 774 backtracks in 0.00s
  [backtrack] Found solution with 636 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (384 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1486 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=106.4s)
  Boundary nodes: [0, 2, 5, 7, 10, 11] → expanding 6 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 3, 3] → J=255, T=199, cost=2 → queued
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 2, 2, 3, 3, 3] → J=270, T=200, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 2, 3, 3, 3] → J=269, T=200, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 2, 3, 3, 3] → J=260, T=198, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 3, 4, 3] → J=269, T=200, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 3, 3, 4] → J=270, T=200, cost=2 → queued

[Iter 5] cost=1, J=263, T=200, edges=36, frontier=18, MILP_calls=23
  V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 2, 3, 2, 3]
  [backtrack] EXHAUSTED search space (200 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (204 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (292 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (234 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (230 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (226 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (90 backtracks in 0.00s)
  [backtrack] Found solution with 59 backtracks in 0.00s
  [backtrack] Found solution with 63 backtracks in 0.00s
  [backtrack] Found solution with 39 backtracks in 0.00s
  [backtrack] Found solution with 217 backtracks in 0.00s
  [backtrack] Found solution with 164 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=97.4s)
  Boundary nodes: [0, 2, 5, 7, 10] → expanding 5 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 3, 2, 3, 2, 3] → J=250, T=200, cost=2 → queued
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 3, 2, 3, 2, 3] → J=262, T=199, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 3, 2, 3, 2, 3] → J=258, T=198, cost=2 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 4, 2, 3, 2, 3] → J=257, T=200, cost=2 → queued

[Iter 6] cost=1, J=259, T=200, edges=37, frontier=21, MILP_calls=27
  V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 2, 3]
  [backtrack] EXHAUSTED search space (79 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (81 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (67 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (42 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (33 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (135 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (55 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (73 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 7, 9, 10, 11] → expanding 6 children
    V_MIN=[4, 1, 3, 2, 2, 3, 2, 2, 2, 3, 2, 3] → J=248, T=198, cost=2 → queued
    V_MIN=[3, 1, 4, 2, 2, 3, 2, 2, 2, 3, 2, 3] → J=257, T=200, cost=2 → queued
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 2, 4] → J=258, T=200, cost=2 → queued

[Iter 7] cost=2, J=270, T=199, edges=37, frontier=23, MILP_calls=30
  V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 3, 3, 2, 3]
  [backtrack] Found solution with 194 backtracks in 0.00s
  [backtrack] Found solution with 255 backtracks in 0.00s
  [backtrack] Found solution with 392 backtracks in 0.00s
  [backtrack] Found solution with 379 backtracks in 0.00s
  [backtrack] Found solution with 266 backtracks in 0.00s
  [backtrack] Found solution with 265 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (485 backtracks in 0.00s)
  [backtrack] Found solution with 206 backtracks in 0.00s
  [backtrack] Found solution with 553 backtracks in 0.00s
  [backtrack] Found solution with 577 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (261 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (243 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=96.6s)
  Boundary nodes: [0, 2, 5, 7, 8, 10, 11] → expanding 7 children
    V_MIN=[3, 1, 3, 2, 2, 4, 2, 2, 3, 3, 2, 3] → J=259, T=200, cost=3 → queued
    V_MIN=[2, 1, 4, 2, 2, 4, 2, 2, 3, 3, 2, 3] → J=264, T=198, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 5, 2, 2, 3, 3, 2, 3] → J=255, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 3, 3, 3, 2, 3] → J=258, T=198, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 4, 3, 2, 3] → J=268, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 3, 3, 3, 3] → J=266, T=198, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 3, 3, 2, 4] → J=264, T=198, cost=3 → queued

[Iter 8] cost=2, J=270, T=199, edges=37, frontier=29, MILP_calls=37
  V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 2, 4, 2, 3]
  [backtrack] Found solution with 194 backtracks in 0.00s
  [backtrack] Found solution with 255 backtracks in 0.00s
  [backtrack] Found solution with 392 backtracks in 0.00s
  [backtrack] Found solution with 379 backtracks in 0.00s
  [backtrack] Found solution with 266 backtracks in 0.00s
  [backtrack] Found solution with 265 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (485 backtracks in 0.00s)
  [backtrack] Found solution with 206 backtracks in 0.00s
  [backtrack] Found solution with 553 backtracks in 0.00s
  [backtrack] Found solution with 577 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (261 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (243 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=96.6s)
  Boundary nodes: [0, 2, 5, 7, 9, 10, 11] → expanding 7 children
    V_MIN=[3, 1, 3, 2, 2, 4, 2, 2, 2, 4, 2, 3] → J=252, T=199, cost=3 → queued
    V_MIN=[2, 1, 4, 2, 2, 4, 2, 2, 2, 4, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 3, 2, 2, 5, 2, 2, 2, 4, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 3, 2, 4, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 2, 5, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 2, 4, 3, 3] → J=262, T=198, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 2, 4, 2, 4] → MILP infeasible, pruned

[Iter 9] cost=2, J=270, T=200, edges=37, frontier=30, MILP_calls=44
  V_MIN=[2, 1, 4, 2, 2, 3, 2, 2, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (516 backtracks in 0.00s)
  [backtrack] Found solution with 325 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (346 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (573 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (750 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (780 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (355 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (606 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (232 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (547 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (221 backtracks in 0.00s)
  [backtrack] Found solution with 558 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=176.3s)
  Boundary nodes: [0, 2, 5, 7, 8, 9] → expanding 6 children
    V_MIN=[3, 1, 4, 2, 2, 3, 2, 2, 3, 3, 2, 3] → J=257, T=200, cost=3 → queued
    V_MIN=[2, 1, 5, 2, 2, 3, 2, 2, 3, 3, 2, 3] → J=268, T=200, cost=3 → queued
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 3, 3, 3, 2, 3] → J=262, T=198, cost=3 → queued
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 2, 4, 3, 2, 3] → J=267, T=199, cost=3 → queued
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 2, 3, 4, 2, 3] → J=267, T=199, cost=3 → queued

[Iter 10] cost=2, J=270, T=200, edges=37, frontier=34, MILP_calls=49
  V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 3, 3, 2, 4]
  [backtrack] Found solution with 293 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (531 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (556 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (431 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (582 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (555 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (394 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (400 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (502 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (371 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (456 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (311 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=176.3s)
  Boundary nodes: [0, 5, 7, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 3, 3, 2, 4] → J=258, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 3, 3, 2, 4] → J=263, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 4, 3, 2, 4] → J=267, T=199, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 3, 4, 2, 4] → J=267, T=199, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 3, 3, 2, 5] → J=268, T=200, cost=3 → queued

[Iter 11] cost=2, J=270, T=200, edges=37, frontier=38, MILP_calls=54
  V_MIN=[2, 1, 4, 2, 2, 3, 2, 2, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (516 backtracks in 0.00s)
  [backtrack] Found solution with 325 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (346 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (573 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (750 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (780 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (355 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (606 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (232 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (547 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (221 backtracks in 0.00s)
  [backtrack] Found solution with 558 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=176.3s)
  Boundary nodes: [0, 2, 5, 7, 9, 10] → expanding 6 children
    V_MIN=[3, 1, 4, 2, 2, 3, 2, 2, 2, 3, 3, 3] → J=255, T=199, cost=3 → queued
    V_MIN=[2, 1, 5, 2, 2, 3, 2, 2, 2, 3, 3, 3] → J=266, T=199, cost=3 → queued
    V_MIN=[2, 1, 4, 2, 2, 4, 2, 2, 2, 3, 3, 3] → J=269, T=200, cost=3 → queued
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 3, 2, 3, 3, 3] → J=260, T=198, cost=3 → queued
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 2, 2, 4, 3, 3] → J=265, T=200, cost=3 → queued
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 2, 2, 3, 4, 3] → J=268, T=200, cost=3 → queued

[Iter 12] cost=2, J=270, T=200, edges=37, frontier=43, MILP_calls=60
  V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 3, 3, 4]
  [backtrack] Found solution with 293 backtracks in 0.01s
  [backtrack] EXHAUSTED search space (531 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (556 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (431 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (582 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (555 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (394 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (400 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (502 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (371 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (456 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (311 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=176.3s)
  Boundary nodes: [0, 5, 7, 9, 10, 11] → expanding 6 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 3, 4] → J=255, T=199, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 2, 3, 3, 4] → J=269, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 2, 3, 3, 4] → J=260, T=198, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 4, 3, 4] → J=265, T=198, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 3, 4, 4] → J=268, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 3, 3, 5] → J=266, T=199, cost=3 → queued

[Iter 13] cost=2, J=269, T=200, edges=37, frontier=48, MILP_calls=66
  V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 2, 3, 3, 3]
  [backtrack] Found solution with 9 backtracks in 0.00s
  [backtrack] Found solution with 161 backtracks in 0.00s
  [backtrack] Found solution with 184 backtracks in 0.00s
  [backtrack] Found solution with 184 backtracks in 0.00s
  [backtrack] Found solution with 184 backtracks in 0.00s
  [backtrack] Found solution with 161 backtracks in 0.00s
  [backtrack] Found solution with 119 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (173 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (165 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (152 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (232 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (175 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=92.0s)
  Boundary nodes: [0, 5, 7, 8, 9, 10] → expanding 6 children
    V_MIN=[3, 1, 3, 2, 2, 4, 2, 2, 2, 3, 3, 3] → J=251, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 5, 2, 2, 2, 3, 3, 3] → J=261, T=198, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 3, 2, 3, 3, 3] → J=258, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 2, 2, 3, 4, 3] → J=264, T=199, cost=3 → queued

[Iter 14] cost=2, J=269, T=200, edges=37, frontier=51, MILP_calls=70
  V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 4, 3, 2, 3]
  [backtrack] EXHAUSTED search space (146 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (160 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (159 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (114 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (491 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (379 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (231 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (416 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (486 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (289 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (334 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (77 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 5, 7, 8, 11] → expanding 6 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 4, 3, 2, 3] → J=258, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 4, 3, 2, 3] → J=261, T=199, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 5, 3, 2, 3] → J=268, T=200, cost=3 → queued

[Iter 15] cost=2, J=269, T=200, edges=37, frontier=53, MILP_calls=73
  V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 3, 4, 3]
  [backtrack] EXHAUSTED search space (255 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (246 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (323 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (382 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (427 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (299 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (867 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (323 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (546 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (359 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (113 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (262 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 5, 7, 8, 10, 11] → expanding 7 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 4, 3] → J=252, T=199, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 2, 3, 4, 3] → J=257, T=198, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 3, 3, 4, 3] → J=264, T=199, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 3, 5, 3] → J=265, T=199, cost=3 → queued

[Iter 16] cost=2, J=267, T=199, edges=37, frontier=56, MILP_calls=77
  V_MIN=[2, 1, 4, 2, 2, 3, 2, 2, 2, 4, 2, 3]
  [backtrack] EXHAUSTED search space (116 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (175 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (166 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (221 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (189 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (174 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (286 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (239 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (76 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (204 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (224 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (118 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 5, 7, 9, 10, 11] → expanding 7 children
    V_MIN=[3, 1, 4, 2, 2, 3, 2, 2, 2, 4, 2, 3] → J=252, T=198, cost=3 → queued
    V_MIN=[2, 1, 5, 2, 2, 3, 2, 2, 2, 4, 2, 3] → J=265, T=199, cost=3 → queued
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 3, 2, 4, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 2, 2, 5, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 2, 2, 4, 2, 4] → J=267, T=199, cost=3 → queued

[Iter 17] cost=2, J=267, T=199, edges=36, frontier=58, MILP_calls=82
  V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 4, 2, 4]
  [backtrack] Found solution with 74 backtracks in 0.00s
  [backtrack] Found solution with 378 backtracks in 0.00s
  [backtrack] Found solution with 402 backtracks in 0.00s
  [backtrack] Found solution with 489 backtracks in 0.00s
  [backtrack] Found solution with 442 backtracks in 0.00s
  [backtrack] Found solution with 432 backtracks in 0.00s
  [backtrack] Found solution with 516 backtracks in 0.00s
  [backtrack] Found solution with 298 backtracks in 0.00s
  [backtrack] Found solution with 266 backtracks in 0.00s
  [backtrack] Found solution with 483 backtracks in 0.00s
  [backtrack] Found solution with 186 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (187 backtracks in 0.00s)
  DFS: latency violated (1 nodes, worst_gap=85.2s)
  Boundary nodes: [0, 5, 7, 9, 10, 11] → expanding 6 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 2, 4, 2, 4] → J=258, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 2, 4, 2, 4] → J=263, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 5, 2, 4] → J=265, T=198, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 2, 2, 4, 2, 5] → MILP infeasible, pruned

[Iter 18] cost=2, J=263, T=200, edges=36, frontier=60, MILP_calls=86
  V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (200 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (204 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (292 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (234 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (230 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (226 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (90 backtracks in 0.00s)
  [backtrack] Found solution with 59 backtracks in 0.00s
  [backtrack] Found solution with 63 backtracks in 0.00s
  [backtrack] Found solution with 39 backtracks in 0.00s
  [backtrack] Found solution with 217 backtracks in 0.00s
  [backtrack] Found solution with 164 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=97.4s)
  Boundary nodes: [0, 2, 5, 7, 8, 10] → expanding 6 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 3, 3, 3, 2, 3] → J=250, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 4, 3, 3, 2, 3] → J=257, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 3, 3, 3, 3] → J=260, T=199, cost=3 → queued

[Iter 19] cost=2, J=263, T=200, edges=36, frontier=62, MILP_calls=89
  V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 2, 4, 2, 3]
  [backtrack] EXHAUSTED search space (200 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (204 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (292 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (234 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (230 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (226 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (90 backtracks in 0.00s)
  [backtrack] Found solution with 59 backtracks in 0.00s
  [backtrack] Found solution with 63 backtracks in 0.00s
  [backtrack] Found solution with 39 backtracks in 0.00s
  [backtrack] Found solution with 217 backtracks in 0.00s
  [backtrack] Found solution with 164 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=97.4s)
  Boundary nodes: [0, 2, 5, 7, 9, 10] → expanding 6 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 3, 2, 4, 2, 3] → J=246, T=198, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 4, 2, 4, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 2, 5, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 2, 4, 3, 3] → J=259, T=199, cost=3 → queued

[Iter 20] cost=2, J=262, T=199, edges=36, frontier=63, MILP_calls=93
  V_MIN=[2, 1, 4, 2, 2, 3, 2, 3, 2, 3, 2, 3]
  [backtrack] Found solution with 90 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (130 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (139 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (128 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (129 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (46 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (157 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (153 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (109 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (80 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (75 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=121.1s)
  Boundary nodes: [0, 2, 5, 7, 9, 10] → expanding 6 children
    V_MIN=[3, 1, 4, 2, 2, 3, 2, 3, 2, 3, 2, 3] → J=241, T=200, cost=3 → queued
    V_MIN=[2, 1, 5, 2, 2, 3, 2, 3, 2, 3, 2, 3] → J=249, T=200, cost=3 → queued
    V_MIN=[2, 1, 4, 2, 2, 4, 2, 3, 2, 3, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 4, 2, 2, 3, 2, 4, 2, 3, 2, 3] → MILP infeasible, pruned

[Iter 21] cost=2, J=260, T=198, edges=36, frontier=64, MILP_calls=97
  V_MIN=[2, 1, 3, 2, 2, 3, 2, 3, 2, 3, 3, 3]
  [backtrack] EXHAUSTED search space (161 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (73 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (201 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (143 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (142 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (141 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (105 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (136 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (132 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (130 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (56 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 5, 7, 9, 10] → expanding 5 children
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 3, 2, 3, 3, 3] → J=249, T=199, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 3, 2, 4, 2, 3, 3, 3] → J=247, T=200, cost=3 → queued

[Iter 22] cost=2, J=259, T=200, edges=37, frontier=65, MILP_calls=99
  V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 3, 3, 2, 3]
  [backtrack] EXHAUSTED search space (79 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (81 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (67 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (42 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (112 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (33 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (135 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (134 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (55 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (125 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (73 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 7, 8, 9, 10, 11] → expanding 7 children
    V_MIN=[4, 1, 3, 2, 2, 3, 2, 2, 3, 3, 2, 3] → J=246, T=200, cost=3 → queued
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 3, 4, 2, 3] → J=258, T=200, cost=3 → queued
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 3, 3, 3, 3] → J=254, T=200, cost=3 → queued

[Iter 23] cost=2, J=258, T=198, edges=36, frontier=67, MILP_calls=102
  V_MIN=[2, 1, 3, 2, 2, 4, 2, 3, 2, 3, 2, 3]
  [backtrack] Found solution with 63 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (244 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (200 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (201 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (250 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (251 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (87 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (177 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (191 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (128 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (94 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (53 backtracks in 0.00s)
  DFS: latency violated (3 nodes, worst_gap=173.2s)
  Boundary nodes: [0, 2, 5, 7, 9, 10, 11] → expanding 7 children
    V_MIN=[3, 1, 3, 2, 2, 4, 2, 3, 2, 3, 2, 3] → J=246, T=200, cost=3 → queued
    V_MIN=[2, 1, 3, 2, 2, 5, 2, 3, 2, 3, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 4, 2, 3, 2, 3] → MILP infeasible, pruned
    V_MIN=[2, 1, 3, 2, 2, 4, 2, 3, 2, 3, 2, 4] → MILP infeasible, pruned

[Iter 24] cost=2, J=258, T=200, edges=36, frontier=67, MILP_calls=106
  V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 2, 4, 2, 3]
  [backtrack] Found solution with 136 backtracks in 0.00s
  [backtrack] Found solution with 130 backtracks in 0.00s
  [backtrack] Found solution with 146 backtracks in 0.00s
  [backtrack] Found solution with 202 backtracks in 0.00s
  [backtrack] Found solution with 119 backtracks in 0.00s
  [backtrack] Found solution with 127 backtracks in 0.00s
  [backtrack] Found solution with 103 backtracks in 0.00s
  [backtrack] Found solution with 81 backtracks in 0.00s
    ✓ Latency-feasible! source=7, T_tour=200.0s
  DFS: latency violated (1 nodes, worst_gap=83.0s)
  Boundary nodes: [0, 2, 4, 5, 7, 9, 10] → expanding 7 children
    V_MIN=[4, 1, 3, 2, 2, 3, 2, 2, 2, 4, 2, 3] → J=248, T=198, cost=3 → queued
    V_MIN=[3, 1, 3, 2, 3, 3, 2, 2, 2, 4, 2, 3] → J=256, T=200, cost=3 → queued
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 2, 5, 2, 3] → J=258, T=199, cost=3 → queued
    V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 2, 4, 3, 3] → J=254, T=200, cost=3 → queued

[Iter 25] cost=2, J=258, T=200, edges=36, frontier=70, MILP_calls=110
  V_MIN=[3, 1, 3, 2, 2, 3, 2, 2, 2, 3, 2, 4]
  [backtrack] Found solution with 188 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=200.0s
  *** SOLUTION FOUND! J=258, T_tour=200.0s ***

============================================================
Search done: 25 iters, 110 MILP calls, 110 states visited

Original flow_B is latency-feasible ✓
  flow_B = [3, -3, 0, 0, 3, -3, 0, 3, -2, 0, -1, -2, 1, -2, 2, 1, -2, 0, -4, 1, -2, -1]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [3, -3, 0, 0, 3, -3, 0, 3, -2, 0, -1, -2, 1, -2, 2, 1, -2, 0, -4, 1, -2, -1]
  Non-zero edges: [((0, 1), np.int64(3)), ((0, 11), np.int64(-3)), ((1, 5), np.int64(3)), ((2, 3), np.int64(-3)), ((2, 11), np.int64(3)), ((3, 4), np.int64(-2)), ((3, 8), np.int64(-1)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(1)), ((6, 7), np.int64(-2)), ((6, 9), np.int64(2)), ((6, 10), np.int64(1)), ((7, 8), np.int64(-2)), ((8, 9), np.int64(-4)), ((8, 11), np.int64(1)), ((9, 10), np.int64(-2)), ((10, 11), np.int64(-1))]

Blocked edge 1: idx=19, edge=(8, 11), flow_B=1  →  need Cm[19]=-1
Blocked edge 2: idx=12, edge=(5, 6), flow_B=1  →  need Cm[12]=-1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=10   ||Cm||_1=10

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 0, -1, 0, 0, -1, -1, 0, 0, 0, 0]

Cm = C_oriented @ beta*:
  [-1, 1, 0, -1, 0, 1, -1, 0, -1, 1, 0, -1, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0]

Original flow_B:
  [3, -3, 0, 0, 3, -3, 0, 3, -2, 0, -1, -2, 1, -2, 2, 1, -2, 0, -4, 1, -2, -1]

flow_B + Cm (corrected flow):
  [2, -2, 0, -1, 3, -2, -1, 3, -3, 1, -1, -3, 0, -2, 2, 1, -2, 0, -4, 0, -2, -1]

Verification:
  flow_corrected[19] = 0  (should be 0, Cm=-1, d=-1)
  flow_corrected[12] = 0  (should be 0, Cm=-1, d=-1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 10  (minimized by MIQP)
  ||Cm||_1  = 10
  ||flow_B||_2² = 90
  ||flow_corrected||_2² = 86

Time difference (|corrected| - |flow_B|) * tau:
  Total: -0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         3      -1           2    6.0     -6.0s
    1     (0, 11)        -3       1          -2    6.1     -6.1s
    2      (1, 2)         0       0           0    5.4          
    3      (1, 3)         0      -1          -1    7.9     +7.9s
    4      (1, 5)         3       0           3    5.0          
    5      (2, 3)        -3       1          -2    5.6     -5.6s
    6      (2, 8)         0      -1          -1    7.3     +7.3s
    7     (2, 11)         3       0           3    5.5          
    8      (3, 4)        -2      -1          -3    4.9     +4.9s
    9      (3, 6)         0       1           1    6.1     +6.1s
   10      (3, 8)        -1       0          -1    5.3          
   11      (4, 5)        -2      -1          -3    4.2     +4.2s
   12      (5, 6)         1      -1           0    5.2     -5.2s ← BLOCKED
   13      (6, 7)        -2       0          -2    7.2          
   14      (6, 9)         2       0           2    5.1          
   15     (6, 10)         1       0           1    4.9          
   16      (7, 8)        -2       0          -2    5.8          
   17     (7, 10)         0       0           0    8.0          
   18      (8, 9)        -4       0          -4    5.4          
   19     (8, 11)         1      -1           0    7.6     -7.6s ← BLOCKED
   20     (9, 10)        -2       0          -2    5.5          
   21    (10, 11)        -1       0          -1    5.4          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=3, out=3  OK
  Node 2: in=3, out=3  OK
  Node 3: in=4, out=4  OK
  Node 4: in=3, out=3  OK
  Node 5: in=3, out=3  OK
  Node 6: in=3, out=3  OK
  Node 7: in=2, out=2  OK
  Node 8: in=4, out=4  OK
  Node 9: in=4, out=4  OK
  Node 10: in=2, out=2  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 36 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 21

  Summary:
    Original path length:  36 edges
    Spliced path length:   36 edges
    Splices performed:     21
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           0         0  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)           3         3  ✓
    5      (2, 3)          -2        -2  ✓
    6      (2, 8)          -1        -1  ✓
    7     (2, 11)           3         3  ✓
    8      (3, 4)          -3        -3  ✓
    9      (3, 6)           1         1  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)          -3        -3  ✓
   12      (5, 6)           0         0  ✓
   13      (6, 7)          -2        -2  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)           1         1  ✓
   16      (7, 8)          -2        -2  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)          -4        -4  ✓
   19     (8, 11)           0         0  ✓
   20     (9, 10)          -2        -2  ✓
   21    (10, 11)          -1        -1  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 96
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2, 2] → J=249, T=199, cost=0 → queued

[Iter 1] cost=0, J=249, T=199, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2, 2]
  [backtrack] Found solution with 6 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 3 backtracks in 0.00s
    ✓ Latency-feasible! source=4, T_tour=198.6s
  DFS: latency violated (1 nodes, worst_gap=113.0s)
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2, 2] → J=230, T=200, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 3, 2, 2, 2, 2, 1, 2, 2] → J=233, T=199, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 2, 3, 2, 2, 2, 1, 2, 2] → J=233, T=199, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 3, 2, 2, 1, 2, 2] → J=233, T=199, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 3, 2, 1, 2, 2] → J=235, T=197, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 2, 3, 1, 2, 2] → J=238, T=198, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2] → J=241, T=199, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 3, 2] → J=235, T=200, cost=1 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 2, 2, 2, 1, 2, 3] → J=236, T=199, cost=1 → queued

[Iter 2] cost=1, J=241, T=199, edges=37, frontier=8, MILP_calls=10
  V_MIN=[2, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2]
  [backtrack] Found solution with 16 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 60 backtracks in 0.00s
    ✓ Latency-feasible! source=3, T_tour=198.6s
  *** SOLUTION FOUND! J=241, T_tour=198.6s ***

============================================================
Search done: 2 iters, 10 MILP calls, 10 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, -3, 7, -2, -5, 2, 0, 2, 0, 0, 2, 0, -2, 2, 0, -2, 0, 0, 0, 2, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, -3, 7, -2, -5, 2, 0, 2, 0, 0, 2, 0, -2, 2, 0, -2, 0, 0, 0, 2, 2]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(-3)), ((1, 3), np.int64(7)), ((1, 5), np.int64(-2)), ((2, 3), np.int64(-5)), ((2, 8), np.int64(2)), ((3, 4), np.int64(2)), ((4, 5), np.int64(2)), ((6, 7), np.int64(-2)), ((6, 9), np.int64(2)), ((7, 8), np.int64(-2)), ((9, 10), np.int64(2)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=3, edge=(1, 3), flow_B=7  →  need Cm[3]=-7
Blocked edge 2: idx=1, edge=(0, 11), flow_B=-2  →  need Cm[1]=2
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=98   ||Cm||_1=32

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [4, 0, -2, 1, -3, 2, -2, 0, 0, -3, 0]

Cm = C_oriented @ beta*:
  [-2, 2, 2, -7, 3, 1, 1, 0, -1, -2, -3, -1, 2, 0, 1, -1, 0, 0, 0, -2, 1, 0]

Original flow_B:
  [2, -2, -3, 7, -2, -5, 2, 0, 2, 0, 0, 2, 0, -2, 2, 0, -2, 0, 0, 0, 2, 2]

flow_B + Cm (corrected flow):
  [0, 0, -1, 0, 1, -4, 3, 0, 1, -2, -3, 1, 2, -2, 3, -1, -2, 0, 0, -2, 3, 2]

Verification:
  flow_corrected[3] = 0  (should be 0, Cm=-7, d=-7)
  flow_corrected[1] = 0  (should be 0, Cm=2, d=2)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 98  (minimized by MIQP)
  ||Cm||_1  = 32
  ||flow_B||_2² = 127
  ||flow_corrected||_2² = 81

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2      -2           0    6.0    -12.0s
    1     (0, 11)        -2       2           0    5.2    -10.4s ← BLOCKED
    2      (1, 2)        -3       2          -1    5.2    -10.4s
    3      (1, 3)         7      -7           0    4.6    -32.2s ← BLOCKED
    4      (1, 5)        -2       3           1    4.1     -4.1s
    5      (2, 3)        -5       1          -4    5.6     -5.6s
    6      (2, 8)         2       1           3    7.0     +7.0s
    7     (2, 11)         0       0           0    7.4          
    8      (3, 4)         2      -1           1    6.6     -6.6s
    9      (3, 6)         0      -2          -2    7.9    +15.8s
   10      (3, 8)         0      -3          -3    6.6    +19.8s
   11      (4, 5)         2      -1           1    7.0     -7.0s
   12      (5, 6)         0       2           2    7.3    +14.6s
   13      (6, 7)        -2       0          -2    4.0          
   14      (6, 9)         2       1           3    6.1     +6.1s
   15     (6, 10)         0      -1          -1    7.7     +7.7s
   16      (7, 8)        -2       0          -2    4.7          
   17     (7, 10)         0       0           0    7.9          
   18      (8, 9)         0       0           0    5.9          
   19     (8, 11)         0      -2          -2    6.2    +12.4s
   20     (9, 10)         2       1           3    5.0     +5.0s
   21    (10, 11)         2       0           2    5.7          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 1: in=1, out=1  OK
  Node 2: in=4, out=4  OK
  Node 3: in=5, out=5  OK
  Node 4: in=1, out=1  OK
  Node 5: in=2, out=2  OK
  Node 6: in=5, out=5  OK
  Node 7: in=2, out=2  OK
  Node 8: in=5, out=5  OK
  Node 9: in=3, out=3  OK
  Node 10: in=3, out=3  OK
  Node 11: in=2, out=2  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 33 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 20

  Summary:
    Original path length:  37 edges
    Spliced path length:   33 edges
    Splices performed:     20
    Path is continuous:    True
    Returns to source 3: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           0         0  ✓
    1     (0, 11)           0         0  ✓
    2      (1, 2)          -1        -1  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)           1         1  ✓
    5      (2, 3)          -4        -4  ✓
    6      (2, 8)           3         3  ✓
    7     (2, 11)           0         0  ✓
    8      (3, 4)           1         1  ✓
    9      (3, 6)          -2        -2  ✓
   10      (3, 8)          -3        -3  ✓
   11      (4, 5)           1         1  ✓
   12      (5, 6)           2         2  ✓
   13      (6, 7)          -2        -2  ✓
   14      (6, 9)           3         3  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)          -2        -2  ✓
   17     (7, 10)           0         0  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)          -2        -2  ✓
   20     (9, 10)           3         3  ✓
   21    (10, 11)           2         2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 97
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2, 2] → J=243, T=199, cost=0 → queued

[Iter 1] cost=0, J=243, T=199, edges=38, frontier=0, MILP_calls=1
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2, 2] → J=239, T=199, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2] → J=241, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2] → J=241, T=199, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 1, 2, 2, 2] → J=243, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 2, 2, 2] → J=241, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2] → J=240, T=198, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 3, 2, 2] → J=239, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 3, 2] → J=243, T=200, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2, 3] → J=239, T=200, cost=1 → queued

[Iter 2] cost=1, J=243, T=200, edges=38, frontier=8, MILP_calls=10
  V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (1075 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (820 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1997 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (951 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1170 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1696 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (625 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (627 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (423 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (613 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1060 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1271 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 2, 4, 3, 1, 2, 2, 2] → J=239, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 4, 3, 1, 2, 2, 2] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 1, 2, 2, 2] → J=241, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 1, 2, 2, 2] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 2, 2, 2, 2] → J=240, T=198, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 1, 3, 2, 2] → J=239, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 1, 2, 2, 3] → J=239, T=199, cost=2 → queued

[Iter 3] cost=1, J=243, T=200, edges=38, frontier=14, MILP_calls=17
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 3, 2]
  [backtrack] EXHAUSTED search space (1075 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (820 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1997 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (951 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1170 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1696 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (625 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (627 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (423 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (613 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1060 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1271 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 1, 2, 3, 2] → J=239, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 2, 3, 2] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 2, 3, 2] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 2, 3, 2] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 3, 2] → J=240, T=198, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 3, 3, 2] → J=239, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 3, 3] → J=239, T=200, cost=2 → queued

[Iter 4] cost=1, J=241, T=200, edges=37, frontier=20, MILP_calls=24
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (461 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (342 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (502 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (492 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (318 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (277 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (798 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (490 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (162 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (428 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (508 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (267 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 1, 2, 2, 2] → J=237, T=198, cost=2 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 1, 2, 2, 2] → J=241, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 1, 2, 2, 2] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 1, 2, 2, 2] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 1, 2, 2, 2] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 2, 2, 2, 2] → J=240, T=198, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 3, 2, 2] → J=238, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 2, 2, 3] → J=238, T=200, cost=2 → queued

[Iter 5] cost=1, J=241, T=199, edges=36, frontier=27, MILP_calls=32
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (430 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (334 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (712 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (606 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (497 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (293 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (618 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (756 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (182 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (462 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (431 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (470 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2] → J=238, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 1, 2, 2, 2] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 2] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 1, 2, 2, 2] → J=238, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 2, 2, 2, 2] → J=239, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 3, 2, 2] → J=239, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 2, 2, 3] → J=238, T=200, cost=2 → queued

[Iter 6] cost=1, J=241, T=200, edges=37, frontier=33, MILP_calls=39
  V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2] → J=236, T=200, cost=2 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2] → J=240, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 3, 3, 1, 2, 2, 2] → J=238, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 2, 2, 2, 2] → J=238, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 3, 2, 2] → J=235, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 3] → J=236, T=200, cost=2 → queued

[Iter 7] cost=1, J=240, T=198, edges=36, frontier=38, MILP_calls=45
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2] → J=237, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 3, 2, 2, 2] → J=239, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 3, 2, 2] → J=237, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 3] → J=237, T=199, cost=2 → queued

[Iter 8] cost=1, J=239, T=199, edges=37, frontier=41, MILP_calls=49
  V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9] → expanding 6 children
    V_MIN=[4, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2, 2] → J=237, T=200, cost=2 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 1, 3, 2, 2] → J=236, T=200, cost=2 → queued

[Iter 9] cost=1, J=239, T=200, edges=37, frontier=42, MILP_calls=51
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [4, 5, 7, 8, 9, 11] → expanding 6 children
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 3, 2, 3] → J=236, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2, 4] → J=237, T=200, cost=2 → queued

[Iter 10] cost=1, J=239, T=200, edges=38, frontier=43, MILP_calls=53
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 3, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 4, 2, 2] → J=236, T=199, cost=2 → queued

[Iter 11] cost=2, J=241, T=200, edges=37, frontier=43, MILP_calls=54
  V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (401 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (295 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (197 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (433 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (373 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (260 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (590 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (648 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (360 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (511 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (609 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (278 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 4, 4, 1, 2, 2, 2] → J=237, T=198, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 4, 4, 1, 2, 2, 2] → J=241, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 4, 4, 1, 2, 2, 2] → J=241, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 4, 4, 1, 2, 2, 2] → J=241, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 4, 1, 2, 2, 2] → J=241, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2] → J=240, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 1, 3, 2, 2] → J=238, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 1, 2, 2, 3] → J=238, T=200, cost=3 → queued

[Iter 12] cost=2, J=241, T=200, edges=37, frontier=50, MILP_calls=62
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 2, 3, 2]
  [backtrack] EXHAUSTED search space (479 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (342 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (502 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (277 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (305 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (492 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (811 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (544 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (177 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (466 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (508 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (269 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 1, 2, 3, 2] → J=237, T=198, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 1, 2, 3, 2] → J=241, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 1, 2, 3, 2] → J=241, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 1, 2, 3, 2] → J=241, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 1, 2, 3, 2] → J=241, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 2, 2, 3, 2] → J=240, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 3, 3, 2] → J=238, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 2, 3, 3] → J=238, T=200, cost=3 → queued

[Iter 13] cost=2, J=241, T=199, edges=36, frontier=57, MILP_calls=70
  V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (430 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (334 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (712 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (606 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (497 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (293 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (618 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (756 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (182 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (462 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (431 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (470 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 3, 4, 3, 1, 2, 2, 2] → J=238, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 4, 3, 1, 2, 2, 2] → J=241, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 4, 3, 1, 2, 2, 2] → J=241, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 4, 3, 1, 2, 2, 2] → J=237, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 2, 2, 2, 2] → J=239, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 1, 3, 2, 2] → J=239, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 1, 2, 2, 3] → J=238, T=200, cost=3 → queued

[Iter 14] cost=2, J=241, T=199, edges=36, frontier=63, MILP_calls=77
  V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (553 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (491 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (244 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (241 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (435 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (580 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (155 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (722 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (424 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (432 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (660 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (485 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 3, 2, 2, 2, 3, 4, 1, 2, 2, 2] → J=237, T=198, cost=3 → queued
    V_MIN=[2, 3, 4, 2, 2, 2, 3, 4, 1, 2, 2, 2] → J=240, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 3, 4, 1, 2, 2, 2] → J=240, T=198, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 4, 1, 2, 2, 2] → J=240, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 2, 2, 2, 2] → J=240, T=198, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 1, 3, 2, 2] → J=238, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 1, 2, 2, 3] → J=238, T=200, cost=3 → queued

[Iter 15] cost=2, J=241, T=200, edges=37, frontier=69, MILP_calls=84
  V_MIN=[2, 3, 2, 2, 3, 2, 4, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 2, 2, 3, 2, 4, 3, 1, 2, 2, 2] → J=233, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 4, 3, 1, 2, 2, 2] → J=240, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 4, 3, 1, 2, 2, 2] → J=234, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 4, 3, 2, 2, 2, 2] → J=238, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 4, 3, 1, 3, 2, 2] → J=235, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 4, 3, 1, 2, 2, 3] → J=235, T=200, cost=3 → queued

[Iter 16] cost=2, J=241, T=200, edges=37, frontier=74, MILP_calls=90
  V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 2, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 3, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 1, 2, 3, 2] → J=240, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 3, 3, 1, 2, 3, 2] → J=236, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 2, 2, 3, 2] → J=238, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 3, 3, 2] → J=235, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 2, 3, 3] → J=236, T=200, cost=3 → queued

[Iter 17] cost=2, J=241, T=200, edges=37, frontier=79, MILP_calls=96
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 2, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 5, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 1, 2, 3, 2] → J=238, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 3, 1, 2, 3, 2] → J=241, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 1, 2, 3, 2] → J=237, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 2, 2, 3, 2] → J=239, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 3, 3, 2] → J=239, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 2, 3, 3] → J=238, T=200, cost=3 → queued

[Iter 18] cost=2, J=241, T=200, edges=37, frontier=84, MILP_calls=102
  V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 3, 2, 2, 3, 4, 1, 2, 2, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 4, 2, 2, 3, 4, 1, 2, 2, 2] → J=240, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 5, 1, 2, 2, 2] → J=240, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 2, 2, 2, 2] → J=240, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 1, 3, 2, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 1, 2, 2, 3] → J=236, T=200, cost=3 → queued

[Iter 19] cost=2, J=241, T=200, edges=37, frontier=89, MILP_calls=108
  V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 3, 2, 3, 4, 1, 2, 2, 2] → J=230, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 3, 4, 1, 2, 2, 2] → J=233, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 5, 1, 2, 2, 2] → J=237, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 2, 2, 2, 2] → J=238, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 1, 3, 2, 2] → J=234, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 1, 2, 2, 3] → J=234, T=199, cost=3 → queued

[Iter 20] cost=2, J=241, T=200, edges=37, frontier=94, MILP_calls=114
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 4, 1, 2, 2, 2] → J=234, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 4, 1, 2, 2, 2] → J=241, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 4, 1, 2, 2, 2] → J=237, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 5, 1, 2, 2, 2] → J=241, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 2, 2, 2, 2] → J=239, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 1, 3, 2, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 1, 2, 2, 3] → J=238, T=200, cost=3 → queued

[Iter 21] cost=2, J=241, T=200, edges=37, frontier=100, MILP_calls=121
  V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 3, 2, 3, 3, 3, 1, 2, 2, 2] → J=238, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 3, 2, 3, 3, 3, 1, 2, 2, 2] → J=240, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 4, 2, 3, 3, 3, 1, 2, 2, 2] → J=240, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 4, 3, 3, 1, 2, 2, 2] → J=238, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 2, 2, 2, 2] → J=239, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 1, 3, 2, 2] → J=235, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 1, 2, 2, 3] → J=238, T=200, cost=3 → queued

[Iter 22] cost=2, J=241, T=200, edges=37, frontier=106, MILP_calls=128
  V_MIN=[2, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 3, 3, 3, 3, 1, 2, 2, 2] → J=240, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 4, 3, 3, 3, 1, 2, 2, 2] → J=238, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 4, 3, 3, 1, 2, 2, 2] → J=238, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 3, 3, 2, 2, 2, 2] → J=238, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 3, 3, 1, 3, 2, 2] → J=235, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 3] → J=236, T=200, cost=3 → queued

[Iter 23] cost=2, J=240, T=198, edges=36, frontier=112, MILP_calls=135
  V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 2, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 2, 2, 2, 2, 4, 3, 2, 2, 2, 2] → J=237, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 3, 2, 2, 2] → J=239, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 2, 3, 2, 2] → J=237, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 2, 2, 2, 3] → J=237, T=199, cost=3 → queued

[Iter 24] cost=2, J=240, T=198, edges=36, frontier=115, MILP_calls=139
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 8, 9, 10, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 2, 2, 3, 2] → J=236, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 3, 2, 3, 2] → J=236, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 3, 3, 2] → J=237, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 4, 2] → J=238, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3] → J=236, T=199, cost=3 → queued

[Iter 25] cost=2, J=240, T=198, edges=36, frontier=119, MILP_calls=144
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 2, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 2, 2, 2, 2] → J=237, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 3, 2, 2, 2] → J=239, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 2, 3, 2, 2] → J=236, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 2, 2, 2, 3] → J=237, T=199, cost=3 → queued

[Iter 26] cost=2, J=240, T=200, edges=37, frontier=122, MILP_calls=148
  V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 8, 9, 11] → expanding 5 children
    V_MIN=[3, 3, 3, 2, 3, 2, 3, 3, 1, 2, 2, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 4, 2, 3, 3, 1, 2, 2, 2] → J=238, T=199, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 2, 2, 2, 2] → J=238, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 1, 3, 2, 2] → J=234, T=198, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 1, 2, 2, 3] → J=236, T=200, cost=3 → queued

[Iter 27] cost=2, J=239, T=199, edges=37, frontier=126, MILP_calls=153
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (1041 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1292 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (262 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1292 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (923 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (668 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (287 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (593 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (535 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (443 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (219 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (841 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 8, 9, 10, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 3, 2, 2, 2] → J=235, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 3, 2, 2, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 3, 2, 2, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 4, 2, 2, 2] → J=234, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 3, 3, 2, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 3, 2, 2, 3] → J=235, T=199, cost=3 → queued

[Iter 28] cost=2, J=239, T=200, edges=36, frontier=131, MILP_calls=159
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (667 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (500 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1091 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (646 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (720 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1045 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (221 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1037 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (747 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (595 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (739 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (633 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 2, 2, 2, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 3, 2, 2, 2, 2] → J=238, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 2, 2, 2, 2] → J=237, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 2, 3, 2, 2] → J=235, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 2, 2, 2, 3] → J=236, T=200, cost=3 → queued

[Iter 29] cost=2, J=239, T=200, edges=37, frontier=135, MILP_calls=164
  V_MIN=[3, 3, 2, 2, 2, 2, 4, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9] → expanding 7 children
    V_MIN=[4, 3, 2, 2, 2, 2, 4, 3, 1, 2, 2, 2] → J=233, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 5, 3, 1, 2, 2, 2] → J=238, T=199, cost=3 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 4, 3, 1, 3, 2, 2] → J=236, T=200, cost=3 → queued

[Iter 30] cost=2, J=239, T=199, edges=37, frontier=137, MILP_calls=167
  V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 1, 2, 2, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [4, 5, 6, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[2, 3, 2, 2, 2, 2, 5, 3, 1, 2, 2, 3] → J=238, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 1, 3, 2, 3] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 1, 2, 2, 4] → J=233, T=200, cost=3 → queued

[Iter 31] cost=2, J=239, T=200, edges=37, frontier=139, MILP_calls=170
  V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 1, 2, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9] → expanding 6 children
    V_MIN=[4, 3, 2, 2, 2, 2, 3, 3, 1, 2, 3, 2] → J=235, T=199, cost=3 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 1, 3, 3, 2] → J=236, T=200, cost=3 → queued

[Iter 32] cost=2, J=239, T=200, edges=37, frontier=140, MILP_calls=172
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 3, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [4, 5, 7, 8, 9, 11] → expanding 6 children
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 3, 3, 3] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 3, 4] → J=235, T=199, cost=3 → queued

[Iter 33] cost=2, J=239, T=200, edges=38, frontier=141, MILP_calls=174
  V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 1, 3, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 1, 4, 2, 2] → J=236, T=199, cost=3 → queued

[Iter 34] cost=2, J=239, T=200, edges=38, frontier=141, MILP_calls=175
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 3, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 4, 3, 2] → J=236, T=199, cost=3 → queued

[Iter 35] cost=2, J=239, T=200, edges=37, frontier=141, MILP_calls=176
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 3, 2, 2]
  [backtrack] EXHAUSTED search space (453 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (380 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (986 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (868 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (771 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (524 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (550 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (509 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (278 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (606 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (977 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (755 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 1, 3, 2, 2] → J=234, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 1, 3, 2, 2] → J=234, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 4, 2, 2] → J=234, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 3, 2, 3] → J=234, T=199, cost=3 → queued

[Iter 36] cost=2, J=238, T=199, edges=37, frontier=144, MILP_calls=180
  V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (576 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (464 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1320 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (941 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1021 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1304 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (169 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (482 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (246 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (218 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (396 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (728 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 5, 6, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 4, 3, 3, 1, 2, 2, 2] → J=234, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 5, 3, 3, 1, 2, 2, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 1, 2, 2, 3] → J=236, T=200, cost=3 → queued

[Iter 37] cost=2, J=238, T=200, edges=37, frontier=146, MILP_calls=183
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 2, 2, 3]
  [backtrack] EXHAUSTED search space (912 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (953 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1057 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (433 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (571 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1013 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (864 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (496 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (727 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (801 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (576 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 1, 2, 2, 3] → J=237, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 5, 1, 2, 2, 3] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 3, 2, 3] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 2, 2, 4] → J=231, T=199, cost=3 → queued

[Iter 38] cost=2, J=238, T=200, edges=37, frontier=149, MILP_calls=187
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 2, 2, 3]
  [backtrack] EXHAUSTED search space (599 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (530 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1291 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1159 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (982 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (567 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (571 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (892 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (516 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (272 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (892 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (999 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 1, 2, 2, 3] → J=238, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 2, 2, 4] → J=232, T=200, cost=3 → queued

[Iter 39] cost=2, J=238, T=199, edges=37, frontier=150, MILP_calls=189
  V_MIN=[2, 3, 2, 2, 4, 2, 3, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 6, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 4, 2, 3, 3, 1, 2, 2, 2] → J=226, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 5, 2, 3, 3, 1, 2, 2, 2] → J=224, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 3, 3, 2, 2, 2, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 3, 3, 1, 3, 2, 2] → J=232, T=197, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 3, 3, 1, 2, 2, 3] → J=230, T=200, cost=3 → queued

[Iter 40] cost=2, J=238, T=200, edges=37, frontier=154, MILP_calls=194
  V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (1046 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1227 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (435 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (729 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1074 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1486 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (606 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1111 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (910 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (482 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (812 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (825 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 8, 9, 11] → expanding 5 children
    V_MIN=[3, 3, 2, 2, 3, 2, 3, 3, 2, 2, 2, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 2, 3, 2, 2] → J=234, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 2, 2, 2, 3] → J=236, T=200, cost=3 → queued

[Iter 41] cost=2, J=238, T=199, edges=37, frontier=156, MILP_calls=197
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 3, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 1, 3, 2, 2] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 5, 1, 3, 2, 2] → J=236, T=198, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 4, 2, 2] → J=233, T=199, cost=3 → queued

[Iter 42] cost=2, J=238, T=200, edges=37, frontier=158, MILP_calls=200
  V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (2108 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1605 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3116 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1499 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1746 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2617 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (397 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1194 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (880 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1391 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1310 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2080 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9] → expanding 6 children
    V_MIN=[4, 3, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2] → J=230, T=197, cost=3 → queued

[Iter 43] cost=2, J=237, T=200, edges=38, frontier=158, MILP_calls=201
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 3, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 2, 3, 2, 2] → J=234, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 4, 2, 2] → J=235, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 3, 2, 3] → J=234, T=200, cost=3 → queued

[Iter 44] cost=2, J=237, T=198, edges=36, frontier=160, MILP_calls=204
  V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9] → expanding 7 children
    V_MIN=[4, 3, 2, 2, 2, 2, 3, 4, 1, 2, 2, 2] → J=230, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 5, 1, 2, 2, 2] → J=234, T=199, cost=3 → queued

[Iter 45] cost=2, J=237, T=199, edges=36, frontier=161, MILP_calls=206
  V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 8, 9, 10] → expanding 7 children
    V_MIN=[4, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2] → J=235, T=200, cost=3 → queued
    V_MIN=[3, 3, 2, 3, 2, 2, 3, 3, 2, 2, 2, 2] → J=236, T=199, cost=3 → queued

[Iter 46] cost=2, J=237, T=199, edges=36, frontier=162, MILP_calls=208
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [3, 4, 5, 8, 9, 10, 11] → expanding 7 children
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 3, 2, 2, 2, 3] → J=236, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 4] → J=235, T=200, cost=3 → queued

[Iter 47] cost=2, J=237, T=200, edges=36, frontier=163, MILP_calls=210
  V_MIN=[4, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7, 8, 9, 10] → expanding 9 children
    V_MIN=[5, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[4, 3, 2, 3, 2, 2, 3, 3, 1, 2, 2, 2] → J=233, T=200, cost=3 → queued
    V_MIN=[4, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2] → J=223, T=198, cost=3 → queued
    V_MIN=[4, 3, 2, 2, 2, 2, 3, 3, 1, 3, 2, 2] → J=229, T=200, cost=3 → queued

[Iter 48] cost=2, J=237, T=200, edges=36, frontier=165, MILP_calls=214
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2, 4]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [3, 4, 5, 6, 7, 8, 9, 10, 11] → expanding 9 children
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 3, 1, 2, 2, 4] → J=233, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 4] → J=229, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 3, 2, 4] → J=230, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2, 5] → J=225, T=200, cost=3 → queued

[Iter 49] cost=2, J=236, T=200, edges=36, frontier=168, MILP_calls=218
  V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 1, 3, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 8, 9] → expanding 6 children
    V_MIN=[3, 3, 2, 3, 2, 2, 3, 3, 1, 3, 2, 2] → J=234, T=199, cost=3 → queued
    V_MIN=[3, 3, 2, 2, 3, 2, 3, 3, 1, 3, 2, 2] → J=234, T=199, cost=3 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 1, 4, 2, 2] → J=231, T=198, cost=3 → queued

[Iter 50] cost=2, J=236, T=200, edges=36, frontier=170, MILP_calls=221
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 3, 2, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [3, 4, 5, 8, 9, 11] → expanding 6 children
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 3, 1, 3, 2, 3] → J=234, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 3, 2, 3] → J=234, T=199, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 4, 2, 3] → J=231, T=198, cost=3 → queued

[Iter 51] cost=2, J=236, T=200, edges=37, frontier=172, MILP_calls=224
  V_MIN=[3, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 6, 7, 9] → expanding 5 children

[Iter 52] cost=2, J=236, T=200, edges=37, frontier=171, MILP_calls=224
  V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 2, 2, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [4, 6, 7, 9, 11] → expanding 5 children

[Iter 53] cost=2, J=236, T=199, edges=37, frontier=170, MILP_calls=224
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 4, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 4, 2, 2] → J=234, T=200, cost=3 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 1, 5, 2, 2] → J=230, T=198, cost=3 → queued

[Iter 54] cost=2, J=235, T=199, edges=37, frontier=171, MILP_calls=226
  V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 1, 3, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 7, 8, 9, 11] → expanding 7 children

[Iter 55] cost=3, J=241, T=199, edges=36, frontier=170, MILP_calls=226
  V_MIN=[2, 3, 3, 2, 2, 2, 4, 4, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (430 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (334 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (712 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (606 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (497 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (293 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (618 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (756 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (182 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (462 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (431 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (470 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 3, 2, 2, 2, 4, 4, 1, 2, 2, 2] → J=237, T=198, cost=4 → queued
    V_MIN=[2, 3, 4, 2, 2, 2, 4, 4, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 4, 4, 1, 2, 2, 2] → J=240, T=198, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 4, 4, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 4, 4, 2, 2, 2, 2] → J=240, T=198, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 4, 4, 1, 3, 2, 2] → J=238, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 4, 4, 1, 2, 2, 3] → J=238, T=200, cost=4 → queued

[Iter 56] cost=3, J=241, T=199, edges=36, frontier=176, MILP_calls=233
  V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 1, 2, 3, 2]
  [backtrack] EXHAUSTED search space (430 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (334 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (712 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (606 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (497 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (293 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (618 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (756 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (182 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (462 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (431 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (470 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 3, 2, 2, 2, 3, 4, 1, 2, 3, 2] → J=237, T=198, cost=4 → queued
    V_MIN=[2, 3, 4, 2, 2, 2, 3, 4, 1, 2, 3, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 3, 4, 1, 2, 3, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 4, 1, 2, 3, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 2, 2, 3, 2] → J=240, T=198, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 1, 3, 3, 2] → J=238, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 1, 2, 3, 3] → J=238, T=200, cost=4 → queued

[Iter 57] cost=3, J=241, T=199, edges=36, frontier=182, MILP_calls=240
  V_MIN=[2, 3, 3, 2, 2, 3, 3, 3, 1, 2, 3, 2]
  [backtrack] EXHAUSTED search space (553 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (491 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (244 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (241 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (435 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (580 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (155 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (722 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (424 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (432 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (660 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (485 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 3, 2, 2, 3, 3, 3, 1, 2, 3, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 4, 2, 2, 3, 3, 3, 1, 2, 3, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 3, 2, 3, 3, 3, 1, 2, 3, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 3, 3, 3, 1, 2, 3, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 4, 3, 3, 1, 2, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 3, 2, 2, 3, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 3, 1, 3, 3, 2] → J=239, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 3, 1, 2, 3, 3] → J=238, T=200, cost=4 → queued

[Iter 58] cost=3, J=241, T=199, edges=36, frontier=189, MILP_calls=248
  V_MIN=[2, 3, 3, 2, 2, 3, 3, 4, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (553 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (491 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (244 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (241 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (435 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (580 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (155 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (722 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (424 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (432 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (660 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (485 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 3, 2, 2, 3, 3, 4, 1, 2, 2, 2] → J=234, T=199, cost=4 → queued
    V_MIN=[2, 3, 4, 2, 2, 3, 3, 4, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 3, 2, 3, 3, 4, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 3, 3, 4, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 4, 3, 4, 1, 2, 2, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 4, 2, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 4, 1, 3, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 4, 1, 2, 2, 3] → J=238, T=200, cost=4 → queued

[Iter 59] cost=3, J=241, T=199, edges=36, frontier=196, MILP_calls=256
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 5, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (553 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (491 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (244 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (241 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (435 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (580 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (155 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (722 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (424 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (432 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (660 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (485 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 5, 1, 2, 2, 2] → J=231, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 5, 1, 2, 2, 2] → J=239, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 3, 5, 1, 2, 2, 2] → J=237, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 5, 1, 2, 2, 2] → J=235, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 6, 1, 2, 2, 2] → J=231, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 5, 2, 2, 2, 2] → J=239, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 5, 1, 3, 2, 2] → J=233, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 5, 1, 2, 2, 3] → J=231, T=200, cost=4 → queued

[Iter 60] cost=3, J=241, T=200, edges=37, frontier=203, MILP_calls=264
  V_MIN=[2, 3, 2, 3, 2, 2, 4, 4, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 3, 2, 2, 4, 4, 1, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 4, 2, 2, 4, 4, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 4, 5, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 4, 4, 2, 2, 2, 2] → J=240, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 4, 4, 1, 3, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 4, 4, 1, 2, 2, 3] → J=236, T=200, cost=4 → queued

[Iter 61] cost=3, J=241, T=200, edges=37, frontier=208, MILP_calls=270
  V_MIN=[2, 3, 2, 2, 3, 2, 4, 4, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 3, 2, 4, 4, 1, 2, 2, 2] → J=230, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 4, 4, 1, 2, 2, 2] → J=231, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 4, 5, 1, 2, 2, 2] → J=237, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 4, 4, 2, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 4, 4, 1, 3, 2, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 4, 4, 1, 2, 2, 3] → J=234, T=199, cost=4 → queued

[Iter 62] cost=3, J=241, T=200, edges=37, frontier=213, MILP_calls=276
  V_MIN=[2, 3, 2, 2, 2, 3, 4, 4, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 3, 4, 4, 1, 2, 2, 2] → J=234, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 4, 4, 1, 2, 2, 2] → J=241, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 4, 4, 1, 2, 2, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 5, 1, 2, 2, 2] → J=241, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 4, 2, 2, 2, 2] → J=239, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 4, 1, 3, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 4, 1, 2, 2, 3] → J=238, T=200, cost=4 → queued

[Iter 63] cost=3, J=241, T=200, edges=37, frontier=219, MILP_calls=283
  V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 1, 2, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 3, 2, 2, 3, 4, 1, 2, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 4, 2, 2, 3, 4, 1, 2, 3, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 5, 1, 2, 3, 2] → J=240, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 2, 2, 3, 2] → J=240, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 1, 3, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 1, 2, 3, 3] → J=236, T=200, cost=4 → queued

[Iter 64] cost=3, J=241, T=200, edges=37, frontier=224, MILP_calls=289
  V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 1, 2, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 3, 2, 3, 4, 1, 2, 3, 2] → J=230, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 3, 4, 1, 2, 3, 2] → J=233, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 5, 1, 2, 3, 2] → J=237, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 2, 2, 3, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 1, 3, 3, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 1, 2, 3, 3] → J=234, T=199, cost=4 → queued

[Iter 65] cost=3, J=241, T=200, edges=37, frontier=229, MILP_calls=295
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 1, 2, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 4, 1, 2, 3, 2] → J=234, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 4, 1, 2, 3, 2] → J=241, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 4, 1, 2, 3, 2] → J=235, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 5, 1, 2, 3, 2] → J=241, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 2, 2, 3, 2] → J=239, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 1, 3, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 1, 2, 3, 3] → J=238, T=200, cost=4 → queued

[Iter 66] cost=3, J=241, T=200, edges=37, frontier=235, MILP_calls=302
  V_MIN=[2, 3, 2, 3, 2, 3, 4, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 3, 2, 3, 4, 3, 1, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 3, 2, 3, 4, 3, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 4, 2, 3, 4, 3, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 4, 4, 3, 1, 2, 2, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 4, 3, 2, 2, 2, 2] → J=239, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 4, 3, 1, 3, 2, 2] → J=235, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 4, 3, 1, 2, 2, 3] → J=238, T=200, cost=4 → queued

[Iter 67] cost=3, J=241, T=200, edges=37, frontier=241, MILP_calls=309
  V_MIN=[2, 3, 2, 2, 3, 3, 4, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 3, 3, 4, 3, 1, 2, 2, 2] → J=233, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 3, 4, 3, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 4, 3, 4, 3, 1, 2, 2, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 4, 4, 3, 1, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 4, 3, 2, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 4, 3, 1, 3, 2, 2] → J=235, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 4, 3, 1, 2, 2, 3] → J=235, T=200, cost=4 → queued

[Iter 68] cost=3, J=240, T=198, edges=36, frontier=247, MILP_calls=316
  V_MIN=[2, 3, 3, 3, 2, 2, 3, 4, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 3, 3, 2, 2, 3, 4, 1, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 4, 3, 2, 2, 3, 4, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 4, 2, 2, 3, 4, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 3, 3, 2, 3, 4, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 3, 4, 2, 2, 2, 2] → J=240, T=198, cost=4 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 3, 4, 1, 3, 2, 2] → J=235, T=198, cost=4 → queued
    V_MIN=[2, 3, 3, 3, 2, 2, 3, 4, 1, 2, 2, 3] → J=236, T=200, cost=4 → queued

[Iter 69] cost=3, J=240, T=198, edges=36, frontier=253, MILP_calls=323
  V_MIN=[2, 3, 2, 3, 2, 2, 3, 5, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 3, 2, 2, 3, 5, 1, 2, 2, 2] → J=228, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 4, 2, 2, 3, 5, 1, 2, 2, 2] → J=237, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 3, 2, 3, 5, 1, 2, 2, 2] → J=237, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 6, 1, 2, 2, 2] → J=231, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 5, 2, 2, 2, 2] → J=240, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 5, 1, 3, 2, 2] → J=235, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 5, 1, 2, 2, 3] → J=232, T=199, cost=4 → queued

[Iter 70] cost=3, J=240, T=198, edges=36, frontier=259, MILP_calls=330
  V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 3, 2, 2, 2] → J=239, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 2, 3, 2, 2] → J=236, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 2, 2, 2, 3] → J=237, T=199, cost=4 → queued

[Iter 71] cost=3, J=240, T=198, edges=36, frontier=262, MILP_calls=334
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 2, 2, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 8, 9, 10, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 2, 2, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 3, 2, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 2, 3, 3, 2] → J=236, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 2, 2, 4, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 2, 2, 3, 3] → J=236, T=200, cost=4 → queued

[Iter 72] cost=3, J=240, T=198, edges=36, frontier=266, MILP_calls=339
  V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 2, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 3, 2, 2, 2, 3, 4, 2, 2, 2, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2] → J=240, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 4, 2, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 3, 2, 2, 2] → J=239, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 2, 3, 2, 2] → J=236, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 2, 2, 2, 3] → J=237, T=199, cost=4 → queued

[Iter 73] cost=3, J=240, T=198, edges=36, frontier=271, MILP_calls=345
  V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 2, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 3, 2, 2, 3, 4, 2, 2, 2, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 4, 2, 2, 3, 4, 2, 2, 2, 2] → J=240, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 3, 2, 3, 4, 2, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 4, 2, 2, 2, 2] → J=239, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 3, 2, 2, 2] → J=239, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 2, 3, 2, 2] → J=235, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 3, 4, 2, 2, 2, 3] → J=235, T=200, cost=4 → queued

[Iter 74] cost=3, J=240, T=200, edges=37, frontier=277, MILP_calls=352
  V_MIN=[2, 3, 4, 2, 2, 2, 3, 4, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 7, 8, 9, 11] → expanding 5 children
    V_MIN=[3, 3, 4, 2, 2, 2, 3, 4, 1, 2, 2, 2] → J=237, T=198, cost=4 → queued
    V_MIN=[2, 3, 4, 2, 2, 2, 3, 5, 1, 2, 2, 2] → J=238, T=199, cost=4 → queued
    V_MIN=[2, 3, 4, 2, 2, 2, 3, 4, 1, 3, 2, 2] → J=236, T=198, cost=4 → queued
    V_MIN=[2, 3, 4, 2, 2, 2, 3, 4, 1, 2, 2, 3] → J=237, T=198, cost=4 → queued

[Iter 75] cost=3, J=240, T=200, edges=37, frontier=280, MILP_calls=356
  V_MIN=[2, 3, 3, 2, 3, 2, 3, 4, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 7, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 3, 2, 3, 2, 3, 4, 1, 2, 2, 2] → J=226, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 4, 2, 3, 4, 1, 2, 2, 2] → J=229, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 5, 1, 2, 2, 2] → J=233, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 4, 1, 3, 2, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 4, 1, 2, 2, 3] → J=234, T=199, cost=4 → queued

[Iter 76] cost=3, J=240, T=200, edges=37, frontier=284, MILP_calls=361
  V_MIN=[2, 3, 3, 2, 3, 2, 4, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 6, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 3, 2, 3, 2, 4, 3, 1, 2, 2, 2] → J=233, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 4, 2, 4, 3, 1, 2, 2, 2] → J=233, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 5, 3, 1, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 4, 3, 2, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 4, 3, 1, 3, 2, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 4, 3, 1, 2, 2, 3] → J=234, T=200, cost=4 → queued

[Iter 77] cost=3, J=240, T=200, edges=37, frontier=289, MILP_calls=367
  V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 1, 2, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 8, 9, 10, 11] → expanding 6 children
    V_MIN=[3, 3, 3, 2, 3, 2, 3, 3, 1, 2, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 4, 2, 3, 3, 1, 2, 3, 2] → J=236, T=198, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 2, 2, 3, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 1, 3, 3, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 1, 2, 4, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 1, 2, 3, 3] → J=236, T=200, cost=4 → queued

[Iter 78] cost=3, J=240, T=200, edges=37, frontier=294, MILP_calls=373
  V_MIN=[2, 3, 3, 3, 2, 3, 3, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 5, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 3, 3, 2, 3, 3, 3, 1, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 4, 2, 3, 3, 3, 1, 2, 2, 2] → J=240, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 3, 2, 4, 3, 3, 1, 2, 2, 2] → J=238, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 3, 2, 3, 3, 3, 2, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 3, 2, 3, 3, 3, 1, 3, 2, 2] → J=235, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 3, 2, 3, 3, 3, 1, 2, 2, 3] → J=238, T=200, cost=4 → queued

[Iter 79] cost=3, J=240, T=200, edges=37, frontier=299, MILP_calls=379
  V_MIN=[2, 3, 3, 2, 3, 3, 3, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 3, 2, 3, 3, 3, 3, 1, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 4, 3, 3, 3, 1, 2, 2, 2] → J=238, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 4, 3, 3, 1, 2, 2, 2] → J=238, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 3, 3, 3, 2, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 3, 3, 3, 1, 3, 2, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 3, 3, 3, 1, 2, 2, 3] → J=236, T=200, cost=4 → queued

[Iter 80] cost=3, J=240, T=200, edges=38, frontier=304, MILP_calls=385
  V_MIN=[2, 3, 2, 4, 2, 2, 3, 4, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (451 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (356 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (703 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (674 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (381 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (355 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (203 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (296 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (281 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (255 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (326 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (518 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7, 8, 9, 11] → expanding 9 children
    V_MIN=[3, 3, 2, 4, 2, 2, 3, 4, 1, 2, 2, 2] → J=234, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 5, 2, 2, 3, 4, 1, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 4, 3, 2, 3, 4, 1, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 4, 2, 3, 3, 4, 1, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 4, 2, 2, 3, 4, 1, 3, 2, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 4, 2, 2, 3, 4, 1, 2, 2, 3] → J=234, T=199, cost=4 → queued

[Iter 81] cost=3, J=240, T=200, edges=38, frontier=309, MILP_calls=391
  V_MIN=[2, 3, 2, 4, 2, 3, 3, 3, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (786 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (470 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1235 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (718 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (919 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1259 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (723 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (458 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (391 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (481 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (432 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (706 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 4, 2, 3, 3, 3, 1, 2, 2, 2] → J=233, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 5, 2, 3, 3, 3, 1, 2, 2, 2] → J=240, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 4, 2, 4, 3, 3, 1, 2, 2, 2] → J=238, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 4, 2, 3, 3, 3, 2, 2, 2, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 4, 2, 3, 3, 3, 1, 3, 2, 2] → J=235, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 4, 2, 3, 3, 3, 1, 2, 2, 3] → J=233, T=199, cost=4 → queued

[Iter 82] cost=3, J=239, T=199, edges=37, frontier=314, MILP_calls=397
  V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (1041 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1292 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (262 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1292 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (923 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (668 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (287 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (593 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (535 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (443 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (219 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (841 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 6, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 4, 3, 3, 2, 2, 2] → J=235, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 4, 3, 3, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 3, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 5, 3, 3, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 4, 2, 2, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 3, 3, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 3, 2, 3, 2] → J=236, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 3, 2, 2, 3] → J=235, T=199, cost=4 → queued

[Iter 83] cost=3, J=239, T=199, edges=37, frontier=321, MILP_calls=405
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (1041 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1292 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (262 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1292 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (923 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (668 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (287 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (593 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (535 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (443 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (219 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (841 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 3, 2, 2, 2] → J=235, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 3, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 3, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 5, 3, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 4, 2, 2, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 3, 3, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 3, 2, 2, 3] → J=235, T=199, cost=4 → queued

[Iter 84] cost=3, J=239, T=200, edges=36, frontier=327, MILP_calls=412
  V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (667 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (500 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1091 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (646 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (720 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1045 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (221 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1037 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (747 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (595 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (739 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (633 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 3, 4, 3, 2, 2, 2, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 4, 3, 2, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 4, 3, 2, 2, 2, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 2, 3, 2, 2] → J=235, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 2, 2, 2, 3] → J=235, T=198, cost=4 → queued

[Iter 85] cost=3, J=239, T=200, edges=36, frontier=331, MILP_calls=417
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (667 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (500 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1091 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (646 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (720 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1045 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (221 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1037 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (747 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (595 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (739 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (633 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 2, 2, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 3, 3, 2, 2, 3, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 2, 2, 3, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 3, 2, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 2, 3, 3, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 2, 2, 4, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 2, 2, 3, 3] → J=236, T=200, cost=4 → queued

[Iter 86] cost=3, J=239, T=200, edges=36, frontier=337, MILP_calls=424
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (1037 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (850 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (527 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1447 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1013 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (314 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (781 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (715 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (430 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (647 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (533 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (786 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 4, 2, 2, 2, 2] → J=232, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 3, 4, 2, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 4, 2, 2, 2, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 2, 3, 2, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 2, 2, 2, 3] → J=235, T=198, cost=4 → queued

[Iter 87] cost=3, J=239, T=200, edges=36, frontier=341, MILP_calls=429
  V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (667 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (500 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1091 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (646 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (720 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1045 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (221 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1037 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (747 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (595 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (739 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (633 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 3, 2, 3, 3, 3, 2, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 3, 3, 3, 3, 2, 2, 2, 2] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 4, 3, 3, 2, 2, 2, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 3, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 2, 3, 2, 2] → J=235, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 2, 2, 2, 3] → J=236, T=200, cost=4 → queued

[Iter 88] cost=3, J=239, T=200, edges=37, frontier=346, MILP_calls=435
  V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 1, 3, 2, 2]
  [backtrack] EXHAUSTED search space (545 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (479 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (353 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (324 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (505 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (582 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (151 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (652 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (454 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (699 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (435 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (525 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 3, 4, 3, 1, 3, 2, 2] → J=230, T=197, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 4, 3, 1, 3, 2, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 1, 4, 2, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 1, 3, 2, 3] → J=232, T=198, cost=4 → queued

[Iter 89] cost=3, J=239, T=200, edges=37, frontier=349, MILP_calls=439
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 3, 3, 2]
  [backtrack] EXHAUSTED search space (453 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (380 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (986 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (868 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (771 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (524 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (550 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (509 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (278 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (606 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (977 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (755 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 1, 3, 3, 2] → J=230, T=197, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 1, 3, 3, 2] → J=235, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 3, 3, 1, 3, 3, 2] → J=235, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 1, 3, 3, 2] → J=233, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 4, 3, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 3, 3, 3] → J=232, T=198, cost=4 → queued

[Iter 90] cost=3, J=238, T=199, edges=37, frontier=354, MILP_calls=445
  V_MIN=[2, 3, 2, 3, 2, 4, 3, 3, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (1424 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1444 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (742 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2405 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2029 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (202 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (464 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (397 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (212 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (341 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (207 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1092 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 5, 6, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 3, 2, 4, 3, 3, 1, 2, 2, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 5, 3, 3, 1, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 4, 3, 4, 1, 2, 2, 2] → J=235, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 4, 3, 3, 1, 3, 2, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 4, 3, 3, 1, 2, 3, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 4, 3, 3, 1, 2, 2, 3] → J=235, T=199, cost=4 → queued

[Iter 91] cost=3, J=238, T=199, edges=37, frontier=359, MILP_calls=451
  V_MIN=[2, 3, 2, 2, 3, 4, 3, 3, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (576 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (464 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1320 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (941 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1021 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1304 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (169 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (482 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (246 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (218 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (396 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (728 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 3, 2, 2, 3, 4, 3, 3, 1, 2, 2, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 4, 4, 3, 3, 1, 2, 2, 2] → J=238, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 5, 3, 3, 1, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 4, 3, 4, 1, 2, 2, 2] → J=235, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 4, 3, 3, 2, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 4, 3, 3, 1, 3, 2, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 4, 3, 3, 1, 2, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 4, 3, 3, 1, 2, 2, 3] → J=235, T=199, cost=4 → queued

[Iter 92] cost=3, J=238, T=199, edges=37, frontier=366, MILP_calls=459
  V_MIN=[3, 3, 2, 2, 2, 2, 5, 3, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (1033 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (984 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (236 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (459 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (671 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (961 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (871 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (709 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (366 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (611 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (386 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (824 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7, 8, 9] → expanding 8 children
    V_MIN=[4, 3, 2, 2, 2, 2, 5, 3, 1, 2, 2, 2] → J=228, T=198, cost=4 → queued
    V_MIN=[3, 3, 2, 3, 2, 2, 5, 3, 1, 2, 2, 2] → J=237, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 3, 2, 5, 3, 1, 2, 2, 2] → J=231, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 3, 5, 3, 1, 2, 2, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 6, 3, 1, 2, 2, 2] → J=233, T=199, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 5, 4, 1, 2, 2, 2] → J=235, T=199, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 5, 3, 2, 2, 2, 2] → J=236, T=199, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 5, 3, 1, 3, 2, 2] → J=230, T=200, cost=4 → queued

[Iter 93] cost=3, J=238, T=199, edges=37, frontier=373, MILP_calls=467
  V_MIN=[2, 3, 2, 2, 2, 2, 5, 3, 1, 2, 2, 3]
  [backtrack] EXHAUSTED search space (810 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (642 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1012 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (489 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (929 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (665 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (503 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (444 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (394 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (472 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (745 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (921 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [3, 4, 5, 6, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[2, 3, 2, 3, 2, 2, 5, 3, 1, 2, 2, 3] → J=237, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 5, 3, 1, 2, 2, 3] → J=235, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 5, 3, 1, 2, 2, 3] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 6, 3, 1, 2, 2, 3] → J=237, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 5, 4, 1, 2, 2, 3] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 5, 3, 2, 2, 2, 3] → J=236, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 5, 3, 1, 3, 2, 3] → J=232, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 5, 3, 1, 2, 2, 4] → J=228, T=198, cost=4 → queued

[Iter 94] cost=3, J=238, T=200, edges=38, frontier=380, MILP_calls=475
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 4, 2]
  [backtrack] EXHAUSTED search space (718 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (966 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (201 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1049 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (678 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (489 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (167 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (466 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (433 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (236 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (551 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (558 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 2, 2, 4, 2] → J=236, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 2, 2, 4, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 3, 2, 4, 2] → J=236, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 3, 4, 2] → J=237, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 5, 2] → J=238, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 2, 4, 3] → J=236, T=199, cost=4 → queued

[Iter 95] cost=3, J=238, T=200, edges=37, frontier=385, MILP_calls=481
  V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 1, 2, 2, 3]
  [backtrack] EXHAUSTED search space (599 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (530 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1291 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1159 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (982 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (567 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (571 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (892 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (516 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (272 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (892 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (999 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 2, 4, 4, 1, 2, 2, 3] → J=237, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 5, 1, 2, 2, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 1, 3, 2, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 1, 2, 2, 4] → J=231, T=199, cost=4 → queued

[Iter 96] cost=3, J=238, T=200, edges=37, frontier=388, MILP_calls=485
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 2, 3, 3]
  [backtrack] EXHAUSTED search space (599 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (530 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1291 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1159 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (982 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (567 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (571 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (892 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (516 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (272 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (892 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (999 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 1, 2, 3, 3] → J=237, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 5, 1, 2, 3, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 3, 3, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 2, 3, 4] → J=231, T=199, cost=4 → queued

[Iter 97] cost=3, J=238, T=200, edges=37, frontier=391, MILP_calls=489
  V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 1, 2, 2, 3]
  [backtrack] EXHAUSTED search space (599 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (530 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1291 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1159 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (982 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (567 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (571 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (892 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (516 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (272 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (892 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (999 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 3, 4, 3, 1, 2, 2, 3] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 4, 3, 1, 2, 2, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 4, 3, 1, 2, 2, 4] → J=231, T=199, cost=4 → queued

[Iter 98] cost=3, J=238, T=200, edges=37, frontier=393, MILP_calls=492
  V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 1, 2, 2, 3]
  [backtrack] EXHAUSTED search space (599 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (530 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1291 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1159 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (982 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (567 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (571 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (892 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (516 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (272 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (892 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (999 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 3, 2, 2, 2, 3, 4, 1, 2, 2, 3] → J=237, T=198, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 5, 1, 2, 2, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 1, 3, 2, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 1, 2, 2, 4] → J=231, T=199, cost=4 → queued

[Iter 99] cost=3, J=238, T=200, edges=37, frontier=396, MILP_calls=496
  V_MIN=[2, 3, 2, 2, 3, 2, 4, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (808 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (613 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1572 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (657 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1338 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1080 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (851 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (636 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (397 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (659 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (608 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (721 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 6, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 2, 2, 3, 2, 4, 3, 2, 2, 2, 2] → J=233, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 4, 3, 2, 2, 2, 2] → J=231, T=197, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 5, 3, 2, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 4, 3, 2, 3, 2, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 4, 3, 2, 2, 2, 3] → J=234, T=200, cost=4 → queued

[Iter 100] cost=3, J=238, T=200, edges=37, frontier=400, MILP_calls=501
  V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 2, 2, 3, 2]
  [backtrack] EXHAUSTED search space (808 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (613 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1572 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (657 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1338 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1080 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (851 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (636 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (397 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (659 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (608 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (721 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 8, 9, 10, 11] → expanding 6 children
    V_MIN=[3, 3, 2, 2, 3, 2, 3, 3, 2, 2, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 3, 3, 2, 2, 3, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 3, 2, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 2, 3, 3, 2] → J=232, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 3, 2, 2, 3, 3] → J=236, T=200, cost=4 → queued

[Iter 101] cost=3, J=238, T=200, edges=37, frontier=404, MILP_calls=506
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 2, 3, 3]
  [backtrack] EXHAUSTED search space (912 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (953 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1057 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (433 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (571 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1013 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (864 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (496 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (727 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (801 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (576 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 1, 2, 3, 3] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 1, 2, 3, 3] → J=238, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 3, 3, 1, 2, 3, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 1, 2, 3, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 3, 1, 2, 3, 4] → J=231, T=199, cost=4 → queued

[Iter 102] cost=3, J=238, T=200, edges=37, frontier=408, MILP_calls=511
  V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (808 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (613 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1572 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (657 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1338 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1080 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (851 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (636 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (397 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (659 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (608 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (721 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 7, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 2, 2, 3, 2, 3, 4, 2, 2, 2, 2] → J=227, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 4, 2, 3, 4, 2, 2, 2, 2] → J=230, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 5, 2, 2, 2, 2] → J=233, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 2, 3, 2, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 4, 2, 2, 2, 3] → J=234, T=200, cost=4 → queued

[Iter 103] cost=3, J=238, T=200, edges=37, frontier=412, MILP_calls=516
  V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 1, 2, 2, 3]
  [backtrack] EXHAUSTED search space (912 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (953 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1057 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (433 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (571 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1013 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (181 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (864 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (496 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (727 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (801 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (576 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 4, 1, 2, 2, 3] → J=234, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3] → J=234, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 3, 4, 1, 2, 2, 3] → J=234, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 4, 1, 2, 2, 3] → J=230, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 1, 3, 2, 3] → J=231, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 3, 4, 1, 2, 2, 4] → J=231, T=199, cost=4 → queued

[Iter 104] cost=3, J=238, T=199, edges=37, frontier=417, MILP_calls=522
  V_MIN=[2, 3, 2, 2, 4, 3, 3, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 6, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 4, 3, 3, 3, 1, 2, 2, 2] → J=226, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 5, 3, 3, 3, 1, 2, 2, 2] → J=224, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 4, 3, 3, 4, 1, 2, 2, 2] → J=233, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 4, 3, 3, 3, 2, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 4, 3, 3, 3, 1, 3, 2, 2] → J=232, T=197, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 4, 3, 3, 3, 1, 2, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 4, 3, 3, 3, 1, 2, 2, 3] → J=230, T=200, cost=4 → queued

[Iter 105] cost=3, J=238, T=200, edges=37, frontier=423, MILP_calls=529
  V_MIN=[2, 3, 2, 2, 3, 3, 3, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (808 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (613 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1572 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (657 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1338 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1080 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (851 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (636 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (397 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (659 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (608 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (721 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 8, 9, 11] → expanding 6 children
    V_MIN=[3, 3, 2, 2, 3, 3, 3, 3, 2, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 3, 3, 2, 3, 2, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 3, 3, 3, 2, 2, 2, 3] → J=236, T=200, cost=4 → queued

[Iter 106] cost=3, J=238, T=199, edges=37, frontier=426, MILP_calls=533
  V_MIN=[2, 3, 3, 2, 4, 2, 3, 3, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 6, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[3, 3, 3, 2, 4, 2, 3, 3, 1, 2, 2, 2] → J=226, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 5, 2, 3, 3, 1, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 3, 3, 2, 4, 2, 3, 3, 2, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 4, 2, 3, 3, 1, 3, 2, 2] → J=225, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 4, 2, 3, 3, 1, 2, 2, 3] → J=230, T=200, cost=4 → queued

[Iter 107] cost=3, J=238, T=200, edges=37, frontier=429, MILP_calls=538
  V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (808 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (613 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1572 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (657 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1338 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1080 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (851 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (636 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (397 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (659 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (608 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (721 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 8, 9, 11] → expanding 5 children
    V_MIN=[3, 3, 3, 2, 3, 2, 3, 3, 2, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 3, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 2, 3, 2, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 3, 2, 3, 3, 2, 2, 2, 3] → J=236, T=200, cost=4 → queued

[Iter 108] cost=3, J=238, T=200, edges=37, frontier=432, MILP_calls=542
  V_MIN=[2, 3, 3, 2, 2, 3, 3, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (1046 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1227 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (435 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (729 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1074 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1486 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (606 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1111 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (910 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (482 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (812 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (825 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 5, 8, 9, 11] → expanding 5 children
    V_MIN=[3, 3, 3, 2, 2, 3, 3, 3, 2, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 4, 3, 3, 2, 2, 2, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 3, 3, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 3, 2, 3, 2, 2] → J=235, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 3, 3, 3, 2, 2, 2, 3] → J=236, T=200, cost=4 → queued

[Iter 109] cost=3, J=238, T=199, edges=37, frontier=436, MILP_calls=547
  V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 1, 3, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 4, 4, 1, 3, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 5, 1, 3, 2, 2] → J=236, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 4, 1, 4, 2, 2] → J=233, T=199, cost=4 → queued

[Iter 110] cost=3, J=238, T=199, edges=37, frontier=438, MILP_calls=550
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 3, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 1, 3, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 5, 1, 3, 3, 2] → J=236, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 1, 4, 3, 2] → J=233, T=199, cost=4 → queued

[Iter 111] cost=3, J=238, T=199, edges=37, frontier=440, MILP_calls=553
  V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 1, 3, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 3, 4, 5, 7, 8, 9, 11] → expanding 9 children
    V_MIN=[3, 3, 3, 2, 2, 2, 3, 4, 1, 3, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 5, 1, 3, 2, 2] → J=236, T=198, cost=4 → queued
    V_MIN=[2, 3, 3, 2, 2, 2, 3, 4, 1, 4, 2, 2] → J=232, T=199, cost=4 → queued

[Iter 112] cost=3, J=238, T=200, edges=37, frontier=442, MILP_calls=556
  V_MIN=[3, 3, 2, 2, 2, 3, 4, 3, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (2108 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1605 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3116 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1499 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1746 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2617 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (397 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1194 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (880 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1391 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1310 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2080 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9] → expanding 7 children
    V_MIN=[4, 3, 2, 2, 2, 3, 4, 3, 1, 2, 2, 2] → J=228, T=198, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 4, 4, 3, 1, 2, 2, 2] → J=233, T=198, cost=4 → queued

[Iter 113] cost=3, J=238, T=200, edges=37, frontier=443, MILP_calls=558
  V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 1, 2, 3, 2]
  [backtrack] EXHAUSTED search space (2108 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1605 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3116 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1499 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1746 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2617 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (397 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1194 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (880 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1391 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1310 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2080 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9] → expanding 6 children
    V_MIN=[4, 3, 2, 2, 2, 3, 3, 3, 1, 2, 3, 2] → J=229, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 3, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 4, 3, 3, 1, 2, 3, 2] → J=233, T=200, cost=4 → queued

[Iter 114] cost=3, J=238, T=200, edges=37, frontier=445, MILP_calls=561
  V_MIN=[3, 3, 2, 3, 2, 3, 3, 3, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (3375 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2635 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1898 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3464 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2511 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (895 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (851 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1411 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (907 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (523 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1658 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2360 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9] → expanding 7 children
    V_MIN=[4, 3, 2, 3, 2, 3, 3, 3, 1, 2, 2, 2] → J=223, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 3, 3, 3, 3, 3, 1, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 3, 2, 3, 3, 4, 1, 2, 2, 2] → J=230, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 3, 2, 3, 3, 3, 1, 3, 2, 2] → J=234, T=199, cost=4 → queued

[Iter 115] cost=3, J=238, T=200, edges=37, frontier=448, MILP_calls=565
  V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 1, 2, 2, 3]
  [backtrack] EXHAUSTED search space (3375 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2635 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1898 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3464 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2511 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (895 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (851 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1411 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (907 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (523 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1658 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2360 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [3, 4, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[2, 3, 2, 3, 3, 3, 3, 3, 1, 2, 2, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 1, 3, 2, 3] → J=234, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 3, 2, 3, 3, 3, 1, 2, 2, 4] → J=231, T=198, cost=4 → queued

[Iter 116] cost=3, J=238, T=200, edges=37, frontier=450, MILP_calls=568
  V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 1, 2, 2, 3]
  [backtrack] EXHAUSTED search space (3375 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2635 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1898 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3464 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2511 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (895 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (851 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1411 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (907 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (523 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1658 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (2360 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[4, 3, 2, 2, 2, 3, 3, 3, 1, 2, 2, 3] → J=230, T=197, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 3, 3, 3, 3, 1, 2, 2, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 4, 3, 3, 1, 2, 2, 3] → J=234, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 2, 2, 2, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 1, 3, 2, 3] → J=234, T=199, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 3, 3, 3, 1, 2, 2, 4] → J=232, T=200, cost=4 → queued

[Iter 117] cost=3, J=237, T=199, edges=37, frontier=455, MILP_calls=574
  V_MIN=[2, 3, 2, 2, 2, 4, 4, 3, 1, 2, 2, 2]
  [backtrack] EXHAUSTED search space (293 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (189 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (634 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (431 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (393 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (324 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (384 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (161 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (431 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (294 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (230 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (414 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7, 9, 10, 11] → expanding 9 children
    V_MIN=[2, 3, 2, 2, 2, 5, 4, 3, 1, 2, 2, 2] → J=236, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 5, 3, 1, 2, 2, 2] → J=237, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 4, 3, 1, 2, 3, 2] → J=237, T=199, cost=4 → queued

[Iter 118] cost=3, J=237, T=199, edges=37, frontier=457, MILP_calls=577
  V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 2, 2, 2, 2]
  [backtrack] EXHAUSTED search space (293 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (189 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (634 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (431 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (393 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (324 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (384 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (161 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (431 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (294 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (230 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (414 backtracks in 0.00s)
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 10, 11] → expanding 9 children
    V_MIN=[3, 3, 2, 2, 2, 4, 3, 3, 2, 2, 2, 2] → J=233, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 5, 3, 3, 2, 2, 2, 2] → J=234, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 3, 2, 2, 2] → J=235, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 2, 3, 2, 2] → J=233, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 2, 2, 2, 3] → J=234, T=200, cost=4 → queued

[Iter 119] cost=3, J=237, T=199, edges=37, frontier=461, MILP_calls=582
  V_MIN=[2, 3, 2, 2, 2, 4, 3, 3, 1, 2, 3, 2]
  [backtrack] EXHAUSTED search space (3098 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1955 backtracks in 0.00s)
  [backtrack] Found solution with 1573 backtracks in 0.00s
  [backtrack] Found solution with 831 backtracks in 0.00s
  [backtrack] Found solution with 938 backtracks in 0.00s
  [backtrack] Found solution with 2180 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (3404 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2960 backtracks in 0.01s)
  [backtrack] Found solution with 1524 backtracks in 0.00s
  [backtrack] Found solution with 1485 backtracks in 0.00s
  [backtrack] Found solution with 3305 backtracks in 0.01s
  [backtrack] EXHAUSTED search space (4292 backtracks in 0.01s)
  DFS: latency violated (3 nodes, worst_gap=114.2s)
  Boundary nodes: [0, 2, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[2, 3, 2, 2, 2, 5, 3, 3, 1, 2, 3, 2] → J=236, T=200, cost=4 → queued

[Iter 120] cost=3, J=237, T=200, edges=36, frontier=461, MILP_calls=583
  V_MIN=[2, 3, 2, 2, 3, 2, 3, 5, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 2, 4, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 3, 2, 3, 5, 1, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 3, 2, 2, 4, 2, 3, 5, 1, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 6, 1, 2, 2, 2] → MILP infeasible, pruned
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 5, 1, 3, 2, 2] → J=225, T=198, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 3, 5, 1, 2, 2, 3] → J=224, T=200, cost=4 → queued

[Iter 121] cost=3, J=237, T=200, edges=38, frontier=462, MILP_calls=588
  V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 2, 3, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 6, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 4, 3, 2, 3, 2, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 5, 3, 2, 3, 2, 2] → J=236, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 2, 4, 2, 2] → J=235, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 2, 3, 2, 3] → J=234, T=200, cost=4 → queued

[Iter 122] cost=3, J=237, T=200, edges=38, frontier=465, MILP_calls=592
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 3, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 4, 5, 7, 8, 9, 11] → expanding 7 children
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 3, 2, 3, 3, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 3, 3, 3, 2] → J=234, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 4, 3, 2] → J=231, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 3, 2, 3, 3, 3] → J=234, T=200, cost=4 → queued

[Iter 123] cost=3, J=237, T=198, edges=36, frontier=468, MILP_calls=596
  V_MIN=[3, 3, 2, 2, 2, 2, 4, 4, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 7, 8, 9] → expanding 8 children
    V_MIN=[4, 3, 2, 2, 2, 2, 4, 4, 1, 2, 2, 2] → J=230, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 4, 5, 1, 2, 2, 2] → J=234, T=199, cost=4 → queued

[Iter 124] cost=3, J=237, T=198, edges=36, frontier=469, MILP_calls=598
  V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 1, 2, 3, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[4, 3, 2, 2, 2, 2, 3, 4, 1, 2, 3, 2] → J=230, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 5, 1, 2, 3, 2] → J=234, T=199, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 1, 2, 4, 2] → J=236, T=200, cost=4 → queued

[Iter 125] cost=3, J=237, T=198, edges=36, frontier=471, MILP_calls=601
  V_MIN=[3, 3, 3, 2, 2, 2, 3, 4, 1, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9] → expanding 7 children
    V_MIN=[4, 3, 3, 2, 2, 2, 3, 4, 1, 2, 2, 2] → J=230, T=200, cost=4 → queued
    V_MIN=[3, 3, 3, 2, 2, 2, 3, 5, 1, 2, 2, 2] → J=232, T=200, cost=4 → queued

[Iter 126] cost=3, J=237, T=198, edges=36, frontier=472, MILP_calls=603
  V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 1, 2, 2, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 11] → expanding 8 children
    V_MIN=[4, 3, 2, 2, 2, 2, 3, 4, 1, 2, 2, 3] → J=230, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 3, 2, 2, 3, 4, 1, 2, 2, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 3, 2, 3, 4, 1, 2, 2, 3] → J=230, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 5, 1, 2, 2, 3] → J=234, T=199, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 2, 2, 2, 3] → J=237, T=199, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 1, 3, 2, 3] → J=236, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 1, 2, 2, 4] → J=230, T=200, cost=4 → queued

[Iter 127] cost=3, J=237, T=199, edges=36, frontier=478, MILP_calls=610
  V_MIN=[3, 3, 2, 2, 2, 2, 4, 3, 2, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 6, 8, 9, 10] → expanding 8 children
    V_MIN=[4, 3, 2, 2, 2, 2, 4, 3, 2, 2, 2, 2] → J=230, T=198, cost=4 → queued
    V_MIN=[3, 3, 2, 3, 2, 2, 4, 3, 2, 2, 2, 2] → J=234, T=198, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 4, 3, 2, 2, 3, 2] → J=236, T=199, cost=4 → queued

[Iter 128] cost=3, J=237, T=199, edges=36, frontier=480, MILP_calls=613
  V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 2, 2, 2, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [3, 4, 5, 6, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[2, 3, 2, 3, 2, 2, 4, 3, 2, 2, 2, 3] → J=236, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 2, 2, 3, 3] → J=236, T=199, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 4, 3, 2, 2, 2, 4] → J=231, T=199, cost=4 → queued

[Iter 129] cost=3, J=237, T=199, edges=36, frontier=482, MILP_calls=616
  V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 2, 2, 2, 2]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [0, 3, 4, 5, 7, 8, 9, 10] → expanding 8 children
    V_MIN=[4, 3, 2, 2, 2, 2, 3, 4, 2, 2, 2, 2] → J=224, T=199, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 5, 2, 2, 2, 2] → J=234, T=200, cost=4 → queued
    V_MIN=[3, 3, 2, 2, 2, 2, 3, 4, 2, 3, 2, 2] → J=234, T=200, cost=4 → queued

[Iter 130] cost=3, J=237, T=199, edges=36, frontier=484, MILP_calls=619
  V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 2, 2, 2, 3]
  Not Eulerian or DFS exhausted — expanding children anyway
  Boundary nodes: [3, 4, 5, 7, 8, 9, 10, 11] → expanding 8 children
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 5, 2, 2, 2, 3] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 2, 3, 2, 3] → J=234, T=200, cost=4 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 4, 2, 2, 2, 4] → J=231, T=200, cost=4 → queued

[Iter 131] cost=3, J=237, T=199, edges=36, frontier=486, MILP_calls=622
  V_MIN=[2, 3, 2, 2, 2, 4, 3, 4, 1, 2, 2, 2]
  [backtrack] Found solution with 116 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=198.6s
  *** SOLUTION FOUND! J=237, T_tour=198.6s ***

============================================================
Search done: 131 iters, 622 MILP calls, 622 states visited

Original flow_B is latency-feasible ✓
  flow_B = [2, -2, 4, 2, -4, 0, 2, 2, 2, 0, 0, 2, -2, -4, 2, 0, -2, -2, 0, 0, 2, 0]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [2, -2, 4, 2, -4, 0, 2, 2, 2, 0, 0, 2, -2, -4, 2, 0, -2, -2, 0, 0, 2, 0]
  Non-zero edges: [((0, 1), np.int64(2)), ((0, 11), np.int64(-2)), ((1, 2), np.int64(4)), ((1, 3), np.int64(2)), ((1, 5), np.int64(-4)), ((2, 8), np.int64(2)), ((2, 11), np.int64(2)), ((3, 4), np.int64(2)), ((4, 5), np.int64(2)), ((5, 6), np.int64(-2)), ((6, 7), np.int64(-4)), ((6, 9), np.int64(2)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(-2)), ((9, 10), np.int64(2))]

Blocked edge 1: idx=3, edge=(1, 3), flow_B=2  →  need Cm[3]=-2
Blocked edge 2: idx=13, edge=(6, 7), flow_B=-4  →  need Cm[13]=4
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=49   ||Cm||_1=21

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [2, 3, -1, 0, -1, 0, 0, 1, 0, 0, 0]

Cm = C_oriented @ beta*:
  [0, 0, 2, -2, 0, 1, 0, 1, 0, 0, -1, 0, 0, 4, -1, -3, 1, 3, 1, -1, 0, 0]

Original flow_B:
  [2, -2, 4, 2, -4, 0, 2, 2, 2, 0, 0, 2, -2, -4, 2, 0, -2, -2, 0, 0, 2, 0]

flow_B + Cm (corrected flow):
  [2, -2, 6, 0, -4, 1, 2, 3, 2, 0, -1, 2, -2, 0, 1, -3, -1, 1, 1, -1, 2, 0]

Verification:
  flow_corrected[3] = 0  (should be 0, Cm=-2, d=-2)
  flow_corrected[13] = 0  (should be 0, Cm=4, d=4)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 49  (minimized by MIQP)
  ||Cm||_1  = 21
  ||flow_B||_2² = 96
  ||flow_corrected||_2² = 105

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.2s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         2       0           2    5.4          
    1     (0, 11)        -2       0          -2    7.6          
    2      (1, 2)         4       2           6    4.5     +9.0s
    3      (1, 3)         2      -2           0    4.8     -9.6s ← BLOCKED
    4      (1, 5)        -4       0          -4    4.6          
    5      (2, 3)         0       1           1    4.4     +4.4s
    6      (2, 8)         2       0           2    5.7          
    7     (2, 11)         2       1           3    5.2     +5.2s
    8      (3, 4)         2       0           2    4.5          
    9      (3, 6)         0       0           0    7.1          
   10      (3, 8)         0      -1          -1    6.4     +6.4s
   11      (4, 5)         2       0           2    6.5          
   12      (5, 6)        -2       0          -2    6.7          
   13      (6, 7)        -4       4           0    7.0    -28.0s ← BLOCKED
   14      (6, 9)         2      -1           1    5.6     -5.6s
   15     (6, 10)         0      -3          -3    4.7    +14.1s
   16      (7, 8)        -2       1          -1    4.7     -4.7s
   17     (7, 10)        -2       3           1    5.3     -5.3s
   18      (8, 9)         0       1           1    6.5     +6.5s
   19     (8, 11)         0      -1          -1    7.8     +7.8s
   20     (9, 10)         2       0           2    5.1          
   21    (10, 11)         0       0           0    4.3          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=2, out=2  OK
  Node 1: in=6, out=6  OK
  Node 2: in=6, out=6  OK
  Node 3: in=2, out=2  OK
  Node 4: in=2, out=2  OK
  Node 5: in=4, out=4  OK
  Node 6: in=3, out=3  OK
  Node 7: in=1, out=1  OK
  Node 8: in=3, out=3  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=3, out=3  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 37 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 17

  Summary:
    Original path length:  36 edges
    Spliced path length:   37 edges
    Splices performed:     17
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           2         2  ✓
    1     (0, 11)          -2        -2  ✓
    2      (1, 2)           6         6  ✓
    3      (1, 3)           0         0  ✓
    4      (1, 5)          -4        -4  ✓
    5      (2, 3)           1         1  ✓
    6      (2, 8)           2         2  ✓
    7     (2, 11)           3         3  ✓
    8      (3, 4)           2         2  ✓
    9      (3, 6)           0         0  ✓
   10      (3, 8)          -1        -1  ✓
   11      (4, 5)           2         2  ✓
   12      (5, 6)          -2        -2  ✓
   13      (6, 7)           0         0  ✓
   14      (6, 9)           1         1  ✓
   15     (6, 10)          -3        -3  ✓
   16      (7, 8)          -1        -1  ✓
   17     (7, 10)           1         1  ✓
   18      (8, 9)           1         1  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           0         0  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 98
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 2, 2, 1, 2, 2] → J=168, T=199, cost=0 → queued

[Iter 1] cost=0, J=168, T=199, edges=32, frontier=0, MILP_calls=1
  V_MIN=[3, 2, 2, 3, 2, 2, 2, 2, 2, 1, 2, 2]
  [backtrack] Found solution with 18 backtracks in 0.00s
  [backtrack] Found solution with 42 backtracks in 0.00s
    ✓ Latency-feasible! source=1, T_tour=199.1s
  *** SOLUTION FOUND! J=168, T_tour=199.1s ***

============================================================
Search done: 1 iters, 1 MILP calls, 1 states visited

Original flow_B is latency-feasible ✓
  flow_B = [3, -3, 1, 1, 1, -1, 0, 2, -2, 4, -2, -2, -1, 2, 1, 0, 1, 1, 0, -1, 1, 2]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [3, -3, 1, 1, 1, -1, 0, 2, -2, 4, -2, -2, -1, 2, 1, 0, 1, 1, 0, -1, 1, 2]
  Non-zero edges: [((0, 1), np.int64(3)), ((0, 11), np.int64(-3)), ((1, 2), np.int64(1)), ((1, 3), np.int64(1)), ((1, 5), np.int64(1)), ((2, 3), np.int64(-1)), ((2, 11), np.int64(2)), ((3, 4), np.int64(-2)), ((3, 6), np.int64(4)), ((3, 8), np.int64(-2)), ((4, 5), np.int64(-2)), ((5, 6), np.int64(-1)), ((6, 7), np.int64(2)), ((6, 9), np.int64(1)), ((7, 8), np.int64(1)), ((7, 10), np.int64(1)), ((8, 11), np.int64(-1)), ((9, 10), np.int64(1)), ((10, 11), np.int64(2))]

Blocked edge 1: idx=4, edge=(1, 5), flow_B=1  →  need Cm[4]=-1
Blocked edge 2: idx=5, edge=(2, 3), flow_B=-1  →  need Cm[5]=1
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = -0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= -0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=8   ||Cm||_1=8

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]

Cm = C_oriented @ beta*:
  [0, 0, 1, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, -1, 0, 0, 0, 0, 1, 0]

Original flow_B:
  [3, -3, 1, 1, 1, -1, 0, 2, -2, 4, -2, -2, -1, 2, 1, 0, 1, 1, 0, -1, 1, 2]

flow_B + Cm (corrected flow):
  [3, -3, 2, 1, 0, 0, 0, 2, -1, 4, -2, -1, -1, 2, 2, -1, 1, 1, 0, -1, 2, 2]

Verification:
  flow_corrected[4] = 0  (should be 0, Cm=-1, d=-1)
  flow_corrected[5] = 0  (should be 0, Cm=1, d=1)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 8  (minimized by MIQP)
  ||Cm||_1  = 8
  ||flow_B||_2² = 68
  ||flow_corrected||_2² = 70

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)         3       0           3    7.7          
    1     (0, 11)        -3       0          -3    5.2          
    2      (1, 2)         1       1           2    7.4     +7.4s
    3      (1, 3)         1       0           1    8.0          
    4      (1, 5)         1      -1           0    5.7     -5.7s ← BLOCKED
    5      (2, 3)        -1       1           0    6.8     -6.8s ← BLOCKED
    6      (2, 8)         0       0           0    7.8          
    7     (2, 11)         2       0           2    5.8          
    8      (3, 4)        -2       1          -1    6.7     -6.7s
    9      (3, 6)         4       0           4    5.2          
   10      (3, 8)        -2       0          -2    7.9          
   11      (4, 5)        -2       1          -1    6.8     -6.8s
   12      (5, 6)        -1       0          -1    4.1          
   13      (6, 7)         2       0           2    4.5          
   14      (6, 9)         1       1           2    5.1     +5.1s
   15     (6, 10)         0      -1          -1    7.5     +7.5s
   16      (7, 8)         1       0           1    7.4          
   17     (7, 10)         1       0           1    6.6          
   18      (8, 9)         0       0           0    7.3          
   19     (8, 11)        -1       0          -1    6.2          
   20     (9, 10)         1       1           2    6.1     +6.1s
   21    (10, 11)         2       0           2    6.4          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=3, out=3  OK
  Node 2: in=2, out=2  OK
  Node 3: in=4, out=4  OK
  Node 4: in=1, out=1  OK
  Node 5: in=1, out=1  OK
  Node 6: in=5, out=5  OK
  Node 7: in=2, out=2  OK
  Node 8: in=2, out=2  OK
  Node 9: in=2, out=2  OK
  Node 10: in=3, out=3  OK
  Node 11: in=4, out=4  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 32 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 7

  Summary:
    Original path length:  32 edges
    Spliced path length:   32 edges
    Splices performed:     7
    Path is continuous:    True
    Returns to source 1: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)           3         3  ✓
    1     (0, 11)          -3        -3  ✓
    2      (1, 2)           2         2  ✓
    3      (1, 3)           1         1  ✓
    4      (1, 5)           0         0  ✓
    5      (2, 3)           0         0  ✓
    6      (2, 8)           0         0  ✓
    7     (2, 11)           2         2  ✓
    8      (3, 4)          -1        -1  ✓
    9      (3, 6)           4         4  ✓
   10      (3, 8)          -2        -2  ✓
   11      (4, 5)          -1        -1  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)           2         2  ✓
   14      (6, 9)           2         2  ✓
   15     (6, 10)          -1        -1  ✓
   16      (7, 8)           1         1  ✓
   17     (7, 10)           1         1  ✓
   18      (8, 9)           0         0  ✓
   19     (8, 11)          -1        -1  ✓
   20     (9, 10)           2         2  ✓
   21    (10, 11)           2         2  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!

================================================================================
TRIAL 99
================================================================================
✓ STATUS: SUCCESS (0 mismatches)

BFS + Frontier search over V_MIN lattice
Priority: (total_increment, -J)
============================================================
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 3, 1, 2, 2] → J=257, T=200, cost=0 → queued

[Iter 1] cost=0, J=257, T=200, edges=37, frontier=0, MILP_calls=1
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 3, 1, 2, 2]
  [backtrack] Found solution with 297 backtracks in 0.00s
  [backtrack] Found solution with 706 backtracks in 0.00s
  [backtrack] Found solution with 6 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (3299 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3111 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2895 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2069 backtracks in 0.00s)
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 2 backtracks in 0.00s
  [backtrack] Found solution with 717 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1731 backtracks in 0.00s)
  [backtrack] Found solution with 2 backtracks in 0.00s
  DFS: latency violated (1 nodes, worst_gap=108.8s)
  Boundary nodes: [0, 1, 3, 4, 5, 6, 7, 9] → expanding 8 children
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 3, 1, 2, 2] → J=252, T=199, cost=1 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 3, 1, 2, 2] → J=253, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 3, 1, 2, 2] → J=252, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 3, 1, 2, 2] → J=246, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 2, 2, 3, 1, 2, 2] → J=246, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 3, 1, 2, 2] → J=252, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 3, 3, 1, 2, 2] → J=252, T=200, cost=1 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2] → J=250, T=200, cost=1 → queued

[Iter 2] cost=1, J=253, T=200, edges=37, frontier=7, MILP_calls=9
  V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 3, 1, 2, 2]
  [backtrack] Found solution with 139 backtracks in 0.00s
  [backtrack] Found solution with 21 backtracks in 0.00s
  [backtrack] Found solution with 432 backtracks in 0.00s
  [backtrack] Found solution with 161 backtracks in 0.00s
  [backtrack] Found solution with 149 backtracks in 0.00s
  [backtrack] Found solution with 125 backtracks in 0.00s
  [backtrack] Found solution with 58 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] Found solution with 3 backtracks in 0.00s
  [backtrack] Found solution with 45 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=149.3s)
  Boundary nodes: [0, 1, 3, 4, 5, 6, 7, 9] → expanding 8 children
    V_MIN=[3, 3, 2, 2, 2, 2, 2, 2, 3, 1, 2, 2] → J=252, T=199, cost=2 → queued
    V_MIN=[2, 4, 2, 2, 2, 2, 2, 2, 3, 1, 2, 2] → J=244, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 3, 2, 2, 2, 2, 3, 1, 2, 2] → J=246, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 3, 2, 2, 2, 3, 1, 2, 2] → J=236, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 3, 2, 2, 3, 1, 2, 2] → J=239, T=198, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 3, 2, 3, 1, 2, 2] → J=248, T=200, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 3, 3, 1, 2, 2] → J=246, T=199, cost=2 → queued
    V_MIN=[2, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2] → J=246, T=200, cost=2 → queued

[Iter 3] cost=1, J=252, T=200, edges=38, frontier=14, MILP_calls=17
  V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 3, 1, 2, 2]
  [backtrack] EXHAUSTED search space (3211 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2170 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3496 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3701 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (4351 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3540 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1458 backtracks in 0.00s)
  [backtrack] Found solution with 1882 backtracks in 0.00s
  [backtrack] Found solution with 4524 backtracks in 0.01s
  [backtrack] EXHAUSTED search space (3565 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2889 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2552 backtracks in 0.01s)
  DFS: latency violated (5 nodes, worst_gap=200.0s)
  Boundary nodes: [0, 1, 2, 3, 4, 5, 6, 9] → expanding 8 children
    V_MIN=[3, 2, 2, 2, 2, 2, 3, 2, 3, 1, 2, 2] → J=246, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 3, 2, 3, 1, 2, 2] → J=252, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 3, 2, 3, 1, 2, 2] → J=252, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 3, 2, 3, 1, 2, 2] → J=241, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 3, 2, 3, 1, 2, 2] → J=245, T=198, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 4, 2, 3, 1, 2, 2] → J=247, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2] → J=246, T=200, cost=2 → queued

[Iter 4] cost=1, J=252, T=200, edges=38, frontier=20, MILP_calls=24
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 3, 3, 1, 2, 2]
  [backtrack] EXHAUSTED search space (3211 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2170 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3496 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3701 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (4351 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (3540 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (1458 backtracks in 0.00s)
  [backtrack] Found solution with 1882 backtracks in 0.00s
  [backtrack] Found solution with 4524 backtracks in 0.01s
  [backtrack] EXHAUSTED search space (3565 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2889 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (2552 backtracks in 0.01s)
  DFS: latency violated (5 nodes, worst_gap=200.0s)
  Boundary nodes: [0, 1, 2, 3, 4, 5, 7, 9] → expanding 8 children
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 3, 3, 1, 2, 2] → J=246, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 2, 2, 2, 2, 3, 3, 1, 2, 2] → J=250, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 3, 3, 1, 2, 2] → J=250, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 3, 3, 1, 2, 2] → J=239, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 2, 3, 3, 1, 2, 2] → J=239, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 4, 3, 1, 2, 2] → J=250, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2] → J=250, T=200, cost=2 → queued

[Iter 5] cost=1, J=252, T=200, edges=38, frontier=26, MILP_calls=31
  V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 3, 1, 2, 2]
  [backtrack] Found solution with 1780 backtracks in 0.00s
  [backtrack] Found solution with 1563 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (2201 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (3718 backtracks in 0.01s)
  [backtrack] EXHAUSTED search space (4189 backtracks in 0.01s)
  [backtrack] Found solution with 1510 backtracks in 0.00s
  [backtrack] Found solution with 2270 backtracks in 0.00s
  [backtrack] Found solution with 187 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (3013 backtracks in 0.01s)
  [backtrack] Found solution with 202 backtracks in 0.00s
  [backtrack] Found solution with 2888 backtracks in 0.01s
  [backtrack] Found solution with 3062 backtracks in 0.01s
  DFS: latency violated (2 nodes, worst_gap=151.7s)
  Boundary nodes: [0, 1, 2, 3, 4, 5, 7, 9] → expanding 8 children
    V_MIN=[3, 2, 2, 3, 2, 2, 2, 2, 3, 1, 2, 2] → J=245, T=200, cost=2 → queued
    V_MIN=[2, 2, 3, 3, 2, 2, 2, 2, 3, 1, 2, 2] → J=250, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 4, 2, 2, 2, 2, 3, 1, 2, 2] → J=250, T=199, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 3, 2, 2, 2, 3, 1, 2, 2] → J=246, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 3, 2, 2, 3, 1, 2, 2] → J=246, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 2] → J=250, T=200, cost=2 → queued

[Iter 6] cost=1, J=252, T=199, edges=37, frontier=31, MILP_calls=37
  V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 3, 1, 2, 2]
  [backtrack] Found solution with 785 backtracks in 0.00s
  [backtrack] Found solution with 588 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1548 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1456 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1653 backtracks in 0.00s)
  [backtrack] Found solution with 375 backtracks in 0.00s
  [backtrack] Found solution with 767 backtracks in 0.00s
  [backtrack] Found solution with 67 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (1082 backtracks in 0.00s)
  [backtrack] Found solution with 123 backtracks in 0.00s
  [backtrack] Found solution with 1088 backtracks in 0.00s
  [backtrack] Found solution with 1090 backtracks in 0.00s
  DFS: latency violated (2 nodes, worst_gap=113.5s)
  Boundary nodes: [0, 2, 3, 4, 5, 6, 7, 9] → expanding 8 children
    V_MIN=[4, 2, 2, 2, 2, 2, 2, 2, 3, 1, 2, 2] → J=240, T=200, cost=2 → queued
    V_MIN=[3, 2, 3, 2, 2, 2, 2, 2, 3, 1, 2, 2] → J=246, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 3, 2, 2, 2, 3, 1, 2, 2] → J=234, T=200, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 3, 2, 2, 3, 1, 2, 2] → J=234, T=199, cost=2 → queued
    V_MIN=[3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2] → J=244, T=199, cost=2 → queued

[Iter 7] cost=1, J=250, T=200, edges=38, frontier=35, MILP_calls=42
  V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2]
  [backtrack] EXHAUSTED search space (795 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (858 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1175 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1095 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (1020 backtracks in 0.00s)
  [backtrack] EXHAUSTED search space (933 backtracks in 0.00s)
  [backtrack] Found solution with 281 backtracks in 0.00s
  [backtrack] Found solution with 491 backtracks in 0.00s
  [backtrack] Found solution with 601 backtracks in 0.00s
  [backtrack] Found solution with 504 backtracks in 0.00s
  [backtrack] Found solution with 0 backtracks in 0.00s
  [backtrack] EXHAUSTED search space (602 backtracks in 0.00s)
  DFS: latency violated (2 nodes, worst_gap=109.5s)
  Boundary nodes: [0, 1, 2, 3, 4, 5, 6, 9] → expanding 8 children
    V_MIN=[2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 2] → J=249, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2] → J=238, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2] → J=238, T=200, cost=2 → queued
    V_MIN=[2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2] → J=243, T=200, cost=2 → queued

[Iter 8] cost=1, J=246, T=200, edges=37, frontier=38, MILP_calls=46
  V_MIN=[2, 2, 2, 2, 3, 2, 2, 2, 3, 1, 2, 2]
  [backtrack] Found solution with 231 backtracks in 0.00s
    ✓ Latency-feasible! source=0, T_tour=199.9s
  *** SOLUTION FOUND! J=246, T_tour=199.9s ***

============================================================
Search done: 8 iters, 46 MILP calls, 46 states visited

Original flow_B is latency-feasible ✓
  flow_B = [-2, 2, 0, 0, -2, 3, -3, 0, 3, 0, 0, 3, 1, 0, -1, 2, -2, 2, 1, -6, 0, 4]

============================================================
Original flow_B (= C_oriented @ w_signed):
  [-2, 2, 0, 0, -2, 3, -3, 0, 3, 0, 0, 3, 1, 0, -1, 2, -2, 2, 1, -6, 0, 4]
  Non-zero edges: [((0, 1), np.int64(-2)), ((0, 11), np.int64(2)), ((1, 5), np.int64(-2)), ((2, 3), np.int64(3)), ((2, 8), np.int64(-3)), ((3, 4), np.int64(3)), ((4, 5), np.int64(3)), ((5, 6), np.int64(1)), ((6, 9), np.int64(-1)), ((6, 10), np.int64(2)), ((7, 8), np.int64(-2)), ((7, 10), np.int64(2)), ((8, 9), np.int64(1)), ((8, 11), np.int64(-6)), ((10, 11), np.int64(4))]

Blocked edge 1: idx=14, edge=(6, 9), flow_B=-1  →  need Cm[14]=1
Blocked edge 2: idx=8, edge=(3, 4), flow_B=3  →  need Cm[8]=-3
  No shared nodes: True ✓

Solving Stage 1: Minimize global time deviation |Delta T| ...
  Stage 1 found minimal achievable |Delta T| = 0.00s

Solving Stage 2: Minimize ||Cm||_2^2 subject to |Delta T| <= 0.00s + tol ...
[Stage 2 Result] Eulerian: True  (balanced=True, weakly_connected=True)
[Stage 2 Result] ||Cm||_2²=36   ||Cm||_1=20

Final correction method used: Two-Stage MIQP (Min T, then min L2)

============================================================
RESULTS
============================================================

beta* (cycle basis weights for correction):
  [0, -1, 0, 1, 0, -2, -1, 0, 0, -1, 0]

Cm = C_oriented @ beta*:
  [-1, 1, -1, -1, 1, 0, 0, -1, -3, 2, 0, -3, -2, -1, 1, 0, 0, -1, 0, 0, 1, 0]

Original flow_B:
  [-2, 2, 0, 0, -2, 3, -3, 0, 3, 0, 0, 3, 1, 0, -1, 2, -2, 2, 1, -6, 0, 4]

flow_B + Cm (corrected flow):
  [-3, 3, -1, -1, -1, 3, -3, -1, 0, 2, 0, 0, -1, -1, 0, 2, -2, 1, 1, -6, 1, 4]

Verification:
  flow_corrected[14] = 0  (should be 0, Cm=1, d=1)
  flow_corrected[8] = 0  (should be 0, Cm=-3, d=-3)
  Both constraints satisfied: True

Norm comparison:
  ||Cm||_2² = 36  (minimized by MIQP)
  ||Cm||_1  = 20
  ||flow_B||_2² = 115
  ||flow_corrected||_2² = 109

Time difference (|corrected| - |flow_B|) * tau:
  Total: +0.1s  (positive = more time, negative = less time)

Edge-level comparison:
  idx        edge    flow_B      Cm   corrected     tau   delta_t
  -----------------------------------------------------------------
    0      (0, 1)        -2      -1          -3    5.5     +5.5s
    1     (0, 11)         2       1           3    6.0     +6.0s
    2      (1, 2)         0      -1          -1    7.7     +7.7s
    3      (1, 3)         0      -1          -1    5.6     +5.6s
    4      (1, 5)        -2       1          -1    7.9     -7.9s
    5      (2, 3)         3       0           3    6.1          
    6      (2, 8)        -3       0          -3    4.4          
    7     (2, 11)         0      -1          -1    7.3     +7.3s
    8      (3, 4)         3      -3           0    4.8    -14.4s ← BLOCKED
    9      (3, 6)         0       2           2    6.2    +12.4s
   10      (3, 8)         0       0           0    5.2          
   11      (4, 5)         3      -3           0    7.3    -21.9s
   12      (5, 6)         1      -2          -1    7.3          
   13      (6, 7)         0      -1          -1    4.9     +4.9s
   14      (6, 9)        -1       1           0    6.6     -6.6s ← BLOCKED
   15     (6, 10)         2       0           2    4.4          
   16      (7, 8)        -2       0          -2    5.6          
   17     (7, 10)         2      -1           1    4.4     -4.4s
   18      (8, 9)         1       0           1    4.6          
   19     (8, 11)        -6       0          -6    4.8          
   20     (9, 10)         0       1           1    5.9     +5.9s
   21    (10, 11)         4       0           4    4.3          

============================================================
STEP 1: Eulerian Check on flow_corrected
============================================================

Degree balance (in==out for all nodes): True
  Node 0: in=3, out=3  OK
  Node 1: in=3, out=3  OK
  Node 2: in=4, out=4  OK
  Node 3: in=3, out=3  OK
  Node 5: in=1, out=1  OK
  Node 6: in=3, out=3  OK
  Node 7: in=2, out=2  OK
  Node 8: in=6, out=6  OK
  Node 9: in=1, out=1  OK
  Node 10: in=4, out=4  OK
  Node 11: in=7, out=7  OK

Weakly connected (non-isolated subgraph): True

Eulerian circuit exists: True

============================================================
STEP 3: Guided Eulerian Circuit (Dynamic Splice)
============================================================
  G_corr built with 37 directed edges (exactly matching |flow_corrected|).
  Guided Eulerian Circuit completed. Total sequence diversions: 19

  Summary:
    Original path length:  37 edges
    Spliced path length:   37 edges
    Splices performed:     19
    Path is continuous:    True
    Returns to source 0: True
    Blocked edges in path: 0 (should be 0)

  Edge-Count Audit (spliced path vs flow_corrected):
  idx        edge   corrected   spliced   match
  --------------------------------------------------
    0      (0, 1)          -3        -3  ✓
    1     (0, 11)           3         3  ✓
    2      (1, 2)          -1        -1  ✓
    3      (1, 3)          -1        -1  ✓
    4      (1, 5)          -1        -1  ✓
    5      (2, 3)           3         3  ✓
    6      (2, 8)          -3        -3  ✓
    7     (2, 11)          -1        -1  ✓
    8      (3, 4)           0         0  ✓
    9      (3, 6)           2         2  ✓
   10      (3, 8)           0         0  ✓
   11      (4, 5)           0         0  ✓
   12      (5, 6)          -1        -1  ✓
   13      (6, 7)          -1        -1  ✓
   14      (6, 9)           0         0  ✓
   15     (6, 10)           2         2  ✓
   16      (7, 8)          -2        -2  ✓
   17     (7, 10)           1         1  ✓
   18      (8, 9)           1         1  ✓
   19     (8, 11)          -6        -6  ✓
   20     (9, 10)           1         1  ✓
   21    (10, 11)           4         4  ✓

  Total mismatches: 0 / 22
  ✓ Perfect match: spliced path exactly reproduces flow_corrected!
